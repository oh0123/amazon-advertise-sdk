// Package tacticalrecommendations provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.15.0 DO NOT EDIT.
package tacticalrecommendations

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
)

// Defines values for AdProduct.
const (
	SB AdProduct = "SB"
	SD AdProduct = "SD"
	SP AdProduct = "SP"
)

// Defines values for BiddingStrategy.
const (
	AUTOFORSALES   BiddingStrategy = "AUTO_FOR_SALES"
	LEGACYFORSALES BiddingStrategy = "LEGACY_FOR_SALES"
	MANUAL         BiddingStrategy = "MANUAL"
	RULEBASED      BiddingStrategy = "RULE_BASED"
)

// Defines values for FilterField.
const (
	ADPRODUCT          FilterField = "AD_PRODUCT"
	CAMPAIGNID         FilterField = "CAMPAIGN_ID"
	GROUPINGTYPE       FilterField = "GROUPING_TYPE"
	RECOMMENDATIONID   FilterField = "RECOMMENDATION_ID"
	RECOMMENDATIONTYPE FilterField = "RECOMMENDATION_TYPE"
	STATUS             FilterField = "STATUS"
)

// Defines values for FilterOperator.
const (
	FilterOperatorEXACT FilterOperator = "EXACT"
)

// Defines values for GroupingType.
const (
	ADDTARGETSCONTEXTUAL                  GroupingType = "ADD_TARGETS_CONTEXTUAL"
	CAMPAIGNINCREASECLICKS                GroupingType = "CAMPAIGN_INCREASE_CLICKS"
	DECREASEBIDCONTEXTUAL                 GroupingType = "DECREASE_BID_CONTEXTUAL"
	INCREASEBIDCONTEXTUAL                 GroupingType = "INCREASE_BID_CONTEXTUAL"
	INCREASEBUDGETCONTEXTUAL              GroupingType = "INCREASE_BUDGET_CONTEXTUAL"
	INCREASECLICKTHROUGHRATE              GroupingType = "INCREASE_CLICKTHROUGH_RATE"
	INCREASECONVERSIONRATE                GroupingType = "INCREASE_CONVERSION_RATE"
	INSEASONASIN                          GroupingType = "IN_SEASON_ASIN"
	NEWASIN                               GroupingType = "NEW_ASIN"
	OPTIMIZEATTRIBUTEDORDERS              GroupingType = "OPTIMIZE_ATTRIBUTED_ORDERS"
	OPTIMIZECLICKS                        GroupingType = "OPTIMIZE_CLICKS"
	OPTIMIZECOSTPERCLICK                  GroupingType = "OPTIMIZE_COST_PER_CLICK"
	OPTIMIZECOSTPERNEWTOBRANDORDERS       GroupingType = "OPTIMIZE_COST_PER_NEW_TO_BRAND_ORDERS"
	OPTIMIZENEWTOBRANDORDERS              GroupingType = "OPTIMIZE_NEW_TO_BRAND_ORDERS"
	OPTIMIZEROAS                          GroupingType = "OPTIMIZE_ROAS"
	UNDERPERFORMINGCAMPAIGNINCREASECLICKS GroupingType = "UNDERPERFORMING_CAMPAIGN_INCREASE_CLICKS"
)

// Defines values for KeywordSortingDimension.
const (
	CLICK      KeywordSortingDimension = "CLICK"
	CONVERSION KeywordSortingDimension = "CONVERSION"
)

// Defines values for Locale.
const (
	ArAE Locale = "ar_AE"
	CsCZ Locale = "cs_CZ"
	DeDE Locale = "de_DE"
	EnAE Locale = "en_AE"
	EnAU Locale = "en_AU"
	EnCA Locale = "en_CA"
	EnGB Locale = "en_GB"
	EnIN Locale = "en_IN"
	EnSG Locale = "en_SG"
	EnUS Locale = "en_US"
	EsCO Locale = "es_CO"
	EsES Locale = "es_ES"
	EsMX Locale = "es_MX"
	EsUS Locale = "es_US"
	FrCA Locale = "fr_CA"
	FrFR Locale = "fr_FR"
	HeIL Locale = "he_IL"
	HiIN Locale = "hi_IN"
	ItIT Locale = "it_IT"
	JaJP Locale = "ja_JP"
	KoKR Locale = "ko_KR"
	NlNL Locale = "nl_NL"
	PlPL Locale = "pl_PL"
	PtBR Locale = "pt_BR"
	SvSE Locale = "sv_SE"
	TaIN Locale = "ta_IN"
	ThTH Locale = "th_TH"
	TrTR Locale = "tr_TR"
	ViVN Locale = "vi_VN"
	ZhCN Locale = "zh_CN"
	ZhTW Locale = "zh_TW"
)

// Defines values for PublishedBy.
const (
	AMAZONADSACCOUNTTEAM PublishedBy = "AMAZON_ADS_ACCOUNT_TEAM"
)

// Defines values for RecommendationReason.
const (
	ATBIDFALLBACK                  RecommendationReason = "AT_BID_FALLBACK"
	ATNOTALLMATCHTYPEENABLED       RecommendationReason = "AT_NOT_ALL_MATCH_TYPE_ENABLED"
	MTBIDFALLBACK                  RecommendationReason = "MT_BID_FALLBACK"
	MTIRRELEVANTKEYWORDIMPRESSIONS RecommendationReason = "MT_IRRELEVANT_KEYWORD_IMPRESSIONS"
	MTKEYWORDFALLBACK              RecommendationReason = "MT_KEYWORD_FALLBACK"
	MTKEYWORDSHAVELOWIMPRESSIONS   RecommendationReason = "MT_KEYWORDS_HAVE_LOW_IMPRESSIONS"
	MTNOTENOUGHTOPIMPRESSIONS      RecommendationReason = "MT_NOT_ENOUGH_TOP_IMPRESSIONS"
)

// Defines values for RecommendationStatus.
const (
	APPLYFAILED     RecommendationStatus = "APPLY_FAILED"
	APPLYINPROGRESS RecommendationStatus = "APPLY_IN_PROGRESS"
	APPLYSUCCESS    RecommendationStatus = "APPLY_SUCCESS"
	PUBLISHED       RecommendationStatus = "PUBLISHED"
	REJECTED        RecommendationStatus = "REJECTED"
)

// Defines values for RecommendationType.
const (
	ADGROUPBIDOPTIMIZATION         RecommendationType = "AD_GROUP_BID_OPTIMIZATION"
	ADGROUPDEFAULTBID              RecommendationType = "AD_GROUP_DEFAULT_BID"
	ADGROUPSTATE                   RecommendationType = "AD_GROUP_STATE"
	AUDIENCETARGETINGBID           RecommendationType = "AUDIENCE_TARGETING_BID"
	AUDIENCETARGETINGSTATE         RecommendationType = "AUDIENCE_TARGETING_STATE"
	CAMPAIGNBIDDINGRULE            RecommendationType = "CAMPAIGN_BIDDING_RULE"
	CAMPAIGNBIDDINGSTRATEGY        RecommendationType = "CAMPAIGN_BIDDING_STRATEGY"
	CAMPAIGNBUDGET                 RecommendationType = "CAMPAIGN_BUDGET"
	CAMPAIGNBUDGETRULE             RecommendationType = "CAMPAIGN_BUDGET_RULE"
	CAMPAIGNENDDATE                RecommendationType = "CAMPAIGN_END_DATE"
	CAMPAIGNPRODUCTPLACEMENT       RecommendationType = "CAMPAIGN_PRODUCT_PLACEMENT"
	CAMPAIGNSTATE                  RecommendationType = "CAMPAIGN_STATE"
	CAMPAIGNTOPPLACEMENT           RecommendationType = "CAMPAIGN_TOP_PLACEMENT"
	KEYWORDBID                     RecommendationType = "KEYWORD_BID"
	KEYWORDSTATE                   RecommendationType = "KEYWORD_STATE"
	NEGATIVEAUDIENCETARGETINGSTATE RecommendationType = "NEGATIVE_AUDIENCE_TARGETING_STATE"
	NEGATIVEKEYWORDSTATE           RecommendationType = "NEGATIVE_KEYWORD_STATE"
	NEGATIVEPRODUCTTARGETINGSTATE  RecommendationType = "NEGATIVE_PRODUCT_TARGETING_STATE"
	NEWADGROUP                     RecommendationType = "NEW_AD_GROUP"
	NEWAUDIENCETARGETING           RecommendationType = "NEW_AUDIENCE_TARGETING"
	NEWCAMPAIGN                    RecommendationType = "NEW_CAMPAIGN"
	NEWCAMPAIGNBIDDINGRULE         RecommendationType = "NEW_CAMPAIGN_BIDDING_RULE"
	NEWCAMPAIGNBUDGETRULE          RecommendationType = "NEW_CAMPAIGN_BUDGET_RULE"
	NEWKEYWORD                     RecommendationType = "NEW_KEYWORD"
	NEWNEGATIVEAUDIENCETARGETING   RecommendationType = "NEW_NEGATIVE_AUDIENCE_TARGETING"
	NEWNEGATIVEKEYWORD             RecommendationType = "NEW_NEGATIVE_KEYWORD"
	NEWNEGATIVEPRODUCTTARGETING    RecommendationType = "NEW_NEGATIVE_PRODUCT_TARGETING"
	NEWPRODUCTAD                   RecommendationType = "NEW_PRODUCT_AD"
	NEWPRODUCTTARGETING            RecommendationType = "NEW_PRODUCT_TARGETING"
	NEWVIDEOCAMPAIGN               RecommendationType = "NEW_VIDEO_CAMPAIGN"
	PRODUCTADSTATE                 RecommendationType = "PRODUCT_AD_STATE"
	PRODUCTTARGETINGBID            RecommendationType = "PRODUCT_TARGETING_BID"
	PRODUCTTARGETINGSTATE          RecommendationType = "PRODUCT_TARGETING_STATE"
)

// Defines values for SummaryCode.
const (
	ADDTARGETSCONTEXTUALSUMMARY     SummaryCode = "ADD_TARGETS_CONTEXTUAL_SUMMARY"
	DECREASEBIDCONTEXTUALSUMMARY    SummaryCode = "DECREASE_BID_CONTEXTUAL_SUMMARY"
	INCREASEBIDCONTEXTUALSUMMARY    SummaryCode = "INCREASE_BID_CONTEXTUAL_SUMMARY"
	INCREASEBUDGETCONTEXTUALSUMMARY SummaryCode = "INCREASE_BUDGET_CONTEXTUAL_SUMMARY"
)

// Defines values for TargetingMatchType.
const (
	TargetingMatchTypeBROAD                         TargetingMatchType = "BROAD"
	TargetingMatchTypeEXACT                         TargetingMatchType = "EXACT"
	TargetingMatchTypeNEGATIVEBROAD                 TargetingMatchType = "NEGATIVE_BROAD"
	TargetingMatchTypeNEGATIVEEXACT                 TargetingMatchType = "NEGATIVE_EXACT"
	TargetingMatchTypeNEGATIVEPHRASE                TargetingMatchType = "NEGATIVE_PHRASE"
	TargetingMatchTypePHRASE                        TargetingMatchType = "PHRASE"
	TargetingMatchTypeTARGETINGEXPRESSION           TargetingMatchType = "TARGETING_EXPRESSION"
	TargetingMatchTypeTARGETINGEXPRESSIONPREDEFINED TargetingMatchType = "TARGETING_EXPRESSION_PREDEFINED"
)

// APIError Error response object providing information on API error.
type APIError struct {
	// Code HTTP status code of the response.
	Code string `json:"code"`

	// Message A human-readable description of the response.
	Message string `json:"message"`
}

// APISuccess Response object providing information on API success.
type APISuccess struct {
	// Code HTTP status code of the response.
	Code string `json:"code"`

	// Message A human-readable description of the response.
	Message string `json:"message"`
}

// AdProduct defines model for AdProduct.
type AdProduct string

// ApplyRecommendationFailure defines model for ApplyRecommendationFailure.
type ApplyRecommendationFailure struct {
	// Error Error response object providing information on API error.
	Error APIError `json:"error"`

	// Index Index of the recommendation in the array from the request body.
	Index float32 `json:"index"`

	// RecommendationId Recommendation identifier.
	RecommendationId string `json:"recommendationId"`
}

// ApplyRecommendationSuccess defines model for ApplyRecommendationSuccess.
type ApplyRecommendationSuccess struct {
	// Index Index of the recommendation in the array from the request body.
	Index          float32        `json:"index"`
	Recommendation Recommendation `json:"recommendation"`

	// RecommendationId Recommendation identifier.
	RecommendationId string `json:"recommendationId"`

	// Success Response object providing information on API success.
	Success APISuccess `json:"success"`
}

// ApplyRecommendationsRequest defines model for ApplyRecommendationsRequest.
type ApplyRecommendationsRequest struct {
	// RecommendationIds Recommendation identifier.
	RecommendationIds []string `json:"recommendationIds"`
}

// ApplyRecommendationsResponse defines model for ApplyRecommendationsResponse.
type ApplyRecommendationsResponse struct {
	Failures  []ApplyRecommendationFailure `json:"failures"`
	Successes []ApplyRecommendationSuccess `json:"successes"`
}

// AsinContext Underlying asin context behind generating the recommendation.
type AsinContext struct {
	// SeasonEndDate Date in which the products in the advertiser's category historically traffic-increase has cooled off.
	SeasonEndDate *openapi_types.Date `json:"seasonEndDate,omitempty"`

	// SeasonStartDate Date in which the products in the advertiser's category have historically started to see an increase in traffic.
	SeasonStartDate *openapi_types.Date `json:"seasonStartDate,omitempty"`

	// Trailing4WeeksClickthroughRate Past 4 weeks clickthrough rate of target product type.
	Trailing4WeeksClickthroughRate *float32 `json:"trailing4WeeksClickthroughRate,omitempty"`

	// Trailing4WeeksConversionRate Past 4 weeks conversion rate of target product type.
	Trailing4WeeksConversionRate *float32 `json:"trailing4WeeksConversionRate,omitempty"`
}

// Benchmark A Benchmark
type Benchmark struct {
	// BenchmarkValue The benchmark for the campaign for a given metric. This value is based on the performance of similar campaigns for the given metric over the specific time period.
	BenchmarkValue *float32 `json:"benchmarkValue,omitempty"`

	// Period The time period in days over which the metric value was determined.
	Period *float32 `json:"period,omitempty"`
}

// BenchmarkContext Benchmark Context for the recommendation.
//
//	| Benchmark | Description |
//
// |---|---|
// | Impressions | Impressions received by the campaign over the specified time period |
// | Roas | Return on ad spend (RoAS) for the campaign over the specified time period |
// | AdSpend | The ad spend incurrend by the campaign over the specified time period |
// | ClickthroughRate | The clickthrough rate of the campaign over the specified time period |
// | BudgetUtilization | Average budget used by the campaign as a percent of total budget allocated, over the specified time period |
type BenchmarkContext struct {
	// AdSpend A Benchmark
	AdSpend *Benchmark `json:"adSpend,omitempty"`

	// BudgetUtilization A Benchmark
	BudgetUtilization *Benchmark `json:"budgetUtilization,omitempty"`

	// ClickthroughRate A Benchmark
	ClickthroughRate *Benchmark `json:"clickthroughRate,omitempty"`

	// Impressions A Benchmark
	Impressions *Benchmark `json:"impressions,omitempty"`

	// Roas A Benchmark
	Roas *Benchmark `json:"roas,omitempty"`
}

// BiddingStrategy Campaign bidding strategy.
type BiddingStrategy string

// BudgetRecommendation Budget recommendation of the campaign to which this recommendation is associated.
type BudgetRecommendation struct {
	// SevenDaysMissedOpportunities Seven days of missed opportunities.
	SevenDaysMissedOpportunities SevenDaysMissedOpportunities `json:"sevenDaysMissedOpportunities"`
}

// BudgetRule Budget rule of the campaign to which this recommendation is associated.
type BudgetRule struct {
	RuleDetails BudgetRuleDetails `json:"ruleDetails"`

	// RuleId Identifier of the budget rule.
	RuleId *string `json:"ruleId,omitempty"`
}

// BudgetRuleDateRangeTypeDuration defines model for BudgetRuleDateRangeTypeDuration.
type BudgetRuleDateRangeTypeDuration struct {
	// EndDate End date of the budget rule in YYYY-MM-DD format. The end date is inclusive.
	EndDate *openapi_types.Date `json:"endDate,omitempty"`

	// StartDate Start date of the budget rule in YYYY-MM-DD format. The start date is inclusive.
	StartDate openapi_types.Date `json:"startDate"`
}

// BudgetRuleDetails defines model for BudgetRuleDetails.
type BudgetRuleDetails struct {
	BudgetIncreaseBy            *BudgetRuleIncreaseBy                  `json:"budgetIncreaseBy,omitempty"`
	Duration                    *BudgetRuleDuration                    `json:"duration,omitempty"`
	PerformanceMeasureCondition *BudgetRulePerformanceMeasureCondition `json:"performanceMeasureCondition,omitempty"`

	// RuleName Name of the budget rule.
	RuleName *string `json:"ruleName,omitempty"`

	// RuleType Type of budget rule.
	RuleType *string `json:"ruleType,omitempty"`
}

// BudgetRuleDuration defines model for BudgetRuleDuration.
type BudgetRuleDuration struct {
	DateRangeTypeDuration *BudgetRuleDateRangeTypeDuration `json:"dateRangeTypeDuration,omitempty"`
	EventTypeDuration     *BudgetRuleEventTypeDuration     `json:"eventTypeDuration,omitempty"`
}

// BudgetRuleEventTypeDuration defines model for BudgetRuleEventTypeDuration.
type BudgetRuleEventTypeDuration struct {
	// EndDate End date of the event in YYYY-MM-DD format.
	EndDate *openapi_types.Date `json:"endDate,omitempty"`

	// EventId Identifier of the event.
	EventId string `json:"eventId"`

	// StartDate Start date of the event in YYYY-MM-DD format. Note that this field is present only for announced events.
	StartDate *openapi_types.Date `json:"startDate,omitempty"`
}

// BudgetRuleIncreaseBy defines model for BudgetRuleIncreaseBy.
type BudgetRuleIncreaseBy struct {
	// Value Budget of the rule.
	Value float32 `json:"value"`
}

// BudgetRulePerformanceMeasureCondition defines model for BudgetRulePerformanceMeasureCondition.
type BudgetRulePerformanceMeasureCondition struct {
	// Threshold Threshold of the performance metric.
	Threshold float32 `json:"threshold"`
}

// CampaignEstimatedImpact Estimated impact at the campaign level.
type CampaignEstimatedImpact struct {
	// Clicks Estimated impact of the recommendation on clicks.
	Clicks *EstimatedImpactClicks `json:"clicks,omitempty"`

	// Cost Estimated impact of the recommendation on cost.
	Cost *EstimatedImpactCost `json:"cost,omitempty"`

	// Impressions Estimated impact of the recommendation on impressions.
	Impressions *EstimatedImpactImpressions `json:"impressions,omitempty"`

	// IncrementalSalesIncrementalCostRatio Estimated impact of the recommendation on incremental sales and incremental cost ratio.
	IncrementalSalesIncrementalCostRatio *EstimatedImpactIncrementalSalesIncrementalCostRatio `json:"incrementalSalesIncrementalCostRatio,omitempty"`

	// Roas Estimated impact of the recommendation on ROAS.
	Roas *EstimatedImpactRoas `json:"roas,omitempty"`

	// Sales Estimated impact of the recommendation on sales.
	Sales *EstimatedImpactSales `json:"sales,omitempty"`

	// TimePeriodInDays Time period of the estimated impact in days.
	TimePeriodInDays int `json:"timePeriodInDays"`
}

// ConsolidatedRecommendation Data for a group of recommendations.
type ConsolidatedRecommendation struct {
	// RecommendationReasons List of reasons why the recommendation was created
	RecommendationReasons *RecommendationReasons `json:"recommendationReasons,omitempty"`

	// SevenDaysEstimatedOpportunities Seven days of estimated opportunities.
	SevenDaysEstimatedOpportunities *SevenDaysEstimatedOpportunities `json:"sevenDaysEstimatedOpportunities,omitempty"`
}

// DiagnosticContext Underlying diagnostic context behind generating the recommendation.
type DiagnosticContext struct {
	// AsinAge The number of days since the ASIN was added to the advertiser’s catalog.
	AsinAge *float32 `json:"asinAge,omitempty"`

	// BenchmarkContext Benchmark Context for the recommendation.
	//  | Benchmark | Description |
	// |---|---|
	// | Impressions | Impressions received by the campaign over the specified time period |
	// | Roas | Return on ad spend (RoAS) for the campaign over the specified time period |
	// | AdSpend | The ad spend incurrend by the campaign over the specified time period |
	// | ClickthroughRate | The clickthrough rate of the campaign over the specified time period |
	// | BudgetUtilization | Average budget used by the campaign as a percent of total budget allocated, over the specified time period |
	BenchmarkContext *BenchmarkContext `json:"benchmarkContext,omitempty"`

	// DiagnosticDate The date on which the campaign was diagnosed.
	DiagnosticDate *openapi_types.Date `json:"diagnosticDate,omitempty"`

	// Summary An explanation of the campaign performance vis-a-vis relevant benchmarks, and why the recommendation was generated.
	Summary *Summary `json:"summary,omitempty"`
}

// EstimatedImpact Estimated impact of the recommendation.
type EstimatedImpact struct {
	// Campaign Estimated impact at the campaign level.
	Campaign *CampaignEstimatedImpact `json:"campaign,omitempty"`
}

// EstimatedImpactClicks Estimated impact of the recommendation on clicks.
type EstimatedImpactClicks struct {
	// IncrementalLowerBound Lower bound of the estimated change in clicks seen for similar advertisers within the time period indicated when the recommendation is adopted.
	IncrementalLowerBound float32 `json:"incrementalLowerBound"`

	// IncrementalUpperBound Upper bound of the estimated change in clicks seen for similar advertisers within the time period indicated when the recommendation is adopted.
	IncrementalUpperBound float32 `json:"incrementalUpperBound"`
}

// EstimatedImpactCost Estimated impact of the recommendation on cost.
type EstimatedImpactCost struct {
	// IncrementalLowerBound Lower bound of the estimated change in cost seen for similar advertisers within the time period indicated when the recommendation is adopted.
	IncrementalLowerBound float32 `json:"incrementalLowerBound"`

	// IncrementalUpperBound Upper bound of the estimated change in cost seen for similar advertisers within the time period indicated when the recommendation is adopted.
	IncrementalUpperBound float32 `json:"incrementalUpperBound"`
}

// EstimatedImpactImpressions Estimated impact of the recommendation on impressions.
type EstimatedImpactImpressions struct {
	// IncrementalLowerBound Lower bound of the estimated change in impressions seen for similar advertisers within the time period indicated when the recommendation is adopted.
	IncrementalLowerBound float32 `json:"incrementalLowerBound"`

	// IncrementalUpperBound Upper bound of the estimated change in impressions seen for similar advertisers within the time period indicated when the recommendation is adopted.
	IncrementalUpperBound float32 `json:"incrementalUpperBound"`
}

// EstimatedImpactIncrementalSalesIncrementalCostRatio Estimated impact of the recommendation on incremental sales and incremental cost ratio.
type EstimatedImpactIncrementalSalesIncrementalCostRatio struct {
	// IncrementalLowerBound Lower bound of the estimated change in incremental sales to incremental cost ratio seen for similar advertisers within the time period indicated when the recommendation is adopted.
	IncrementalLowerBound float32 `json:"incrementalLowerBound"`

	// IncrementalUpperBound Upper bound of the estimated change in incremental sales to incremental cost ratio seen for similar advertisers within the time period indicated when the recommendation is adopted.
	IncrementalUpperBound float32 `json:"incrementalUpperBound"`
}

// EstimatedImpactRoas Estimated impact of the recommendation on ROAS.
type EstimatedImpactRoas struct {
	// IncrementalLowerBound Lower bound of the estimated change in ROAS seen for similar advertisers within the time period indicated when the recommendation is adopted.
	IncrementalLowerBound float32 `json:"incrementalLowerBound"`

	// IncrementalUpperBound Upper bound of the estimated change in ROAS seen for similar advertisers within the time period indicated when the recommendation is adopted.
	IncrementalUpperBound float32 `json:"incrementalUpperBound"`
}

// EstimatedImpactSales Estimated impact of the recommendation on sales.
type EstimatedImpactSales struct {
	// IncrementalLowerBound Lower bound of the estimated change in sales seen for similar advertisers within the time period indicated when the recommendation is adopted.
	IncrementalLowerBound float32 `json:"incrementalLowerBound"`

	// IncrementalUpperBound Upper bound of the estimated change in sales seen for similar advertisers within the time period indicated when the recommendation is adopted.
	IncrementalUpperBound float32 `json:"incrementalUpperBound"`
}

// FilterField Field to filter by.
type FilterField string

// FilterOperator Operator to filter field by.
type FilterOperator string

// GroupingType Type of grouping for consolidated recommendation data.
//
//	| Type of grouping | Description |
//
// |---|---|
// | CAMPAIGN_INCREASE_CLICKS | Recommendation grouping type for generating additional clicks for campaigns |
// | OPTIMIZE_ATTRIBUTED_ORDERS | Recommendation grouping type for optimizing attributed orders |
// | OPTIMIZE_CLICKS | Recommendation grouping type for optimizing clicks |
// | OPTIMIZE_COST_PER_CLICK | Recommendation grouping type for optimizing cost per click |
// | OPTIMIZE_COST_PER_NEW_TO_BRAND_ORDERS | Recommendation grouping type for optimizing cost per new-to-brand orders |
// | OPTIMIZE_NEW_TO_BRAND_ORDERS | Recommendation grouping type for optimizing new-to-brand orders |
// | OPTIMIZE_ROAS | Recommendation grouping type for optimizing ROAS |
// | UNDERPERFORMING_CAMPAIGN_INCREASE_CLICKS | Recommendation grouping type for zero-click campaigns |
// | INCREASE_BUDGET_CONTEXTUAL | Recommendation grouping type for increasing budget based on contextual diagnostics |
// | INCREASE_BID_CONTEXTUAL | Recommendation grouping type for increasing bids based on contextual diagnostics |
// | DECREASE_BID_CONTEXTUAL | Recommendation grouping type for decreasing bids based on contextual diagnostics |
// | ADD_TARGETS_CONTEXTUAL | Recommendation grouping type for adding targets based on contextual diagnostics |
// | IN_SEASON_ASIN | Recommendation grouping type for ASINs that are in-season |
// | INCREASE_CLICKTHROUGH_RATE | Recommendation grouping type for ASINs that have low clickthrough rate compared to benchmarks |
// | INCREASE_CONVERSION_RATE | Recommendation grouping type for ASINs that have low conversion rate compared to benchmarks |
// | NEW_ASIN | Recommendation grouping type for unadvertised ASINs that have recently been added to the catalog |
type GroupingType string

// KeywordSortingDimension Sorting dimension for new keyword recommendations.
type KeywordSortingDimension string

// ListRecommendationsFilter defines model for ListRecommendationsFilter.
type ListRecommendationsFilter struct {
	// Field Field to filter by.
	Field FilterField `json:"field"`

	// Include Flag to specify if the filter should be included or excluded.
	Include *bool `json:"include,omitempty"`

	// Operator Operator to filter field by.
	Operator FilterOperator `json:"operator"`
	Values   []string       `json:"values"`
}

// ListRecommendationsRequest defines model for ListRecommendationsRequest.
type ListRecommendationsRequest struct {
	Filters *[]ListRecommendationsFilter `json:"filters,omitempty"`

	// Locale This will control the language of preference returned for the summary field.
	Locale     *Locale `json:"locale,omitempty"`
	MaxResults *int    `json:"maxResults,omitempty"`

	// NextToken Token to retrieve the next page of results.
	NextToken *string `json:"nextToken,omitempty"`
}

// ListRecommendationsResponse defines model for ListRecommendationsResponse.
type ListRecommendationsResponse struct {
	// NextToken Token to retrieve the next page of results.
	NextToken       *string          `json:"nextToken,omitempty"`
	Recommendations []Recommendation `json:"recommendations"`

	// TotalResults Total number of results.
	TotalResults int `json:"totalResults"`
}

// Locale Eligible language codes.
type Locale string

// PublishMetadata Metadata for publishing the recommendation.
type PublishMetadata struct {
	// PublishedBy Publisher of the recommendation.
	PublishedBy PublishedBy `json:"publishedBy"`

	// PublishedToAmazonAdConsole Indicates if recommendation was published to Amazon Ad Console.
	PublishedToAmazonAdConsole bool `json:"publishedToAmazonAdConsole"`
}

// PublishedBy Publisher of the recommendation.
type PublishedBy string

// Recommendation defines model for Recommendation.
type Recommendation struct {
	// AdGroupId Identifier of the ad group to which this recommendation is associated.
	AdGroupId *string `json:"adGroupId,omitempty"`

	// AdId Identifier of the product ad to which this recommendation is associated.
	AdId      *string   `json:"adId,omitempty"`
	AdProduct AdProduct `json:"adProduct"`

	// ApplyFailureReason A human-readable description of why the recommendation failed to apply.
	ApplyFailureReason *string `json:"applyFailureReason,omitempty"`

	// Asin ASIN associated with the product. Defined for vendors only.
	Asin *string `json:"asin,omitempty"`

	// AsinGroupTemplateId Identifier of the asin group template to which this recommendation is associated.
	AsinGroupTemplateId *string `json:"asinGroupTemplateId,omitempty"`

	// BudgetRecommendation Budget recommendation of the campaign to which this recommendation is associated.
	BudgetRecommendation *BudgetRecommendation `json:"budgetRecommendation,omitempty"`

	// BudgetRule Budget rule of the campaign to which this recommendation is associated.
	BudgetRule *BudgetRule `json:"budgetRule,omitempty"`

	// CampaignId Identifier of the campaign to which this recommendation is associated.
	CampaignId *string `json:"campaignId,omitempty"`

	// CampaignTemplateId Identifier of the campaign template to which this recommendation is associated.
	CampaignTemplateId *string `json:"campaignTemplateId,omitempty"`

	// ConsolidatedRecommendation Data for a group of recommendations.
	ConsolidatedRecommendation *ConsolidatedRecommendation `json:"consolidatedRecommendation,omitempty"`

	// CurrentValue Current value of the campaign entity to which this recommendation is associated. Will be null if the recommendation is for a new campaign entity.
	CurrentValue *string `json:"currentValue,omitempty"`

	// EstimatedImpact Estimated impact of the recommendation.
	EstimatedImpact *EstimatedImpact `json:"estimatedImpact,omitempty"`

	// GroupingType Type of grouping for consolidated recommendation data.
	//  | Type of grouping | Description |
	// |---|---|
	// | CAMPAIGN_INCREASE_CLICKS | Recommendation grouping type for generating additional clicks for campaigns |
	// | OPTIMIZE_ATTRIBUTED_ORDERS | Recommendation grouping type for optimizing attributed orders |
	// | OPTIMIZE_CLICKS | Recommendation grouping type for optimizing clicks |
	// | OPTIMIZE_COST_PER_CLICK | Recommendation grouping type for optimizing cost per click |
	// | OPTIMIZE_COST_PER_NEW_TO_BRAND_ORDERS | Recommendation grouping type for optimizing cost per new-to-brand orders |
	// | OPTIMIZE_NEW_TO_BRAND_ORDERS | Recommendation grouping type for optimizing new-to-brand orders |
	// | OPTIMIZE_ROAS | Recommendation grouping type for optimizing ROAS |
	// | UNDERPERFORMING_CAMPAIGN_INCREASE_CLICKS | Recommendation grouping type for zero-click campaigns |
	// | INCREASE_BUDGET_CONTEXTUAL | Recommendation grouping type for increasing budget based on contextual diagnostics |
	// | INCREASE_BID_CONTEXTUAL | Recommendation grouping type for increasing bids based on contextual diagnostics |
	// | DECREASE_BID_CONTEXTUAL | Recommendation grouping type for decreasing bids based on contextual diagnostics |
	// | ADD_TARGETS_CONTEXTUAL | Recommendation grouping type for adding targets based on contextual diagnostics |
	// | IN_SEASON_ASIN | Recommendation grouping type for ASINs that are in-season |
	// | INCREASE_CLICKTHROUGH_RATE | Recommendation grouping type for ASINs that have low clickthrough rate compared to benchmarks |
	// | INCREASE_CONVERSION_RATE | Recommendation grouping type for ASINs that have low conversion rate compared to benchmarks |
	// | NEW_ASIN | Recommendation grouping type for unadvertised ASINs that have recently been added to the catalog |
	GroupingType *GroupingType `json:"groupingType,omitempty"`

	// KeywordSortingDimension Sorting dimension for new keyword recommendations.
	KeywordSortingDimension *KeywordSortingDimension `json:"keywordSortingDimension,omitempty"`

	// KeywordSortingRank Sorting rank for new keyword recommendations.
	KeywordSortingRank *int `json:"keywordSortingRank,omitempty"`

	// PublishMetadata Metadata for publishing the recommendation.
	PublishMetadata *PublishMetadata `json:"publishMetadata,omitempty"`

	// RecommendationContext Context of the recommendation.
	RecommendationContext *RecommendationContext `json:"recommendationContext,omitempty"`

	// RecommendationId Recommendation identifier.
	RecommendationId string `json:"recommendationId"`

	// RecommendationType Type of recommendation to apply certain changes to the advertiser's sponsored ads.
	RecommendationType RecommendationType `json:"recommendationType"`

	// RecommendedValue Recommended value of the campaign entity to which this recommendation is associated.
	RecommendedValue *string `json:"recommendedValue,omitempty"`

	// ResolvedTargeting Resolved targeting expression to which this recommendation is associated.
	ResolvedTargeting *string `json:"resolvedTargeting,omitempty"`

	// RuleBasedBidding Rule based bidding for the campaign to which this recommendation is associated.
	RuleBasedBidding *RuleBasedBidding `json:"ruleBasedBidding,omitempty"`

	// Sku SKU associated with the product. Defined for seller accounts only.
	Sku *string `json:"sku,omitempty"`

	// Status Status of the recommendation.
	Status RecommendationStatus `json:"status"`

	// TargetId Identifier of the target to which this recommendation is associated.
	TargetId *string `json:"targetId,omitempty"`

	// Targeting Targeting expression to which this recommendation is associated.
	Targeting *string `json:"targeting,omitempty"`

	// TargetingMatchType Match type of the target for keyword and targeting recommendations.
	TargetingMatchType *TargetingMatchType `json:"targetingMatchType,omitempty"`
}

// RecommendationContext Context of the recommendation.
type RecommendationContext struct {
	// AsinContext Underlying asin context behind generating the recommendation.
	AsinContext *AsinContext `json:"asinContext,omitempty"`

	// DiagnosticContext Underlying diagnostic context behind generating the recommendation.
	DiagnosticContext *DiagnosticContext `json:"diagnosticContext,omitempty"`
}

// RecommendationReason Type of reason why the recommendation was created.
//
//	| Type of reason | Description |
//
// |---|---|
// | AT_NOT_ALL_MATCH_TYPE_ENABLED | Auto targeting campaign does not have all match types enabled |
// | AT_BID_FALLBACK | Auto targeting bid fallback reason |
// | MT_NOT_ENOUGH_TOP_IMPRESSIONS | Manual targeting campaign not getting enough top impressions |
// | MT_BID_FALLBACK | Manual targeting bid fallback reason |
// | MT_KEYWORDS_HAVE_LOW_IMPRESSIONS | Manual targeting keywords have low impressions |
// | MT_IRRELEVANT_KEYWORD_IMPRESSIONS | Manual targeting campaign has irrelevant keyword impressions |
// | MT_KEYWORD_FALLBACK | Manual targeting keyword fallback reason |
type RecommendationReason string

// RecommendationReasons List of reasons why the recommendation was created
type RecommendationReasons = []RecommendationReason

// RecommendationStatus Status of the recommendation.
type RecommendationStatus string

// RecommendationType Type of recommendation to apply certain changes to the advertiser's sponsored ads.
type RecommendationType string

// RuleBasedBidding Rule based bidding for the campaign to which this recommendation is associated.
type RuleBasedBidding struct {
	// CampaignOptimizationId Identifier of the campaign optimization.
	CampaignOptimizationId *string `json:"campaignOptimizationId,omitempty"`

	// CurrentBiddingStrategy Campaign bidding strategy.
	CurrentBiddingStrategy *BiddingStrategy `json:"currentBiddingStrategy,omitempty"`

	// CurrentRuleRoas Current threshold of the RoAS performance metric.
	CurrentRuleRoas *float32 `json:"currentRuleRoas,omitempty"`

	// RecommendedBiddingStrategy Campaign bidding strategy.
	RecommendedBiddingStrategy BiddingStrategy `json:"recommendedBiddingStrategy"`

	// RecommendedRuleRoas Recommended threshold of the RoAS performance metric.
	RecommendedRuleRoas float32 `json:"recommendedRuleRoas"`
}

// SevenDaysEstimatedOpportunities Seven days of estimated opportunities.
type SevenDaysEstimatedOpportunities struct {
	// EndDate End date of the opportunities date range in YYYY-MM-DDTHH:mm:ssZ format.
	EndDate time.Time `json:"endDate"`

	// EstimatedIncrementalClicksLower Lower bound of estimated incremental clicks that could be gained if all recommendations are applied.
	EstimatedIncrementalClicksLower *int `json:"estimatedIncrementalClicksLower,omitempty"`

	// EstimatedIncrementalClicksUpper Upper bound of estimated incremental clicks that could be gained if all recommendations are applied.
	EstimatedIncrementalClicksUpper *int `json:"estimatedIncrementalClicksUpper,omitempty"`

	// StartDate Start date of the opportunities date range in YYYY-MM-DDTHH:mm:ssZ format.
	StartDate time.Time `json:"startDate"`
}

// SevenDaysMissedOpportunities Seven days of missed opportunities.
type SevenDaysMissedOpportunities struct {
	// EndDate End date of the date range in local time and YYYY-MM-DD format for which missed opportunity metrics are provided.
	EndDate openapi_types.Date `json:"endDate"`

	// EstimatedMissedClicksLower Lower bound of estimated missed clicks.
	EstimatedMissedClicksLower *int `json:"estimatedMissedClicksLower,omitempty"`

	// EstimatedMissedClicksUpper Upper bound of estimated missed clicks.
	EstimatedMissedClicksUpper *int `json:"estimatedMissedClicksUpper,omitempty"`

	// EstimatedMissedImpressionsLower Lower bound of estimated missed impressions.
	EstimatedMissedImpressionsLower *int `json:"estimatedMissedImpressionsLower,omitempty"`

	// EstimatedMissedImpressionsUpper Upper bound of estimated missed impressions.
	EstimatedMissedImpressionsUpper *int `json:"estimatedMissedImpressionsUpper,omitempty"`

	// EstimatedMissedSalesLower Lower bound of estimated missed sales. Provided in local currency.
	EstimatedMissedSalesLower *float32 `json:"estimatedMissedSalesLower,omitempty"`

	// EstimatedMissedSalesUpper Upper bound of estimated missed sales. Provided in local currency.
	EstimatedMissedSalesUpper *float32 `json:"estimatedMissedSalesUpper,omitempty"`

	// PercentTimeInBudget Percentage of time the campaign is active with a budget.
	PercentTimeInBudget *float32 `json:"percentTimeInBudget,omitempty"`

	// StartDate Start date of the date range in local time and YYYY-MM-DD format for which missed opportunity metrics are provided.
	StartDate openapi_types.Date `json:"startDate"`
}

// Summary An explanation of the campaign performance vis-a-vis relevant benchmarks, and why the recommendation was generated.
type Summary struct {
	// Code Summary Codes.
	//  | Code | Message |
	// |---|---|
	// | DECREASE_BID_CONTEXTUAL_SUMMARY | You have Sponsored Products campaigns with high impressions but low clickthrough rate, compared to similar campaigns. Applying these keyword bid recommendations can optimize your ROAS. |
	// | INCREASE_BID_CONTEXTUAL_SUMMARY | You have Sponsored Products campaigns with high clickthrough rate, compared to similar campaigns. Applying these keyword bid recommendations can increase sales. |
	// | INCREASE_BUDGET_CONTEXTUAL_SUMMARY | You have budget recommendations for Sponsored Products campaigns with high ROAS and high budget use, compared to similar campaigns. Applying these recommendations can optimize sales and keep your campaigns in budget. |
	// | ADD_TARGETS_CONTEXTUAL_SUMMARY | You have Sponsored Products campaigns with low clickthrough rate and low conversion rate, compared to similar campaigns. Applying these keyword recommendations can increase sales. |
	Code *SummaryCode `json:"code,omitempty"`

	// Message A localized description of the summary.
	Message *string `json:"message,omitempty"`
}

// SummaryCode Summary Codes.
//
//	| Code | Message |
//
// |---|---|
// | DECREASE_BID_CONTEXTUAL_SUMMARY | You have Sponsored Products campaigns with high impressions but low clickthrough rate, compared to similar campaigns. Applying these keyword bid recommendations can optimize your ROAS. |
// | INCREASE_BID_CONTEXTUAL_SUMMARY | You have Sponsored Products campaigns with high clickthrough rate, compared to similar campaigns. Applying these keyword bid recommendations can increase sales. |
// | INCREASE_BUDGET_CONTEXTUAL_SUMMARY | You have budget recommendations for Sponsored Products campaigns with high ROAS and high budget use, compared to similar campaigns. Applying these recommendations can optimize sales and keep your campaigns in budget. |
// | ADD_TARGETS_CONTEXTUAL_SUMMARY | You have Sponsored Products campaigns with low clickthrough rate and low conversion rate, compared to similar campaigns. Applying these keyword recommendations can increase sales. |
type SummaryCode string

// TargetingMatchType Match type of the target for keyword and targeting recommendations.
type TargetingMatchType string

// UpdateBudgetRule Can only be updated for recommendations with recommendationType NEW_CAMPAIGN_BUDGET_RULE or CAMPAIGN_BUDGET_RULE.
type UpdateBudgetRule struct {
	RuleDetails UpdateBudgetRuleDetails `json:"ruleDetails"`
}

// UpdateBudgetRuleDetails defines model for UpdateBudgetRuleDetails.
type UpdateBudgetRuleDetails struct {
	BudgetIncreaseBy            *BudgetRuleIncreaseBy                  `json:"budgetIncreaseBy,omitempty"`
	Duration                    *UpdateBudgetRuleDuration              `json:"duration,omitempty"`
	PerformanceMeasureCondition *BudgetRulePerformanceMeasureCondition `json:"performanceMeasureCondition,omitempty"`

	// RuleName Name of the budget rule. Required to be unique within a campaign.
	RuleName *string `json:"ruleName,omitempty"`
}

// UpdateBudgetRuleDuration defines model for UpdateBudgetRuleDuration.
type UpdateBudgetRuleDuration struct {
	DateRangeTypeDuration *UpdateBudgetRuleDurationDateRange `json:"dateRangeTypeDuration,omitempty"`
}

// UpdateBudgetRuleDurationDateRange defines model for UpdateBudgetRuleDurationDateRange.
type UpdateBudgetRuleDurationDateRange struct {
	// EndDate End date of the budget rule in YYYY-MM-DD format. The end date is inclusive.
	EndDate *openapi_types.Date `json:"endDate,omitempty"`
}

// UpdateRecommendationRequest defines model for UpdateRecommendationRequest.
type UpdateRecommendationRequest struct {
	// BudgetRule Can only be updated for recommendations with recommendationType NEW_CAMPAIGN_BUDGET_RULE or CAMPAIGN_BUDGET_RULE.
	BudgetRule *UpdateBudgetRule `json:"budgetRule,omitempty"`

	// RecommendedValue Recommended value of the recommendation. Type of data expected for each recommendation type:
	// | Recommendation type | Data type |
	// |---|---|
	// | CAMPAIGN_BUDGET, CAMPAIGN_TOP_PLACEMENT, CAMPAIGN_PRODUCT_PLACEMENT, AD_GROUP_DEFAULT_BID, NEW_KEYWORD, KEYWORD_BID, NEW_PRODUCT_TARGETING, PRODUCT_TARGETING_BID, NEW_AUDIENCE_TARGETING, AUDIENCE_TARGETING_BID | number |
	// | CAMPAIGN_END_DATE | string($YYYY-MM-DD) |
	// | AD_GROUP_BID_OPTIMIZATION | One of [ CLICKS, CONVERSIONS, REACH ] |
	// | CAMPAIGN_BIDDING_STRATEGY | One of [ LEGACY_FOR_SALES, AUTO_FOR_SALES, MANUAL ] |
	// | CAMPAIGN_STATE, AD_GROUP_STATE, KEYWORD_STATE, NEGATIVE_KEYWORD_STATE, PRODUCT_AD_STATE, PRODUCT_TARGETING_STATE, NEGATIVE_PRODUCT_TARGETING_STATE, AUDIENCE_TARGETING_STATE, NEGATIVE_AUDIENCE_TARGETING_STATE | One of [ ENABLED, PAUSED, ARCHIVED ] |
	RecommendedValue *string `json:"recommendedValue,omitempty"`

	// RuleBasedBidding Can only be updated for recommendations with recommendationType NEW_CAMPAIGN_BIDDING_RULE or CAMPAIGN_BIDDING_RULE.
	RuleBasedBidding *UpdateRuleBasedBidding `json:"ruleBasedBidding,omitempty"`
}

// UpdateRuleBasedBidding Can only be updated for recommendations with recommendationType NEW_CAMPAIGN_BIDDING_RULE or CAMPAIGN_BIDDING_RULE.
type UpdateRuleBasedBidding struct {
	RecommendedRuleRoas float32 `json:"recommendedRuleRoas"`
}

// ApplyRecommendationsParams defines parameters for ApplyRecommendations.
type ApplyRecommendationsParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId string `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use GET method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope string `json:"Amazon-Advertising-API-Scope"`
}

// ListRecommendationsParams defines parameters for ListRecommendations.
type ListRecommendationsParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId string `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use GET method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header. account.
	AmazonAdvertisingAPIScope string `json:"Amazon-Advertising-API-Scope"`
}

// UpdateRecommendationParams defines parameters for UpdateRecommendation.
type UpdateRecommendationParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId string `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use GET method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header. account.
	AmazonAdvertisingAPIScope string `json:"Amazon-Advertising-API-Scope"`
}

// ApplyRecommendationsApplicationVndApplyRecommendationsRequestV1PlusJSONRequestBody defines body for ApplyRecommendations for application/vnd.applyRecommendationsRequest.v1+json ContentType.
type ApplyRecommendationsApplicationVndApplyRecommendationsRequestV1PlusJSONRequestBody = ApplyRecommendationsRequest

// ListRecommendationsApplicationVndListRecommendationsRequestV1PlusJSONRequestBody defines body for ListRecommendations for application/vnd.listRecommendationsRequest.v1+json ContentType.
type ListRecommendationsApplicationVndListRecommendationsRequestV1PlusJSONRequestBody = ListRecommendationsRequest

// UpdateRecommendationApplicationVndUpdateRecommendationRequestV1PlusJSONRequestBody defines body for UpdateRecommendation for application/vnd.updateRecommendationRequest.v1+json ContentType.
type UpdateRecommendationApplicationVndUpdateRecommendationRequestV1PlusJSONRequestBody = UpdateRecommendationRequest

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ApplyRecommendationsWithBody request with any body
	ApplyRecommendationsWithBody(ctx context.Context, params *ApplyRecommendationsParams, contentType string, body io.Reader) (*http.Response, error)

	ApplyRecommendationsWithApplicationVndApplyRecommendationsRequestV1PlusJSONBody(ctx context.Context, params *ApplyRecommendationsParams, body ApplyRecommendationsApplicationVndApplyRecommendationsRequestV1PlusJSONRequestBody) (*http.Response, error)

	// ListRecommendationsWithBody request with any body
	ListRecommendationsWithBody(ctx context.Context, params *ListRecommendationsParams, contentType string, body io.Reader) (*http.Response, error)

	ListRecommendationsWithApplicationVndListRecommendationsRequestV1PlusJSONBody(ctx context.Context, params *ListRecommendationsParams, body ListRecommendationsApplicationVndListRecommendationsRequestV1PlusJSONRequestBody) (*http.Response, error)

	// UpdateRecommendationWithBody request with any body
	UpdateRecommendationWithBody(ctx context.Context, recommendationId string, params *UpdateRecommendationParams, contentType string, body io.Reader) (*http.Response, error)

	UpdateRecommendationWithApplicationVndUpdateRecommendationRequestV1PlusJSONBody(ctx context.Context, recommendationId string, params *UpdateRecommendationParams, body UpdateRecommendationApplicationVndUpdateRecommendationRequestV1PlusJSONRequestBody) (*http.Response, error)
}

func (c *Client) ApplyRecommendationsWithBody(ctx context.Context, params *ApplyRecommendationsParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewApplyRecommendationsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ApplyRecommendationsWithApplicationVndApplyRecommendationsRequestV1PlusJSONBody(ctx context.Context, params *ApplyRecommendationsParams, body ApplyRecommendationsApplicationVndApplyRecommendationsRequestV1PlusJSONRequestBody) (*http.Response, error) {
	req, err := NewApplyRecommendationsRequestWithApplicationVndApplyRecommendationsRequestV1PlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListRecommendationsWithBody(ctx context.Context, params *ListRecommendationsParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewListRecommendationsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) ListRecommendationsWithApplicationVndListRecommendationsRequestV1PlusJSONBody(ctx context.Context, params *ListRecommendationsParams, body ListRecommendationsApplicationVndListRecommendationsRequestV1PlusJSONRequestBody) (*http.Response, error) {
	req, err := NewListRecommendationsRequestWithApplicationVndListRecommendationsRequestV1PlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateRecommendationWithBody(ctx context.Context, recommendationId string, params *UpdateRecommendationParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateRecommendationRequestWithBody(c.Server, recommendationId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) UpdateRecommendationWithApplicationVndUpdateRecommendationRequestV1PlusJSONBody(ctx context.Context, recommendationId string, params *UpdateRecommendationParams, body UpdateRecommendationApplicationVndUpdateRecommendationRequestV1PlusJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateRecommendationRequestWithApplicationVndUpdateRecommendationRequestV1PlusJSONBody(c.Server, recommendationId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewApplyRecommendationsRequestWithApplicationVndApplyRecommendationsRequestV1PlusJSONBody calls the generic ApplyRecommendations builder with application/vnd.applyRecommendationsRequest.v1+json body
func NewApplyRecommendationsRequestWithApplicationVndApplyRecommendationsRequestV1PlusJSONBody(server string, params *ApplyRecommendationsParams, body ApplyRecommendationsApplicationVndApplyRecommendationsRequestV1PlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewApplyRecommendationsRequestWithBody(server, params, "application/vnd.applyRecommendationsRequest.v1+json", bodyReader)
}

// NewApplyRecommendationsRequestWithBody generates requests for ApplyRecommendations with any type of body
func NewApplyRecommendationsRequestWithBody(server string, params *ApplyRecommendationsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recommendations/apply")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewListRecommendationsRequestWithApplicationVndListRecommendationsRequestV1PlusJSONBody calls the generic ListRecommendations builder with application/vnd.listRecommendationsRequest.v1+json body
func NewListRecommendationsRequestWithApplicationVndListRecommendationsRequestV1PlusJSONBody(server string, params *ListRecommendationsParams, body ListRecommendationsApplicationVndListRecommendationsRequestV1PlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListRecommendationsRequestWithBody(server, params, "application/vnd.listRecommendationsRequest.v1+json", bodyReader)
}

// NewListRecommendationsRequestWithBody generates requests for ListRecommendations with any type of body
func NewListRecommendationsRequestWithBody(server string, params *ListRecommendationsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recommendations/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewUpdateRecommendationRequestWithApplicationVndUpdateRecommendationRequestV1PlusJSONBody calls the generic UpdateRecommendation builder with application/vnd.updateRecommendationRequest.v1+json body
func NewUpdateRecommendationRequestWithApplicationVndUpdateRecommendationRequestV1PlusJSONBody(server string, recommendationId string, params *UpdateRecommendationParams, body UpdateRecommendationApplicationVndUpdateRecommendationRequestV1PlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRecommendationRequestWithBody(server, recommendationId, params, "application/vnd.updateRecommendationRequest.v1+json", bodyReader)
}

// NewUpdateRecommendationRequestWithBody generates requests for UpdateRecommendation with any type of body
func NewUpdateRecommendationRequestWithBody(server string, recommendationId string, params *UpdateRecommendationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recommendationId", runtime.ParamLocationPath, recommendationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recommendations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ApplyRecommendationsWithBodyWithResponse request with any body
	ApplyRecommendationsWithBodyWithResponse(ctx context.Context, params *ApplyRecommendationsParams, contentType string, body io.Reader) (*ApplyRecommendationsResp, error)

	ApplyRecommendationsWithApplicationVndApplyRecommendationsRequestV1PlusJSONBodyWithResponse(ctx context.Context, params *ApplyRecommendationsParams, body ApplyRecommendationsApplicationVndApplyRecommendationsRequestV1PlusJSONRequestBody) (*ApplyRecommendationsResp, error)

	// ListRecommendationsWithBodyWithResponse request with any body
	ListRecommendationsWithBodyWithResponse(ctx context.Context, params *ListRecommendationsParams, contentType string, body io.Reader) (*ListRecommendationsResp, error)

	ListRecommendationsWithApplicationVndListRecommendationsRequestV1PlusJSONBodyWithResponse(ctx context.Context, params *ListRecommendationsParams, body ListRecommendationsApplicationVndListRecommendationsRequestV1PlusJSONRequestBody) (*ListRecommendationsResp, error)

	// UpdateRecommendationWithBodyWithResponse request with any body
	UpdateRecommendationWithBodyWithResponse(ctx context.Context, recommendationId string, params *UpdateRecommendationParams, contentType string, body io.Reader) (*UpdateRecommendationResp, error)

	UpdateRecommendationWithApplicationVndUpdateRecommendationRequestV1PlusJSONBodyWithResponse(ctx context.Context, recommendationId string, params *UpdateRecommendationParams, body UpdateRecommendationApplicationVndUpdateRecommendationRequestV1PlusJSONRequestBody) (*UpdateRecommendationResp, error)
}

type ApplyRecommendationsResp struct {
	Body                                                []byte
	HTTPResponse                                        *http.Response
	ApplicationvndApplyRecommendationsResponseV1JSON207 *ApplyRecommendationsResponse
	ApplicationvndRecommendationApiErrorV1JSON400       *APIError
	ApplicationvndRecommendationApiErrorV1JSON429       *APIError
	ApplicationvndRecommendationApiErrorV1JSON500       *APIError
}

// Status returns HTTPResponse.Status
func (r ApplyRecommendationsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApplyRecommendationsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRecommendationsResp struct {
	Body                                               []byte
	HTTPResponse                                       *http.Response
	ApplicationvndListRecommendationsResponseV1JSON200 *ListRecommendationsResponse
	ApplicationvndRecommendationApiErrorV1JSON400      *APIError
	ApplicationvndRecommendationApiErrorV1JSON429      *APIError
	ApplicationvndRecommendationApiErrorV1JSON500      *APIError
}

// Status returns HTTPResponse.Status
func (r ListRecommendationsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRecommendationsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRecommendationResp struct {
	Body                                          []byte
	HTTPResponse                                  *http.Response
	ApplicationvndRecommendationV1JSON200         *Recommendation
	ApplicationvndRecommendationApiErrorV1JSON400 *APIError
	ApplicationvndRecommendationApiErrorV1JSON404 *APIError
	ApplicationvndRecommendationApiErrorV1JSON429 *APIError
	ApplicationvndRecommendationApiErrorV1JSON500 *APIError
}

// Status returns HTTPResponse.Status
func (r UpdateRecommendationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRecommendationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ApplyRecommendationsWithBodyWithResponse request with arbitrary body returning *ApplyRecommendationsResp
func (c *ClientWithResponses) ApplyRecommendationsWithBodyWithResponse(ctx context.Context, params *ApplyRecommendationsParams, contentType string, body io.Reader) (*ApplyRecommendationsResp, error) {
	rsp, err := c.ApplyRecommendationsWithBody(ctx, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseApplyRecommendationsResp(rsp)
}

func (c *ClientWithResponses) ApplyRecommendationsWithApplicationVndApplyRecommendationsRequestV1PlusJSONBodyWithResponse(ctx context.Context, params *ApplyRecommendationsParams, body ApplyRecommendationsApplicationVndApplyRecommendationsRequestV1PlusJSONRequestBody) (*ApplyRecommendationsResp, error) {
	rsp, err := c.ApplyRecommendationsWithApplicationVndApplyRecommendationsRequestV1PlusJSONBody(ctx, params, body)
	if err != nil {
		return nil, err
	}
	return ParseApplyRecommendationsResp(rsp)
}

// ListRecommendationsWithBodyWithResponse request with arbitrary body returning *ListRecommendationsResp
func (c *ClientWithResponses) ListRecommendationsWithBodyWithResponse(ctx context.Context, params *ListRecommendationsParams, contentType string, body io.Reader) (*ListRecommendationsResp, error) {
	rsp, err := c.ListRecommendationsWithBody(ctx, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseListRecommendationsResp(rsp)
}

func (c *ClientWithResponses) ListRecommendationsWithApplicationVndListRecommendationsRequestV1PlusJSONBodyWithResponse(ctx context.Context, params *ListRecommendationsParams, body ListRecommendationsApplicationVndListRecommendationsRequestV1PlusJSONRequestBody) (*ListRecommendationsResp, error) {
	rsp, err := c.ListRecommendationsWithApplicationVndListRecommendationsRequestV1PlusJSONBody(ctx, params, body)
	if err != nil {
		return nil, err
	}
	return ParseListRecommendationsResp(rsp)
}

// UpdateRecommendationWithBodyWithResponse request with arbitrary body returning *UpdateRecommendationResp
func (c *ClientWithResponses) UpdateRecommendationWithBodyWithResponse(ctx context.Context, recommendationId string, params *UpdateRecommendationParams, contentType string, body io.Reader) (*UpdateRecommendationResp, error) {
	rsp, err := c.UpdateRecommendationWithBody(ctx, recommendationId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRecommendationResp(rsp)
}

func (c *ClientWithResponses) UpdateRecommendationWithApplicationVndUpdateRecommendationRequestV1PlusJSONBodyWithResponse(ctx context.Context, recommendationId string, params *UpdateRecommendationParams, body UpdateRecommendationApplicationVndUpdateRecommendationRequestV1PlusJSONRequestBody) (*UpdateRecommendationResp, error) {
	rsp, err := c.UpdateRecommendationWithApplicationVndUpdateRecommendationRequestV1PlusJSONBody(ctx, recommendationId, params, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRecommendationResp(rsp)
}

// ParseApplyRecommendationsResp parses an HTTP response from a ApplyRecommendationsWithResponse call
func ParseApplyRecommendationsResp(rsp *http.Response) (*ApplyRecommendationsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApplyRecommendationsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest ApplyRecommendationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApplyRecommendationsResponseV1JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndRecommendationApiErrorV1JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndRecommendationApiErrorV1JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndRecommendationApiErrorV1JSON500 = &dest

	}

	return response, nil
}

// ParseListRecommendationsResp parses an HTTP response from a ListRecommendationsWithResponse call
func ParseListRecommendationsResp(rsp *http.Response) (*ListRecommendationsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRecommendationsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListRecommendationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndListRecommendationsResponseV1JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndRecommendationApiErrorV1JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndRecommendationApiErrorV1JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndRecommendationApiErrorV1JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRecommendationResp parses an HTTP response from a UpdateRecommendationWithResponse call
func ParseUpdateRecommendationResp(rsp *http.Response) (*UpdateRecommendationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRecommendationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Recommendation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndRecommendationV1JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndRecommendationApiErrorV1JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndRecommendationApiErrorV1JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndRecommendationApiErrorV1JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest APIError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndRecommendationApiErrorV1JSON500 = &dest

	}

	return response, nil
}
