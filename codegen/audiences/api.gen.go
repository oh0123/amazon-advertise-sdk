// Package audiences provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.15.0 DO NOT EDIT.
package audiences

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for AudienceCommonFieldsV1Status.
const (
	AudienceCommonFieldsV1StatusActive      AudienceCommonFieldsV1Status = "Active"
	AudienceCommonFieldsV1StatusDeactivated AudienceCommonFieldsV1Status = "Deactivated"
	AudienceCommonFieldsV1StatusDeprecated  AudienceCommonFieldsV1Status = "Deprecated"
	AudienceCommonFieldsV1StatusFailed      AudienceCommonFieldsV1Status = "Failed"
	AudienceCommonFieldsV1StatusProcessing  AudienceCommonFieldsV1Status = "Processing"
)

// Defines values for AudienceV1Status.
const (
	AudienceV1StatusActive      AudienceV1Status = "Active"
	AudienceV1StatusDeactivated AudienceV1Status = "Deactivated"
	AudienceV1StatusDeprecated  AudienceV1Status = "Deprecated"
	AudienceV1StatusFailed      AudienceV1Status = "Failed"
	AudienceV1StatusProcessing  AudienceV1Status = "Processing"
)

// Defines values for FetchTaxonomyRequestBodyV1AdType.
const (
	FetchTaxonomyRequestBodyV1AdTypeDSP FetchTaxonomyRequestBodyV1AdType = "DSP"
	FetchTaxonomyRequestBodyV1AdTypeSD  FetchTaxonomyRequestBodyV1AdType = "SD"
)

// Defines values for ListAudiencesRequestBodyV1AdType.
const (
	ListAudiencesRequestBodyV1AdTypeDSP ListAudiencesRequestBodyV1AdType = "DSP"
	ListAudiencesRequestBodyV1AdTypeSD  ListAudiencesRequestBodyV1AdType = "SD"
)

// AudienceCommonFieldsV1 defines model for AudienceCommonFieldsV1.
type AudienceCommonFieldsV1 struct {
	// AudienceId Audience segment identifier
	AudienceId string `json:"audienceId"`

	// AudienceName Audience name
	AudienceName string `json:"audienceName"`

	// Category Audience segment category
	Category   string     `json:"category"`
	CreateDate *time.Time `json:"createDate,omitempty"`

	// Description Audience description
	Description string `json:"description"`
	Forecasts   struct {
		InventoryForecasts struct {
			All *InventoryForecastV1 `json:"all,omitempty"`
		} `json:"inventoryForecasts"`
	} `json:"forecasts"`
	Status AudienceCommonFieldsV1Status `json:"status"`

	// SubCategory Audience segment sub-category
	SubCategory *string    `json:"subCategory,omitempty"`
	UpdateDate  *time.Time `json:"updateDate,omitempty"`
}

// AudienceCommonFieldsV1Status defines model for AudienceCommonFieldsV1.Status.
type AudienceCommonFieldsV1Status string

// AudienceErrorV1 The error response object.
type AudienceErrorV1 struct {
	Errors *[]AudienceSubErrorV1 `json:"errors,omitempty"`

	// Message A human-readable description of the response.
	Message *string `json:"message,omitempty"`

	// RequestId A value created by Amazon API Gateway that uniquely identifies your request.
	RequestId *string `json:"requestId,omitempty"`
}

// AudienceFilterV1 defines model for AudienceFilterV1.
type AudienceFilterV1 struct {
	// Field Field to filter by. Supported enums are 'audienceName', 'category', 'categoryPath', 'audienceId' and 'status'. The 'audienceName' is a broad match filter but not an exact match. The 'category' enum returns all audiences under a high-level category, whereas the 'categoryPath' enum expects a path of nodes in the taxonomy tree and returns audiences attached directly to the node at the specified path.
	Field  *string   `json:"field,omitempty"`
	Values *[]string `json:"values,omitempty"`
}

// AudienceSubErrorV1 The sub error object.
type AudienceSubErrorV1 struct {
	ErrorType string  `json:"errorType"`
	FieldName *string `json:"fieldName,omitempty"`
	Message   string  `json:"message"`
}

// AudienceV1 defines model for AudienceV1.
type AudienceV1 struct {
	// AudienceId Audience segment identifier
	AudienceId string `json:"audienceId"`

	// AudienceName Audience name
	AudienceName string `json:"audienceName"`

	// Category Audience segment category
	Category   string     `json:"category"`
	CreateDate *time.Time `json:"createDate,omitempty"`

	// Description Audience description
	Description string `json:"description"`
	Forecasts   struct {
		InventoryForecasts struct {
			All *InventoryForecastV1 `json:"all,omitempty"`
		} `json:"inventoryForecasts"`
	} `json:"forecasts"`
	Status AudienceV1Status `json:"status"`

	// SubCategory Audience segment sub-category
	SubCategory *string    `json:"subCategory,omitempty"`
	UpdateDate  *time.Time `json:"updateDate,omitempty"`
}

// AudienceV1Status defines model for AudienceV1.Status.
type AudienceV1Status string

// FetchTaxonomyNodeV1 defines model for FetchTaxonomyNodeV1.
type FetchTaxonomyNodeV1 struct {
	AudienceCount *int64  `json:"audienceCount,omitempty"`
	Category      *string `json:"category,omitempty"`
}

// FetchTaxonomyRequestBodyV1 The response data will have the categories that are under the given path, and main categories will be returned if no path is specified. The response data also depends on the adType specified here since ad programs may support targeting audiences in certain categories.
type FetchTaxonomyRequestBodyV1 struct {
	AdType       *FetchTaxonomyRequestBodyV1AdType `json:"adType,omitempty"`
	CategoryPath *[]string                         `json:"categoryPath,omitempty"`
}

// FetchTaxonomyRequestBodyV1AdType defines model for FetchTaxonomyRequestBodyV1.AdType.
type FetchTaxonomyRequestBodyV1AdType string

// FetchTaxonomyResponseV1 defines model for FetchTaxonomyResponseV1.
type FetchTaxonomyResponseV1 struct {
	Categories   *[]FetchTaxonomyNodeV1 `json:"categories,omitempty"`
	CategoryPath *[]string              `json:"categoryPath,omitempty"`
	NextToken    *string                `json:"nextToken,omitempty"`
}

// InventoryForecastV1 defines model for InventoryForecastV1.
type InventoryForecastV1 = map[string]interface{}

// ListAudiencesRequestBodyV1 Resulting segments will match all specified filters
type ListAudiencesRequestBodyV1 struct {
	AdType  *ListAudiencesRequestBodyV1AdType `json:"adType,omitempty"`
	Filters *[]AudienceFilterV1               `json:"filters,omitempty"`
}

// ListAudiencesRequestBodyV1AdType defines model for ListAudiencesRequestBodyV1.AdType.
type ListAudiencesRequestBodyV1AdType string

// ListAudiencesResponseV1 defines model for ListAudiencesResponseV1.
type ListAudiencesResponseV1 struct {
	// Audiences Array of segments matching given filters sorted by create time, earliest first.
	Audiences  *[]AudienceV1 `json:"audiences,omitempty"`
	MatchCount *int64        `json:"matchCount,omitempty"`
	NextToken  *string       `json:"nextToken,omitempty"`
}

// ListAudiencesParams defines parameters for ListAudiences.
type ListAudiencesParams struct {
	// AdvertiserId The advertiser to retrieve segments for. This parameter is required for the DSP adType, but optional for the SD adType.
	AdvertiserId *string `form:"advertiserId,omitempty" json:"advertiserId,omitempty"`

	// CanTarget When set to true, only targetable audience segments will be returned.
	CanTarget *bool `form:"canTarget,omitempty" json:"canTarget,omitempty"`

	// NextToken Token from a previous request. Use in conjunction with the `maxResults` parameter to control pagination of the returned array.
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// MaxResults Sets the maximum number of audiences in the returned array. Use in conjunction with the `nextToken` parameter to control pagination. For example, supplying maxResults=20 with a previously returned token will fetch up to the next 20 items. In some cases, fewer items may be returned.
	MaxResults *int `form:"maxResults,omitempty" json:"maxResults,omitempty"`

	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId string `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope string `json:"Amazon-Advertising-API-Scope"`
}

// FetchTaxonomyParams defines parameters for FetchTaxonomy.
type FetchTaxonomyParams struct {
	// AdvertiserId The advertiser associated with the advertising account. This parameter is required for the DSP adType, but optional for the SD adType.
	AdvertiserId *string `form:"advertiserId,omitempty" json:"advertiserId,omitempty"`

	// NextToken Token from a previous request. Use in conjunction with the `maxResults` parameter to control pagination of the returned array.
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// MaxResults Sets the maximum number of categories in the returned array. Use in conjunction with the `nextToken` parameter to control pagination. For example, supplying maxResults=20 with a previously returned token will fetch up to the next 20 items. In some cases, fewer items may be returned.
	MaxResults *int `form:"maxResults,omitempty" json:"maxResults,omitempty"`

	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId string `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope string `json:"Amazon-Advertising-API-Scope"`
}

// ListAudiencesJSONRequestBody defines body for ListAudiences for application/json ContentType.
type ListAudiencesJSONRequestBody = ListAudiencesRequestBodyV1

// FetchTaxonomyJSONRequestBody defines body for FetchTaxonomy for application/json ContentType.
type FetchTaxonomyJSONRequestBody = FetchTaxonomyRequestBodyV1

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListAudiencesWithBody request with any body
	ListAudiencesWithBody(ctx context.Context, params *ListAudiencesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListAudiences(ctx context.Context, params *ListAudiencesParams, body ListAudiencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchTaxonomyWithBody request with any body
	FetchTaxonomyWithBody(ctx context.Context, params *FetchTaxonomyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FetchTaxonomy(ctx context.Context, params *FetchTaxonomyParams, body FetchTaxonomyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListAudiencesWithBody(ctx context.Context, params *ListAudiencesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAudiencesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAudiences(ctx context.Context, params *ListAudiencesParams, body ListAudiencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAudiencesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchTaxonomyWithBody(ctx context.Context, params *FetchTaxonomyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchTaxonomyRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchTaxonomy(ctx context.Context, params *FetchTaxonomyParams, body FetchTaxonomyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchTaxonomyRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAudiencesRequest calls the generic ListAudiences builder with application/json body
func NewListAudiencesRequest(server string, params *ListAudiencesParams, body ListAudiencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListAudiencesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewListAudiencesRequestWithBody generates requests for ListAudiences with any type of body
func NewListAudiencesRequestWithBody(server string, params *ListAudiencesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audiences/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AdvertiserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "advertiserId", runtime.ParamLocationQuery, *params.AdvertiserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CanTarget != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "canTarget", runtime.ParamLocationQuery, *params.CanTarget); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxResults", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewFetchTaxonomyRequest calls the generic FetchTaxonomy builder with application/json body
func NewFetchTaxonomyRequest(server string, params *FetchTaxonomyParams, body FetchTaxonomyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFetchTaxonomyRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFetchTaxonomyRequestWithBody generates requests for FetchTaxonomy with any type of body
func NewFetchTaxonomyRequestWithBody(server string, params *FetchTaxonomyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audiences/taxonomy/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AdvertiserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "advertiserId", runtime.ParamLocationQuery, *params.AdvertiserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxResults", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAudiencesWithBodyWithResponse request with any body
	ListAudiencesWithBodyWithResponse(ctx context.Context, params *ListAudiencesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListAudiencesResp, error)

	ListAudiencesWithResponse(ctx context.Context, params *ListAudiencesParams, body ListAudiencesJSONRequestBody, reqEditors ...RequestEditorFn) (*ListAudiencesResp, error)

	// FetchTaxonomyWithBodyWithResponse request with any body
	FetchTaxonomyWithBodyWithResponse(ctx context.Context, params *FetchTaxonomyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FetchTaxonomyResp, error)

	FetchTaxonomyWithResponse(ctx context.Context, params *FetchTaxonomyParams, body FetchTaxonomyJSONRequestBody, reqEditors ...RequestEditorFn) (*FetchTaxonomyResp, error)
}

type ListAudiencesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAudiencesResponseV1
	JSON400      *AudienceErrorV1
	JSON403      *AudienceErrorV1
	JSON429      *AudienceErrorV1
	JSON500      *AudienceErrorV1
}

// Status returns HTTPResponse.Status
func (r ListAudiencesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAudiencesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchTaxonomyResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FetchTaxonomyResponseV1
	JSON400      *AudienceErrorV1
	JSON403      *AudienceErrorV1
	JSON429      *AudienceErrorV1
	JSON500      *AudienceErrorV1
}

// Status returns HTTPResponse.Status
func (r FetchTaxonomyResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchTaxonomyResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAudiencesWithBodyWithResponse request with arbitrary body returning *ListAudiencesResp
func (c *ClientWithResponses) ListAudiencesWithBodyWithResponse(ctx context.Context, params *ListAudiencesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListAudiencesResp, error) {
	rsp, err := c.ListAudiencesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAudiencesResp(rsp)
}

func (c *ClientWithResponses) ListAudiencesWithResponse(ctx context.Context, params *ListAudiencesParams, body ListAudiencesJSONRequestBody, reqEditors ...RequestEditorFn) (*ListAudiencesResp, error) {
	rsp, err := c.ListAudiences(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAudiencesResp(rsp)
}

// FetchTaxonomyWithBodyWithResponse request with arbitrary body returning *FetchTaxonomyResp
func (c *ClientWithResponses) FetchTaxonomyWithBodyWithResponse(ctx context.Context, params *FetchTaxonomyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FetchTaxonomyResp, error) {
	rsp, err := c.FetchTaxonomyWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchTaxonomyResp(rsp)
}

func (c *ClientWithResponses) FetchTaxonomyWithResponse(ctx context.Context, params *FetchTaxonomyParams, body FetchTaxonomyJSONRequestBody, reqEditors ...RequestEditorFn) (*FetchTaxonomyResp, error) {
	rsp, err := c.FetchTaxonomy(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchTaxonomyResp(rsp)
}

// ParseListAudiencesResp parses an HTTP response from a ListAudiencesWithResponse call
func ParseListAudiencesResp(rsp *http.Response) (*ListAudiencesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAudiencesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAudiencesResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest AudienceErrorV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AudienceErrorV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest AudienceErrorV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest AudienceErrorV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseFetchTaxonomyResp parses an HTTP response from a FetchTaxonomyWithResponse call
func ParseFetchTaxonomyResp(rsp *http.Response) (*FetchTaxonomyResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchTaxonomyResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FetchTaxonomyResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest AudienceErrorV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest AudienceErrorV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest AudienceErrorV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest AudienceErrorV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
