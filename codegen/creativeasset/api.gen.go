// Package creativeasset provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.15.0 DO NOT EDIT.
package creativeasset

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Defines values for CaAssetSortCriteriaField.
const (
	CaAssetSortCriteriaFieldCREATEDTIME CaAssetSortCriteriaField = "CREATED_TIME"
	CaAssetSortCriteriaFieldEXTENSION   CaAssetSortCriteriaField = "EXTENSION"
	CaAssetSortCriteriaFieldIMAGEHEIGHT CaAssetSortCriteriaField = "IMAGE_HEIGHT"
	CaAssetSortCriteriaFieldIMAGEWIDTH  CaAssetSortCriteriaField = "IMAGE_WIDTH"
	CaAssetSortCriteriaFieldNAME        CaAssetSortCriteriaField = "NAME"
	CaAssetSortCriteriaFieldSIZE        CaAssetSortCriteriaField = "SIZE"
)

// Defines values for CaAssetSortCriteriaOrder.
const (
	ASC  CaAssetSortCriteriaOrder = "ASC"
	DESC CaAssetSortCriteriaOrder = "DESC"
)

// Defines values for CaAssetStatus.
const (
	ACTIVE     CaAssetStatus = "ACTIVE"
	ARCHIVED   CaAssetStatus = "ARCHIVED"
	PROCESSING CaAssetStatus = "PROCESSING"
)

// Defines values for CaAssetSubType.
const (
	AUTHORIMAGE     CaAssetSubType = "AUTHOR_IMAGE"
	BACKGROUNDVIDEO CaAssetSubType = "BACKGROUND_VIDEO"
	LIFESTYLEIMAGE  CaAssetSubType = "LIFESTYLE_IMAGE"
	LOGO            CaAssetSubType = "LOGO"
	OTHERIMAGE      CaAssetSubType = "OTHER_IMAGE"
	PRODUCTIMAGE    CaAssetSubType = "PRODUCT_IMAGE"
)

// Defines values for CaAssetType.
const (
	IMAGE CaAssetType = "IMAGE"
	VIDEO CaAssetType = "VIDEO"
)

// Defines values for CaFileMetadataContentType.
const (
	Imagejpeg CaFileMetadataContentType = "image/jpeg"
	Imagejpg  CaFileMetadataContentType = "image/jpg"
	Imagepng  CaFileMetadataContentType = "image/png"
	Jpeg      CaFileMetadataContentType = "jpeg"
	Jpg       CaFileMetadataContentType = "jpg"
	Mp4       CaFileMetadataContentType = "mp4"
	Png       CaFileMetadataContentType = "png"
)

// Defines values for CaModerationContentStatus.
const (
	COMPLETED  CaModerationContentStatus = "COMPLETED"
	FAILED     CaModerationContentStatus = "FAILED"
	INPROGRESS CaModerationContentStatus = "IN_PROGRESS"
)

// Defines values for CaModerationStatus.
const (
	APPROVED CaModerationStatus = "APPROVED"
	PENDING  CaModerationStatus = "PENDING"
	REJECTED CaModerationStatus = "REJECTED"
)

// Defines values for CaProcessedUrlType.
const (
	BACKGROUNDVIDEOTILE                        CaProcessedUrlType = "BACKGROUND_VIDEO_TILE"
	IMAGETHUMBNAIL500                          CaProcessedUrlType = "IMAGE_THUMBNAIL_500"
	INTROSPLASH                                CaProcessedUrlType = "INTRO_SPLASH"
	MODERATION                                 CaProcessedUrlType = "MODERATION"
	MP410000KBS30FPS48KHZ320KBS1080P           CaProcessedUrlType = "MP4_10000KBS_30FPS_48KHZ_320KBS_1080P"
	MP410000KBS30FPS48KHZ320KBS1080PH264HIGH   CaProcessedUrlType = "MP4_10000KBS_30FPS_48KHZ_320KBS_1080P_H264_HIGH"
	MP41350KBS25FPS48KHZ128KBS540PH264MAIN     CaProcessedUrlType = "MP4_1350KBS_25FPS_48KHZ_128KBS_540P_H264_MAIN"
	MP41350KBS30FPS48KHZ96KBS720P              CaProcessedUrlType = "MP4_1350KBS_30FPS_48KHZ_96KBS_720P"
	MP41350KBS30FPS48KHZ96KBS720PH264HIGH      CaProcessedUrlType = "MP4_1350KBS_30FPS_48KHZ_96KBS_720P_H264_HIGH"
	MP41500KBS24FPS48KHZ96KBS576P              CaProcessedUrlType = "MP4_1500KBS_24FPS_48KHZ_96KBS_576P"
	MP41500KBS25FPS48KHZ128KBS576PH264HIGH     CaProcessedUrlType = "MP4_1500KBS_25FPS_48KHZ_128KBS_576P_H264_HIGH"
	MP41500KBS30FPS48KHZ192KBS540PH264HIGH     CaProcessedUrlType = "MP4_1500KBS_30FPS_48KHZ_192KBS_540P_H264_HIGH"
	MP420000KBSAUTOFPS48KHZ320KBS              CaProcessedUrlType = "MP4_20000KBS_AUTOFPS_48KHZ_320KBS"
	MP420000KBSAUTOFPS48KHZ320KBS1080PH264HIGH CaProcessedUrlType = "MP4_20000KBS_AUTOFPS_48KHZ_320KBS_1080P_H264_HIGH"
	MP42000KBS30FPS48KHZ192KBS720PH264HIGH     CaProcessedUrlType = "MP4_2000KBS_30FPS_48KHZ_192KBS_720P_H264_HIGH"
	MP42000KBS30FPS48KHZ96KBS720P              CaProcessedUrlType = "MP4_2000KBS_30FPS_48KHZ_96KBS_720P"
	MP42000KBS30FPS48KHZ96KBS720PH264HIGH      CaProcessedUrlType = "MP4_2000KBS_30FPS_48KHZ_96KBS_720P_H264_HIGH"
	MP42100KBS30FPS48KHZ192KBS480PH264MAIN     CaProcessedUrlType = "MP4_2100KBS_30FPS_48KHZ_192KBS_480P_H264_MAIN"
	MP42100KBS30FPS48KHZ192KBS576PH264HIGH     CaProcessedUrlType = "MP4_2100KBS_30FPS_48KHZ_192KBS_576P_H264_HIGH"
	MP425000KBS30FPS48KHZ192KBS1080PH264HIGH   CaProcessedUrlType = "MP4_25000KBS_30FPS_48KHZ_192KBS_1080P_H264_HIGH"
	MP425000KBS30FPS48KHZ192KBS1080PH264MAIN   CaProcessedUrlType = "MP4_25000KBS_30FPS_48KHZ_192KBS_1080P_H264_MAIN"
	MP4260KBS25FPS48KHZ64KBS180PH264BASELINE   CaProcessedUrlType = "MP4_260KBS_25FPS_48KHZ_64KBS_180P_H264_BASELINE"
	MP4300KBS15FPS48KHZ96KBS360P               CaProcessedUrlType = "MP4_300KBS_15FPS_48KHZ_96KBS_360P"
	MP4300KBS30FPS48KHZ96KBS360PH264BASELINE   CaProcessedUrlType = "MP4_300KBS_30FPS_48KHZ_96KBS_360P_H264_BASELINE"
	MP4320KBS25FPS48KHZ96KBS576PH264HIGH       CaProcessedUrlType = "MP4_320KBS_25FPS_48KHZ_96KBS_576P_H264_HIGH"
	MP43400KBS30FPS48KHZ192KBS1080PH264HIGH    CaProcessedUrlType = "MP4_3400KBS_30FPS_48KHZ_192KBS_1080P_H264_HIGH"
	MP43500KBS24FPS48KHZ96KBS1080P             CaProcessedUrlType = "MP4_3500KBS_24FPS_48KHZ_96KBS_1080P"
	MP43500KBS30FPS48KHZ128KBS720PH264HIGH     CaProcessedUrlType = "MP4_3500KBS_30FPS_48KHZ_128KBS_720P_H264_HIGH"
	MP4375KBS30FPS48KHZ192KBS360PH264HIGH      CaProcessedUrlType = "MP4_375KBS_30FPS_48KHZ_192KBS_360P_H264_HIGH"
	MP44000KBS30FPS48KHZ192KBS1080P            CaProcessedUrlType = "MP4_4000KBS_30FPS_48KHZ_192KBS_1080P"
	MP44000KBS30FPS48KHZ192KBS1080PH264HIGH    CaProcessedUrlType = "MP4_4000KBS_30FPS_48KHZ_192KBS_1080P_H264_HIGH"
	MP4450KBS15FPS48KHZ96KBS360P               CaProcessedUrlType = "MP4_450KBS_15FPS_48KHZ_96KBS_360P"
	MP4450KBS30FPS48KHZ96KBS360PH264BASELINE   CaProcessedUrlType = "MP4_450KBS_30FPS_48KHZ_96KBS_360P_H264_BASELINE"
	MP4600KBS15FPS48KHZ96KBS480P               CaProcessedUrlType = "MP4_600KBS_15FPS_48KHZ_96KBS_480P"
	MP4600KBS25FPS48KHZ128KBS360PH264BASELINE  CaProcessedUrlType = "MP4_600KBS_25FPS_48KHZ_128KBS_360P_H264_BASELINE"
	MP4600KBS30FPS48KHZ128KBS360PH264BASELINE  CaProcessedUrlType = "MP4_600KBS_30FPS_48KHZ_128KBS_360P_H264_BASELINE"
	MP4600KBS30FPS48KHZ96KBS480PH264BASELINE   CaProcessedUrlType = "MP4_600KBS_30FPS_48KHZ_96KBS_480P_H264_BASELINE"
	MP4700KBS24FPS48KHZ96KBS360P               CaProcessedUrlType = "MP4_700KBS_24FPS_48KHZ_96KBS_360P"
	MP4750KBS25FPS48KHZ96KBS576PH264HIGH       CaProcessedUrlType = "MP4_750KBS_25FPS_48KHZ_96KBS_576P_H264_HIGH"
	MP4750KBS30FPS48KHZ192KBS432PH264HIGH      CaProcessedUrlType = "MP4_750KBS_30FPS_48KHZ_192KBS_432P_H264_HIGH"
	MP4900KBS15FPS48KHZ96KBS480P               CaProcessedUrlType = "MP4_900KBS_15FPS_48KHZ_96KBS_480P"
	MP4900KBS30FPS48KHZ96KBS480PH264BASELINE   CaProcessedUrlType = "MP4_900KBS_30FPS_48KHZ_96KBS_480P_H264_BASELINE"
	PRODUCTVIDEOOPTIMIZED                      CaProcessedUrlType = "PRODUCT_VIDEO_OPTIMIZED"
	VIDEODEFAULTOPTIMIZED                      CaProcessedUrlType = "VIDEO_DEFAULT_OPTIMIZED"
	VIDEOTILE                                  CaProcessedUrlType = "VIDEO_TILE"
)

// Defines values for CaProgram.
const (
	AMAZONDSP CaProgram = "AMAZON_DSP"
)

// Defines values for CaSpecificationProgram.
const (
	DEMANDSIDEPLATFORMOLV     CaSpecificationProgram = "DEMAND_SIDE_PLATFORM_OLV"
	DEMANDSIDEPLATFORMOTT     CaSpecificationProgram = "DEMAND_SIDE_PLATFORM_OTT"
	SPONSOREDBRANDSVIDEO      CaSpecificationProgram = "SPONSORED_BRANDS_VIDEO"
	SPONSOREDDISPLAYVIDEO     CaSpecificationProgram = "SPONSORED_DISPLAY_VIDEO"
	STORESBACKGROUNDVIDEOTILE CaSpecificationProgram = "STORES_BACKGROUND_VIDEO_TILE"
	STORESINTROSPLASH         CaSpecificationProgram = "STORES_INTRO_SPLASH"
	STORESVIDEOTILE           CaSpecificationProgram = "STORES_VIDEO_TILE"
)

// Defines values for CaValueFilterValueField.
const (
	APPROVEDADPOLICY CaValueFilterValueField = "APPROVED_AD_POLICY"
	ASIN             CaValueFilterValueField = "ASIN"
	ASSETEXTENSION   CaValueFilterValueField = "ASSET_EXTENSION"
	ASSETSUBTYPE     CaValueFilterValueField = "ASSET_SUB_TYPE"
	ASSETTYPE        CaValueFilterValueField = "ASSET_TYPE"
	CAMPAIGNID       CaValueFilterValueField = "CAMPAIGN_ID"
	CAMPAIGNNAME     CaValueFilterValueField = "CAMPAIGN_NAME"
	PROGRAM          CaValueFilterValueField = "PROGRAM"
	TAG              CaValueFilterValueField = "TAG"
)

// DATEUPLOADED The value for this should be timestamp in milliseconds. It is the same as creation date.
type DATEUPLOADED = string

// SIZE File size in bytes.
type SIZE = string

// CaAccounts The list of advertiser accounts the asset can be shared with. All the accounts within this list will be able to search this asset. Additional validation of checking that the accounts are associated will be done as part of this call.
type CaAccounts = []string

// CaAdPolicyModerationResult defines model for caAdPolicyModerationResult.
type CaAdPolicyModerationResult struct {
	Locale           *string             `json:"locale,omitempty"`
	MarketplaceId    *string             `json:"marketplaceId,omitempty"`
	ModerationStatus *CaModerationStatus `json:"moderationStatus,omitempty"`
	PolicyName       *string             `json:"policyName,omitempty"`
}

// CaArgumentList List of arguments for translation string
type CaArgumentList = []string

// CaAsins Tagging assets with ASIN, promotes asset discoverability downstream. If ASIN is provided at the time of upload/during asset registration, it is applied as a tag on that asset. This allows for that asset to be searchable using that ASIN#. For e.g., An advertiser may want to search for assets tagged with ASIN BC10001, so they can create a store spotlight ad with product images for that ASIN.
type CaAsins = []string

// CaAsset defines model for caAsset.
type CaAsset struct {
	AssetId       *string           `json:"assetId,omitempty"`
	AssetSubTypes *[]CaAssetSubType `json:"assetSubTypes,omitempty"`

	// AssetType The asset type you are registering [`IMAGE`, `VIDEO`]
	AssetType            *CaAssetType `json:"assetType,omitempty"`
	AssociatedAccountIds *[]string    `json:"associatedAccountIds,omitempty"`

	// AssociatedContexts A hashmap of key-value pairs, this is the most accurate way of defining a map in swagger 2.0
	AssociatedContexts *CaAssociatedContextTypeMapping `json:"associatedContexts,omitempty"`
	Collections        *[]string                       `json:"collections,omitempty"`
	CreatedBy          *string                         `json:"createdBy,omitempty"`
	CreationTime       *int64                          `json:"creationTime,omitempty"`
	FileMetadata       *CaFileMetadata                 `json:"fileMetadata,omitempty"`
	LastUpdatedBy      *string                         `json:"lastUpdatedBy,omitempty"`
	LastUpdatedTime    *int64                          `json:"lastUpdatedTime,omitempty"`
	Marketplaces       *[]string                       `json:"marketplaces,omitempty"`

	// ModerationPolicyMap A hashmap of key-value pairs, this is the most accurate way of defining a map in swagger 2.0
	ModerationPolicyMap *CaModerationPolicyMap `json:"moderationPolicyMap,omitempty"`
	Name                *string                `json:"name,omitempty"`

	// SpecCheckApprovedPrograms List of spec programs for which asset spec check is approved
	SpecCheckApprovedPrograms *CaSpecCheckApprovedPrograms `json:"specCheckApprovedPrograms,omitempty"`
	Status                    *CaAssetStatus               `json:"status,omitempty"`
	StorageLocationUrls       *CaStorageLocationUrls       `json:"storageLocationUrls,omitempty"`
	Tags                      *[]string                    `json:"tags,omitempty"`
	Version                   *string                      `json:"version,omitempty"`
}

// CaAssetFiles Structure containing processed transcode files for an asset
//
//	defaultUrl: This is the location of the original source.
//	processedFiles: List of processed files with metadata.
type CaAssetFiles struct {
	DefaultUrl     *string            `json:"defaultUrl,omitempty"`
	ProcessedFiles *[]CaProcessedFile `json:"processedFiles,omitempty"`
}

// CaAssetGlobal defines model for caAssetGlobal.
type CaAssetGlobal struct {
	// AccountIds The list of advertiser accounts the asset can be shared with. All the accounts within this list will be able to search this asset. Additional validation of checking that the accounts are associated will be done as part of this call.
	AccountIds *CaAccounts `json:"accountIds,omitempty"`

	// AssetId The asset identifier.
	AssetId *CaAssetId `json:"assetId,omitempty"`

	// AssetType The asset type you are registering [`IMAGE`, `VIDEO`]
	AssetType *CaAssetType `json:"assetType,omitempty"`

	// MarketplaceId The list of marketplace Ids.
	MarketplaceId *CaMarketplaceIds `json:"marketplaceId,omitempty"`
}

// CaAssetId The asset identifier.
type CaAssetId = string

// CaAssetIdentifier defines model for caAssetIdentifier.
type CaAssetIdentifier struct {
	// AssetId The asset identifier.
	AssetId *CaAssetId `json:"assetId,omitempty"`

	// Version The version of the asset.
	Version *CaVersion `json:"version,omitempty"`
}

// CaAssetName The name to be given to the asset being registered.
type CaAssetName = string

// CaAssetSortCriteria defines model for caAssetSortCriteria.
type CaAssetSortCriteria struct {
	Field *CaAssetSortCriteriaField `json:"field,omitempty"`
	Order *CaAssetSortCriteriaOrder `json:"order,omitempty"`
}

// CaAssetSortCriteriaField defines model for CaAssetSortCriteria.Field.
type CaAssetSortCriteriaField string

// CaAssetSortCriteriaOrder defines model for CaAssetSortCriteria.Order.
type CaAssetSortCriteriaOrder string

// CaAssetStatus defines model for caAssetStatus.
type CaAssetStatus string

// CaAssetSubType 1. For assetType `IMAGE` acceptable assetSubTypes are `LOGO`, `PRODUCT_IMAGE`, `AUTHOR_IMAGE`, `LIFESTYLE_IMAGE`, `OTHER_IMAGE`
// 2. For assetType `VIDEO` acceptable assetSubtype is `BACKGROUND_VIDEO`.
type CaAssetSubType string

// CaAssetType The asset type you are registering [`IMAGE`, `VIDEO`]
type CaAssetType string

// CaAssetUploadLocation The url to upload the asset. The url expires in 15 minutes.
type CaAssetUploadLocation = string

// CaAssetVersion defines model for caAssetVersion.
type CaAssetVersion struct {
	// AssetFiles Structure containing processed transcode files for an asset
	//  defaultUrl: This is the location of the original source.
	//  processedFiles: List of processed files with metadata.
	AssetFiles      *CaAssetFiles      `json:"assetFiles,omitempty"`
	AssetIdentifier *CaAssetIdentifier `json:"assetIdentifier,omitempty"`
	AssetStatus     *CaAssetStatus     `json:"assetStatus,omitempty"`
	AssetSubTypes   *CaassetSubTypes   `json:"assetSubTypes,omitempty"`
	CreatedBy       *string            `json:"createdBy,omitempty"`
	CreationTime    *int64             `json:"creationTime,omitempty"`

	// FailedSpecChecks Specification Checks for all programs
	FailedSpecChecks      *CaProgramSpecificationsList `json:"failedSpecChecks,omitempty"`
	FileMetadata          *CaFileMetadata              `json:"fileMetadata,omitempty"`
	LastUpdatedBy         *string                      `json:"lastUpdatedBy,omitempty"`
	LastUpdatedTime       *int64                       `json:"lastUpdatedTime,omitempty"`
	ModerationContentList *[]CaModerationContent       `json:"moderationContentList,omitempty"`

	// Name The fileName of the asset.
	Name *CaFileName `json:"name,omitempty"`

	// OtherMetadata Include key-value pairs related to the asset. For DSP use "dspAdvertiserId" = "ID". Include program as AMAZON_DSP.
	OtherMetadata *CaMetadataMap `json:"otherMetadata,omitempty"`

	// SpecCheckApprovedPrograms List of spec programs for which asset spec check is approved
	SpecCheckApprovedPrograms *CaSpecCheckApprovedPrograms `json:"specCheckApprovedPrograms,omitempty"`
	StorageLocationUrls       *CaStorageLocationUrls       `json:"storageLocationUrls,omitempty"`

	// Url The URL of the asset.
	Url *CaURL `json:"url,omitempty"`

	// VersionNotes The URL of the asset
	VersionNotes *string `json:"versionNotes,omitempty"`
}

// CaAssetVersionList The asset version list.
type CaAssetVersionList = []CaAssetVersion

// CaAssociatedContextTypeMapping A hashmap of key-value pairs, this is the most accurate way of defining a map in swagger 2.0
type CaAssociatedContextTypeMapping = map[string]interface{}

// CaAssociatedProgram defines model for caAssociatedProgram.
type CaAssociatedProgram struct {
	// Metadata Include key-value pairs related to the asset. For DSP use "dspAdvertiserId" = "ID". Include program as AMAZON_DSP.
	Metadata *CaMetadataMap `json:"metadata,omitempty"`

	// ProgramName Use this field to specify which program you are uploading an asset for. Currently, the accepted value here on registration is to associate an asset with a DSP advertiser.
	ProgramName *CaProgram `json:"programName,omitempty"`
}

// CaAssociatedSubEntity defines model for caAssociatedSubEntity.
type CaAssociatedSubEntity struct {
	// BrandEntityId The entity id of brand, which can be retrieved using GET /brands.
	BrandEntityId *string `json:"brandEntityId,omitempty"`
}

// CaAssociatedSubEntityList This field is required for sellers, but not required for vendors. The brandEntityId is required for sellers uploading assets for use in Sponsored Brands. As a best practice, ensure to include brandEntityId when uploading assets for sellers.
type CaAssociatedSubEntityList = []CaAssociatedSubEntity

// CaAudioStreamMetadata Structure containing metadata of Video Stream.
//
//	profile: This is the profile of the stream.
//	duration: This is the duration of the stream in secs.
//	codecName: This tells the codec of the media stream.
//	codecType: This is the codec type of stream.
//	bitRate: This tells the bit rate of the stream.
//	channelLayout: This tells the channel of the stream
//	sampleRate: This is the sample rate of the stream
type CaAudioStreamMetadata struct {
	BitRate       *int64   `json:"bitRate,omitempty"`
	ChannelLayout *string  `json:"channelLayout,omitempty"`
	CodecName     *string  `json:"codecName,omitempty"`
	CodecType     *string  `json:"codecType,omitempty"`
	Duration      *float64 `json:"duration,omitempty"`
	Profile       *string  `json:"profile,omitempty"`
	SampleRate    *int64   `json:"sampleRate,omitempty"`
}

// CaBadRequest 400 bad request
type CaBadRequest struct {
	Message *string `json:"message,omitempty"`
}

// CaFileMetadata defines model for caFileMetadata.
type CaFileMetadata struct {
	// AspectRatio The aspect ration of the asset.
	AspectRatio     *string  `json:"aspectRatio,omitempty"`
	AudioSampleRate *float64 `json:"audioSampleRate,omitempty"`

	// ContentType The content type of the asset.
	ContentType *CaFileMetadataContentType `json:"contentType,omitempty"`
	Duration    *float64                   `json:"duration,omitempty"`

	// Extension The extension of the file name.
	Extension *string `json:"extension,omitempty"`

	// FileSize The asset size in bytes.
	FileSize *float32 `json:"fileSize,omitempty"`

	// Height The height of the asset in pixels.
	Height           *float32 `json:"height,omitempty"`
	ResolutionHeight *int     `json:"resolutionHeight,omitempty"`
	ResolutionWidth  *int     `json:"resolutionWidth,omitempty"`

	// Width The width of the asset in pixels.
	Width *float32 `json:"width,omitempty"`
}

// CaFileMetadataContentType The content type of the asset.
type CaFileMetadataContentType string

// CaFileName The fileName of the asset.
type CaFileName = string

// CaFilterCriteria **Optional** this is used to filter results, we support two types of filters, valueFilter and rangeFilter
type CaFilterCriteria struct {
	RangeFilters *[]CaRangeFilter `json:"rangeFilters,omitempty"`
	ValueFilters *[]CaValueFilter `json:"valueFilters,omitempty"`
}

// CaForbiddenRequest 403 forbidden request
type CaForbiddenRequest struct {
	Message *string `json:"message,omitempty"`
}

// CaInternalError 500 internal server error
type CaInternalError struct {
	Message *string `json:"message,omitempty"`
}

// CaMarketplaceIds The list of marketplace Ids.
type CaMarketplaceIds = []string

// CaMetadataMap Include key-value pairs related to the asset. For DSP use "dspAdvertiserId" = "ID". Include program as AMAZON_DSP.
type CaMetadataMap map[string]string

// CaModerationContent defines model for caModerationContent.
type CaModerationContent struct {
	AdPolicyModerationResultList *[]CaAdPolicyModerationResult `json:"adPolicyModerationResultList,omitempty"`

	// AssetSubType 1. For assetType `IMAGE` acceptable assetSubTypes are `LOGO`, `PRODUCT_IMAGE`, `AUTHOR_IMAGE`, `LIFESTYLE_IMAGE`, `OTHER_IMAGE`
	// 2. For assetType `VIDEO` acceptable assetSubtype is `BACKGROUND_VIDEO`.
	AssetSubType            *CaAssetSubType            `json:"assetSubType,omitempty"`
	ModerationContentStatus *CaModerationContentStatus `json:"moderationContentStatus,omitempty"`
}

// CaModerationContentStatus defines model for caModerationContentStatus.
type CaModerationContentStatus string

// CaModerationPolicyMap A hashmap of key-value pairs, this is the most accurate way of defining a map in swagger 2.0
type CaModerationPolicyMap = map[string]interface{}

// CaModerationStatus defines model for caModerationStatus.
type CaModerationStatus string

// CaPageCriteria used for pagination
//
// when searching for the first page, no need to put anything, otherwise, use the token returned from previous search call
type CaPageCriteria struct {
	Identifier *CaPageIdentifier `json:"identifier,omitempty"`
	Size       *CaPageSize       `json:"size,omitempty"`
}

// CaPageIdentifier defines model for caPageIdentifier.
type CaPageIdentifier struct {
	PageNumber *int    `json:"pageNumber,omitempty"`
	Token      *string `json:"token,omitempty"`
}

// CaPageSize defines model for caPageSize.
type CaPageSize = int

// CaProcessedFile Structure containing url, program, profile and metadata of processed output
//
//	program: This is the program for which this transcoding is done.
//	profile: This is the profile/outformat of the processed file.
//	url: This is the location of the processed file.
//	fileMetadata: This contains the metadata of file.
type CaProcessedFile struct {
	// FileMetadata Structure containing metadata of processed file.
	//  contentHash: This is the location of the original source.
	//  contentType: This is the location of the original source.
	//  videoStreams: This contains the metadata of Video streams.
	//  audioStreams: This contains the metadata of Audio streams.
	FileMetadata *CaProcessedFileMetadata `json:"fileMetadata,omitempty"`

	// Profile Enum containing different type of processed urls
	// 1. `MODERATION`: This is an internal url that will be used to moderate the asset.
	// 2. `IMAGE_THUMBNAIL_500`: This is the url for image asset type to support thumbnail rendering of max side 500px.
	// 3. `VIDEO_DEFAULT_OPTIMIZED`: This is the default processed url for video asset type for optimized rendering.
	// 4. `PRODUCT_VIDEO_OPTIMIZED`: This is the processed url for video that can be used for product.
	// 5. `BACKGROUND_VIDEO_TILE`: This is the processed url for video that can be used for background video tile.
	// 6. `VIDEO_TILE`: This is the processed url for video that can be used for video tile.
	// 7. `INTRO_SPLASH`: This is the processed url for video that can be used for intro splash.
	// 8. `MP4_260KBS_25FPS_48KHZ_64KBS_180P_H264_BASELINE`: This is the processed url for video that can be used with mp4 container, 260KBS bitrate, 25fps(frame per sec), 48KHZ sampleRate, 64KBS audio bit rate, 180p height and generated with codec profile H.264/ Baseline.
	// 9. `MP4_300KBS_15FPS_48KHZ_96KBS_360P`: This is the processed url for video that can be used with mp4 container, 300KBS bitrate, 15fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate and 360p height.
	// 10. `MP4_300KBS_30FPS_48KHZ_96KBS_360P_H264_BASELINE`: This is the processed url for video that can be used with mp4 container, 300KBS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate, 360p height and generated with codec profile H.264/ Baseline.
	// 11. `MP4_320KBS_25FPS_48KHZ_96KBS_576P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 320KBS bitrate, 25fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate, 576p height and generated with codec profile H.264/ High.
	// 12. `MP4_375KBS_30FPS_48KHZ_192KBS_360P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 375KBS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 192KBS audio bit rate, 360p height and generated with codec profile H.264/ High.
	// 13. `MP4_450KBS_15FPS_48KHZ_96KBS_360P`: This is the processed url for video that can be used with mp4 container, 450KBS bitrate, 15fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate and 360p height.
	// 14. `MP4_450KBS_30FPS_48KHZ_96KBS_360P_H264_BASELINE`: This is the processed url for video that can be used with mp4 container, 450KBS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate, 360p height and generated with codec profile H.264/ Baseline.
	// 15. `MP4_600KBS_15FPS_48KHZ_96KBS_480P`: This is the processed url for video that can be used with mp4 container, 600KBS bitrate, 15fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate and 480p height.
	// 16. `MP4_600KBS_30FPS_48KHZ_96KBS_480P_H264_BASELINE`: This is the processed url for video that can be used with mp4 container, 600KBS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate, 480p height and generated with codec profile H.264/ Baseline.
	// 17. `MP4_600KBS_25FPS_48KHZ_128KBS_360P_H264_BASELINE`: This is the processed url for video that can be used with mp4 container, 600KBS bitrate, 25fps(frame per sec), 48KHZ sampleRate, 128KBS audio bit rate, 360p height and generated with codec profile H.264/ Baseline.
	// 18. `MP4_600KBS_30FPS_48KHZ_128KBS_360P_H264_BASELINE`: This is the processed url for video that can be used with mp4 container, 600KBS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 128KBS audio bit rate, 360p height and generated with codec profile H.264/ Baseline.
	// 19. `MP4_700KBS_24FPS_48KHZ_96KBS_360P`: This is the processed url for video that can be used with mp4 container, 700KBS bitrate, 24fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate and 360p height.
	// 20. `MP4_750KBS_30FPS_48KHZ_192KBS_432P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 750KBS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 192KBS audio bit rate, 432p height and generated with codec profile H.264/ High.
	// 21. `MP4_750KBS_25FPS_48KHZ_96KBS_576P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 750KBS bitrate, 25fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate, 576p height and generated with codec profile H.264/ High.
	// 22. `MP4_900KBS_15FPS_48KHZ_96KBS_480P`: This is the processed url for video that can be used with mp4 container, 900KBS bitrate, 15fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate and 480p height.
	// 23. `MP4_900KBS_30FPS_48KHZ_96KBS_480P_H264_BASELINE`: This is the processed url for video that can be used with mp4 container, 900KBS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate, 480p height and generated with codec profile H.264/ Baseline.
	// 24. `MP4_1350KBS_30FPS_48KHZ_96KBS_720P`: This is the processed url for video that can be used with mp4 container, 1350KBS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate and 720p height.
	// 25. `MP4_1350KBS_30FPS_48KHZ_96KBS_720P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 1.35MBPS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate, 720p height and generated with codec profile H.264/ High.
	// 26. `MP4_1350KBS_25FPS_48KHZ_128KBS_540P_H264_MAIN`: This is the processed url for video that can be used with mp4 container, 1.35MBPS bitrate, 25fps(frame per sec), 48KHZ sampleRate, 128KBS audio bit rate, 540p height and generated with codec profile H.264/ Main.
	// 27. `MP4_1500KBS_24FPS_48KHZ_96KBS_576P`: This is the processed url for video that can be used with mp4 container, 1500KBS bitrate, 24fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate and 576p height.
	// 28. `MP4_1500KBS_30FPS_48KHZ_192KBS_540P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 1.5MBPS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 192KBS audio bit rate, 540p height and generated with codec profile H.264/ High.
	// 29. `MP4_1500KBS_25FPS_48KHZ_128KBS_576P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 1.5MBPS bitrate, 25fps(frame per sec), 48KHZ sampleRate, 128KBS audio bit rate, 576p height and generated with codec profile H.264/ High.
	// 30. `MP4_2000KBS_30FPS_48KHZ_96KBS_720P`: This is the processed url for video that can be used with mp4 container, 2000KBS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate and 720p height.
	// 31. `MP4_2000KBS_30FPS_48KHZ_96KBS_720P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 2MBPS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate, 720p height and generated with codec profile H.264/ High.
	// 32. `MP4_2000KBS_30FPS_48KHZ_192KBS_720P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 2MBPS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 192KBS audio bit rate, 720p height and generated with codec profile H.264/ High.
	// 33. `MP4_2100KBS_30FPS_48KHZ_192KBS_576P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 2.1MBPS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 192KBS audio bit rate, 576p height and generated with codec profile H.264/ High.
	// 34. `MP4_2100KBS_30FPS_48KHZ_192KBS_480P_H264_MAIN`: This is the processed url for video that can be used with mp4 container, 2.1MBPS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 192KBS audio bit rate, 480p height and generated with codec profile H.264/ Main.
	// 35. `MP4_3400KBS_30FPS_48KHZ_192KBS_1080P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 3.4MBPS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 192KBS audio bit rate, 1080p height and generated with codec profile H.264/ High.
	// 36. `MP4_3500KBS_24FPS_48KHZ_96KBS_1080P`: This is the processed url for video that can be used with mp4 container, 3500KBS bitrate, 24fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate and 1080p height.
	// 37. `MP4_3500KBS_30FPS_48KHZ_128KBS_720P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 3.5MBPS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 128KBS audio bit rate, 720p height and generated with codec profile H.264/ High.
	// 38. `MP4_4000KBS_30FPS_48KHZ_192KBS_1080P`: This is the processed url for video that can be used with mp4 container, 4000KBS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 192KBS audio bit rate and 1080p height.
	// 39. `MP4_4000KBS_30FPS_48KHZ_192KBS_1080P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 4MBPS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 192KBS audio bit rate, 1080p height and generated with codec profile H.264/ High.
	// 40. `MP4_10000KBS_30FPS_48KHZ_320KBS_1080P`: This is the processed url for video that can be used with mp4 container, 10000KBS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 320KBS audio bit rate and 1080p height.
	// 41. `MP4_10000KBS_30FPS_48KHZ_320KBS_1080P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 10MBPS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 320KBS audio bit rate, 1080p height and generated with codec profile H.264/ High.
	// 42. `MP4_20000KBS_AUTOFPS_48KHZ_320KBS`: This is the processed url for video that can be used with mp4 container, 20000KBS bitrate, auto fps, 48KHZ sampleRate, 320KBS audio bit rate.
	// 43. `MP4_20000KBS_AUTOFPS_48KHZ_320KBS_1080P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 20MBPS bitrate, auto fps, 48KHZ sampleRate, 320KBS audio bit rate, 1080p height and generated with codec profile H.264/ High.
	// 44. `MP4_25000KBS_30FPS_48KHZ_192KBS_1080P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 25MBPS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 192KBS audio bit rate, 1080p height and generated with codec profile H.264/ High.
	// 45. `MP4_25000KBS_30FPS_48KHZ_192KBS_1080P_H264_MAIN`: This is the processed url for video that can be used with mp4 container, 25MBPS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 192KBS audio bit rate, 1080p height and generated with codec profile H.264/ Main.
	Profile  *CaProcessedUrlType `json:"profile,omitempty"`
	Programs *[]CaProgram        `json:"programs,omitempty"`
	Url      *string             `json:"url,omitempty"`
}

// CaProcessedFileMetadata Structure containing metadata of processed file.
//
//	contentHash: This is the location of the original source.
//	contentType: This is the location of the original source.
//	videoStreams: This contains the metadata of Video streams.
//	audioStreams: This contains the metadata of Audio streams.
type CaProcessedFileMetadata struct {
	AudioStreams *[]CaAudioStreamMetadata `json:"audioStreams,omitempty"`
	ContentHash  *string                  `json:"contentHash,omitempty"`
	ContentType  *string                  `json:"contentType,omitempty"`
	VideoStreams *[]CaVideoStreamMetadata `json:"videoStreams,omitempty"`
}

// CaProcessedUrlType Enum containing different type of processed urls
// 1. `MODERATION`: This is an internal url that will be used to moderate the asset.
// 2. `IMAGE_THUMBNAIL_500`: This is the url for image asset type to support thumbnail rendering of max side 500px.
// 3. `VIDEO_DEFAULT_OPTIMIZED`: This is the default processed url for video asset type for optimized rendering.
// 4. `PRODUCT_VIDEO_OPTIMIZED`: This is the processed url for video that can be used for product.
// 5. `BACKGROUND_VIDEO_TILE`: This is the processed url for video that can be used for background video tile.
// 6. `VIDEO_TILE`: This is the processed url for video that can be used for video tile.
// 7. `INTRO_SPLASH`: This is the processed url for video that can be used for intro splash.
// 8. `MP4_260KBS_25FPS_48KHZ_64KBS_180P_H264_BASELINE`: This is the processed url for video that can be used with mp4 container, 260KBS bitrate, 25fps(frame per sec), 48KHZ sampleRate, 64KBS audio bit rate, 180p height and generated with codec profile H.264/ Baseline.
// 9. `MP4_300KBS_15FPS_48KHZ_96KBS_360P`: This is the processed url for video that can be used with mp4 container, 300KBS bitrate, 15fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate and 360p height.
// 10. `MP4_300KBS_30FPS_48KHZ_96KBS_360P_H264_BASELINE`: This is the processed url for video that can be used with mp4 container, 300KBS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate, 360p height and generated with codec profile H.264/ Baseline.
// 11. `MP4_320KBS_25FPS_48KHZ_96KBS_576P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 320KBS bitrate, 25fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate, 576p height and generated with codec profile H.264/ High.
// 12. `MP4_375KBS_30FPS_48KHZ_192KBS_360P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 375KBS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 192KBS audio bit rate, 360p height and generated with codec profile H.264/ High.
// 13. `MP4_450KBS_15FPS_48KHZ_96KBS_360P`: This is the processed url for video that can be used with mp4 container, 450KBS bitrate, 15fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate and 360p height.
// 14. `MP4_450KBS_30FPS_48KHZ_96KBS_360P_H264_BASELINE`: This is the processed url for video that can be used with mp4 container, 450KBS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate, 360p height and generated with codec profile H.264/ Baseline.
// 15. `MP4_600KBS_15FPS_48KHZ_96KBS_480P`: This is the processed url for video that can be used with mp4 container, 600KBS bitrate, 15fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate and 480p height.
// 16. `MP4_600KBS_30FPS_48KHZ_96KBS_480P_H264_BASELINE`: This is the processed url for video that can be used with mp4 container, 600KBS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate, 480p height and generated with codec profile H.264/ Baseline.
// 17. `MP4_600KBS_25FPS_48KHZ_128KBS_360P_H264_BASELINE`: This is the processed url for video that can be used with mp4 container, 600KBS bitrate, 25fps(frame per sec), 48KHZ sampleRate, 128KBS audio bit rate, 360p height and generated with codec profile H.264/ Baseline.
// 18. `MP4_600KBS_30FPS_48KHZ_128KBS_360P_H264_BASELINE`: This is the processed url for video that can be used with mp4 container, 600KBS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 128KBS audio bit rate, 360p height and generated with codec profile H.264/ Baseline.
// 19. `MP4_700KBS_24FPS_48KHZ_96KBS_360P`: This is the processed url for video that can be used with mp4 container, 700KBS bitrate, 24fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate and 360p height.
// 20. `MP4_750KBS_30FPS_48KHZ_192KBS_432P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 750KBS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 192KBS audio bit rate, 432p height and generated with codec profile H.264/ High.
// 21. `MP4_750KBS_25FPS_48KHZ_96KBS_576P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 750KBS bitrate, 25fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate, 576p height and generated with codec profile H.264/ High.
// 22. `MP4_900KBS_15FPS_48KHZ_96KBS_480P`: This is the processed url for video that can be used with mp4 container, 900KBS bitrate, 15fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate and 480p height.
// 23. `MP4_900KBS_30FPS_48KHZ_96KBS_480P_H264_BASELINE`: This is the processed url for video that can be used with mp4 container, 900KBS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate, 480p height and generated with codec profile H.264/ Baseline.
// 24. `MP4_1350KBS_30FPS_48KHZ_96KBS_720P`: This is the processed url for video that can be used with mp4 container, 1350KBS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate and 720p height.
// 25. `MP4_1350KBS_30FPS_48KHZ_96KBS_720P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 1.35MBPS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate, 720p height and generated with codec profile H.264/ High.
// 26. `MP4_1350KBS_25FPS_48KHZ_128KBS_540P_H264_MAIN`: This is the processed url for video that can be used with mp4 container, 1.35MBPS bitrate, 25fps(frame per sec), 48KHZ sampleRate, 128KBS audio bit rate, 540p height and generated with codec profile H.264/ Main.
// 27. `MP4_1500KBS_24FPS_48KHZ_96KBS_576P`: This is the processed url for video that can be used with mp4 container, 1500KBS bitrate, 24fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate and 576p height.
// 28. `MP4_1500KBS_30FPS_48KHZ_192KBS_540P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 1.5MBPS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 192KBS audio bit rate, 540p height and generated with codec profile H.264/ High.
// 29. `MP4_1500KBS_25FPS_48KHZ_128KBS_576P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 1.5MBPS bitrate, 25fps(frame per sec), 48KHZ sampleRate, 128KBS audio bit rate, 576p height and generated with codec profile H.264/ High.
// 30. `MP4_2000KBS_30FPS_48KHZ_96KBS_720P`: This is the processed url for video that can be used with mp4 container, 2000KBS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate and 720p height.
// 31. `MP4_2000KBS_30FPS_48KHZ_96KBS_720P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 2MBPS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate, 720p height and generated with codec profile H.264/ High.
// 32. `MP4_2000KBS_30FPS_48KHZ_192KBS_720P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 2MBPS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 192KBS audio bit rate, 720p height and generated with codec profile H.264/ High.
// 33. `MP4_2100KBS_30FPS_48KHZ_192KBS_576P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 2.1MBPS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 192KBS audio bit rate, 576p height and generated with codec profile H.264/ High.
// 34. `MP4_2100KBS_30FPS_48KHZ_192KBS_480P_H264_MAIN`: This is the processed url for video that can be used with mp4 container, 2.1MBPS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 192KBS audio bit rate, 480p height and generated with codec profile H.264/ Main.
// 35. `MP4_3400KBS_30FPS_48KHZ_192KBS_1080P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 3.4MBPS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 192KBS audio bit rate, 1080p height and generated with codec profile H.264/ High.
// 36. `MP4_3500KBS_24FPS_48KHZ_96KBS_1080P`: This is the processed url for video that can be used with mp4 container, 3500KBS bitrate, 24fps(frame per sec), 48KHZ sampleRate, 96KBS audio bit rate and 1080p height.
// 37. `MP4_3500KBS_30FPS_48KHZ_128KBS_720P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 3.5MBPS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 128KBS audio bit rate, 720p height and generated with codec profile H.264/ High.
// 38. `MP4_4000KBS_30FPS_48KHZ_192KBS_1080P`: This is the processed url for video that can be used with mp4 container, 4000KBS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 192KBS audio bit rate and 1080p height.
// 39. `MP4_4000KBS_30FPS_48KHZ_192KBS_1080P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 4MBPS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 192KBS audio bit rate, 1080p height and generated with codec profile H.264/ High.
// 40. `MP4_10000KBS_30FPS_48KHZ_320KBS_1080P`: This is the processed url for video that can be used with mp4 container, 10000KBS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 320KBS audio bit rate and 1080p height.
// 41. `MP4_10000KBS_30FPS_48KHZ_320KBS_1080P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 10MBPS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 320KBS audio bit rate, 1080p height and generated with codec profile H.264/ High.
// 42. `MP4_20000KBS_AUTOFPS_48KHZ_320KBS`: This is the processed url for video that can be used with mp4 container, 20000KBS bitrate, auto fps, 48KHZ sampleRate, 320KBS audio bit rate.
// 43. `MP4_20000KBS_AUTOFPS_48KHZ_320KBS_1080P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 20MBPS bitrate, auto fps, 48KHZ sampleRate, 320KBS audio bit rate, 1080p height and generated with codec profile H.264/ High.
// 44. `MP4_25000KBS_30FPS_48KHZ_192KBS_1080P_H264_HIGH`: This is the processed url for video that can be used with mp4 container, 25MBPS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 192KBS audio bit rate, 1080p height and generated with codec profile H.264/ High.
// 45. `MP4_25000KBS_30FPS_48KHZ_192KBS_1080P_H264_MAIN`: This is the processed url for video that can be used with mp4 container, 25MBPS bitrate, 30fps(frame per sec), 48KHZ sampleRate, 192KBS audio bit rate, 1080p height and generated with codec profile H.264/ Main.
type CaProcessedUrlType string

// CaProcessedUrlsMap Map containing processed urls of the asset. Key is the processed type and value is the url
type CaProcessedUrlsMap map[string]map[string]interface{}

// CaProgram Use this field to specify which program you are uploading an asset for. Currently, the accepted value here on registration is to associate an asset with a DSP advertiser.
type CaProgram string

// CaProgramSpecifications Specification Check for program, This contains program name and specifications
type CaProgramSpecifications struct {
	SpecProgramName *CaSpecificationProgram `json:"specProgramName,omitempty"`

	// Specifications List of specifications
	Specifications *CaSpecificationList `json:"specifications,omitempty"`
}

// CaProgramSpecificationsList Specification Checks for all programs
type CaProgramSpecificationsList = []CaProgramSpecifications

// CaRange defines model for caRange.
type CaRange struct {
	End   *string `json:"end,omitempty"`
	Start *string `json:"start,omitempty"`
}

// CaRangeFilter Filter assets which have certain ranges of asset attributes.
//
// For example, filter assets which have file size in the range of [10,20] or [40,50].
type CaRangeFilter struct {
	Range      *[]CaRange                 `json:"range,omitempty"`
	RangeField *CaValueRangeFilterOptions `json:"rangeField,omitempty"`
}

// CaRegistrationContext This is used on registration of an asset, to associate DSP assets to a specific advertiser. This is **required** for assets being uploaded for use in DSP.
type CaRegistrationContext struct {
	AssociatedPrograms *[]CaAssociatedProgram `json:"associatedPrograms,omitempty"`
}

// CaResourceNotFound 404 requested resource not found
type CaResourceNotFound struct {
	Message *string `json:"message,omitempty"`
}

// CaSearchAssetText The text used for searching assets, it matches asset name, asset name prefix, tags and ASINs associated with the assets
type CaSearchAssetText = string

// CaSearchRequestCommon defines model for caSearchRequestCommon.
type CaSearchRequestCommon struct {
	// FilterCriteria **Optional** this is used to filter results, we support two types of filters, valueFilter and rangeFilter
	FilterCriteria *CaFilterCriteria `json:"filterCriteria,omitempty"`

	// PageCriteria used for pagination
	//
	// when searching for the first page, no need to put anything, otherwise, use the token returned from previous search call
	PageCriteria *CaPageCriteria      `json:"pageCriteria,omitempty"`
	SortCriteria *CaAssetSortCriteria `json:"sortCriteria,omitempty"`

	// Text The text used for searching assets, it matches asset name, asset name prefix, tags and ASINs associated with the assets
	Text *CaSearchAssetText `json:"text,omitempty"`
}

// CaSpecCheckApprovedPrograms List of spec programs for which asset spec check is approved
type CaSpecCheckApprovedPrograms = []CaSpecificationProgram

// CaSpecification Structure containing specification
//
//	stringId: This is the translated string Id, client will be retrieving the translation corresponding to this string.
//	failureReason: This specifies the failure reason of specification.
//	arguments: Arguments required for translation string.
//	isPassed: Whether spec got passed or failed.
//	actualValue: If spec got failed then this attribute represent the actual value of the spec parameter in the file.
type CaSpecification struct {
	ActualValue *string `json:"actualValue,omitempty"`

	// Arguments List of arguments for translation string
	Arguments     *CaArgumentList `json:"arguments,omitempty"`
	FailureReason *string         `json:"failureReason,omitempty"`
	IsPassed      *bool           `json:"isPassed,omitempty"`
	StringId      *string         `json:"stringId,omitempty"`
}

// CaSpecificationList List of specifications
type CaSpecificationList = []CaSpecification

// CaSpecificationProgram defines model for caSpecificationProgram.
type CaSpecificationProgram string

// CaStorageLocationUrls defines model for caStorageLocationUrls.
type CaStorageLocationUrls struct {
	DefaultUrl *string `json:"defaultUrl,omitempty"`

	// ProcessedUrls Map containing processed urls of the asset. Key is the processed type and value is the url
	ProcessedUrls *CaProcessedUrlsMap `json:"processedUrls,omitempty"`
}

// CaURL The URL of the asset.
type CaURL = string

// CaUnauthorizedRequest 401 unauthorized request
type CaUnauthorizedRequest struct {
	Message *string `json:"message,omitempty"`
}

// CaValueFilter Filter for certain values of asset attributes
type CaValueFilter struct {
	ValueField *CaValueFilterValueField `json:"valueField,omitempty"`
	Values     *[]string                `json:"values,omitempty"`
}

// CaValueFilterValueField defines model for CaValueFilter.ValueField.
type CaValueFilterValueField string

// CaValueRangeFilterOptions defines model for caValueRangeFilterOptions.
type CaValueRangeFilterOptions struct {
	union json.RawMessage
}

// CaVersion The version of the asset.
type CaVersion = string

// CaVersionInfo defines model for caVersionInfo.
type CaVersionInfo struct {
	// LinkedAssetId The registering asset will be created as a new version of this linkedAssetId.
	LinkedAssetId *string `json:"linkedAssetId,omitempty"`

	// VersionNotes The version notes that client can associate to the asset.Versioning enables users to update an old asset, so that you can ensure the latest asset is being used. You can upload a new version of an existing asset along with version notes. Any tags/ASINs from previous version, will be retained on the new version too.
	VersionNotes *string `json:"versionNotes,omitempty"`
}

// CaVideoStreamMetadata Structure containing metadata of Video Stream.
//
//	profile: This is the profile of the stream.
//	width: This is the resolution width of stream.
//	height: This is the resolution height of stream.
//	duration: This is the duration of the stream in secs.
//	codecName: This tells the codec of the media stream.
//	codecType: This is the codec type of stream.
//	displayAspectRatio: This tells the aspect ratio of the stream.
//	bitRate: This tells the bit rate of the stream.
//	frameRate: This is the frame rate of video stream per sec.
type CaVideoStreamMetadata struct {
	BitRate            *int64   `json:"bitRate,omitempty"`
	CodecName          *string  `json:"codecName,omitempty"`
	CodecType          *string  `json:"codecType,omitempty"`
	DisplayAspectRatio *string  `json:"displayAspectRatio,omitempty"`
	Duration           *float64 `json:"duration,omitempty"`
	FrameRate          *float64 `json:"frameRate,omitempty"`
	Height             *int     `json:"height,omitempty"`
	Profile            *string  `json:"profile,omitempty"`
	Width              *int     `json:"width,omitempty"`
}

// CaassetSubTypes defines model for caassetSubTypes.
type CaassetSubTypes = []CaAssetSubType

// GetAssetParams defines parameters for GetAsset.
type GetAssetParams struct {
	// AssetId The assetId
	AssetId string `form:"assetId" json:"assetId"`

	// Version The versionId of the asset, if not included all versions will return.
	Version *string `form:"version,omitempty" json:"version,omitempty"`

	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId string `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope string `json:"Amazon-Advertising-API-Scope"`
}

// RegisterAssetJSONBody defines parameters for RegisterAsset.
type RegisterAssetJSONBody struct {
	// AsinList Tagging assets with ASIN, promotes asset discoverability downstream. If ASIN is provided at the time of upload/during asset registration, it is applied as a tag on that asset. This allows for that asset to be searchable using that ASIN#. For e.g., An advertiser may want to search for assets tagged with ASIN BC10001, so they can create a store spotlight ad with product images for that ASIN.
	AsinList         *CaAsins         `json:"asinList,omitempty"`
	AssetSubTypeList *CaassetSubTypes `json:"assetSubTypeList,omitempty"`

	// AssetType The asset type you are registering [`IMAGE`, `VIDEO`]
	AssetType *CaAssetType `json:"assetType,omitempty"`

	// AssociatedSubEntityList This field is required for sellers, but not required for vendors. The brandEntityId is required for sellers uploading assets for use in Sponsored Brands. As a best practice, ensure to include brandEntityId when uploading assets for sellers.
	AssociatedSubEntityList *CaAssociatedSubEntityList `json:"associatedSubEntityList,omitempty"`

	// Name The name to be given to the asset being registered.
	Name *CaAssetName `json:"name,omitempty"`

	// RegistrationContext This is used on registration of an asset, to associate DSP assets to a specific advertiser. This is **required** for assets being uploaded for use in DSP.
	RegistrationContext *CaRegistrationContext `json:"registrationContext,omitempty"`

	// SkipAssetSubTypesDetection Select true if you want to set an asset to a specific assetSubType, if this is not included the system may reclassify your asset based on specifications.
	SkipAssetSubTypesDetection *bool     `json:"skipAssetSubTypesDetection,omitempty"`
	Tags                       *[]string `json:"tags,omitempty"`

	// Url The url to upload the asset. The url expires in 15 minutes.
	Url         *CaAssetUploadLocation `json:"url,omitempty"`
	VersionInfo *CaVersionInfo         `json:"versionInfo,omitempty"`
}

// RegisterAssetParams defines parameters for RegisterAsset.
type RegisterAssetParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId string `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope string `json:"Amazon-Advertising-API-Scope"`
}

// SearchAssetsParams defines parameters for SearchAssets.
type SearchAssetsParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId string `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope string `json:"Amazon-Advertising-API-Scope"`
}

// GetUploadLocationJSONBody defines parameters for GetUploadLocation.
type GetUploadLocationJSONBody struct {
	// FileName The fileName of the asset.
	FileName *CaFileName `json:"fileName,omitempty"`
}

// GetUploadLocationParams defines parameters for GetUploadLocation.
type GetUploadLocationParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId string `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope string `json:"Amazon-Advertising-API-Scope"`
}

// RegisterAssetJSONRequestBody defines body for RegisterAsset for application/json ContentType.
type RegisterAssetJSONRequestBody RegisterAssetJSONBody

// SearchAssetsJSONRequestBody defines body for SearchAssets for application/json ContentType.
type SearchAssetsJSONRequestBody = CaSearchRequestCommon

// GetUploadLocationJSONRequestBody defines body for GetUploadLocation for application/json ContentType.
type GetUploadLocationJSONRequestBody GetUploadLocationJSONBody

// AsSIZE returns the union data inside the CaValueRangeFilterOptions as a SIZE
func (t CaValueRangeFilterOptions) AsSIZE() (SIZE, error) {
	var body SIZE
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSIZE overwrites any union data inside the CaValueRangeFilterOptions as the provided SIZE
func (t *CaValueRangeFilterOptions) FromSIZE(v SIZE) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSIZE performs a merge with any union data inside the CaValueRangeFilterOptions, using the provided SIZE
func (t *CaValueRangeFilterOptions) MergeSIZE(v SIZE) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDATEUPLOADED returns the union data inside the CaValueRangeFilterOptions as a DATEUPLOADED
func (t CaValueRangeFilterOptions) AsDATEUPLOADED() (DATEUPLOADED, error) {
	var body DATEUPLOADED
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDATEUPLOADED overwrites any union data inside the CaValueRangeFilterOptions as the provided DATEUPLOADED
func (t *CaValueRangeFilterOptions) FromDATEUPLOADED(v DATEUPLOADED) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDATEUPLOADED performs a merge with any union data inside the CaValueRangeFilterOptions, using the provided DATEUPLOADED
func (t *CaValueRangeFilterOptions) MergeDATEUPLOADED(v DATEUPLOADED) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t CaValueRangeFilterOptions) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CaValueRangeFilterOptions) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAsset request
	GetAsset(ctx context.Context, params *GetAssetParams) (*http.Response, error)

	// RegisterAssetWithBody request with any body
	RegisterAssetWithBody(ctx context.Context, params *RegisterAssetParams, contentType string, body io.Reader) (*http.Response, error)

	RegisterAsset(ctx context.Context, params *RegisterAssetParams, body RegisterAssetJSONRequestBody) (*http.Response, error)

	// SearchAssetsWithBody request with any body
	SearchAssetsWithBody(ctx context.Context, params *SearchAssetsParams, contentType string, body io.Reader) (*http.Response, error)

	SearchAssets(ctx context.Context, params *SearchAssetsParams, body SearchAssetsJSONRequestBody) (*http.Response, error)

	// GetUploadLocationWithBody request with any body
	GetUploadLocationWithBody(ctx context.Context, params *GetUploadLocationParams, contentType string, body io.Reader) (*http.Response, error)

	GetUploadLocation(ctx context.Context, params *GetUploadLocationParams, body GetUploadLocationJSONRequestBody) (*http.Response, error)
}

func (c *Client) GetAsset(ctx context.Context, params *GetAssetParams) (*http.Response, error) {
	req, err := NewGetAssetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) RegisterAssetWithBody(ctx context.Context, params *RegisterAssetParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewRegisterAssetRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) RegisterAsset(ctx context.Context, params *RegisterAssetParams, body RegisterAssetJSONRequestBody) (*http.Response, error) {
	req, err := NewRegisterAssetRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) SearchAssetsWithBody(ctx context.Context, params *SearchAssetsParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewSearchAssetsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) SearchAssets(ctx context.Context, params *SearchAssetsParams, body SearchAssetsJSONRequestBody) (*http.Response, error) {
	req, err := NewSearchAssetsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetUploadLocationWithBody(ctx context.Context, params *GetUploadLocationParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGetUploadLocationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetUploadLocation(ctx context.Context, params *GetUploadLocationParams, body GetUploadLocationJSONRequestBody) (*http.Response, error) {
	req, err := NewGetUploadLocationRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewGetAssetRequest generates requests for GetAsset
func NewGetAssetRequest(server string, params *GetAssetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assetId", runtime.ParamLocationQuery, params.AssetId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				values := make([]string, 0)
				for _, v2 := range v {
					values = append(values, v2)
				}
				queryValues.Add(k, strings.Join(values, ","))
			}
		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					values := make([]string, 0)
					for _, v2 := range v {
						values = append(values, v2)
					}
					queryValues.Add(k, strings.Join(values, ","))
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewRegisterAssetRequest calls the generic RegisterAsset builder with application/json body
func NewRegisterAssetRequest(server string, params *RegisterAssetParams, body RegisterAssetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterAssetRequestWithBody(server, params, "application/json", bodyReader)
}

// NewRegisterAssetRequestWithBody generates requests for RegisterAsset with any type of body
func NewRegisterAssetRequestWithBody(server string, params *RegisterAssetParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewSearchAssetsRequest calls the generic SearchAssets builder with application/json body
func NewSearchAssetsRequest(server string, params *SearchAssetsParams, body SearchAssetsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchAssetsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSearchAssetsRequestWithBody generates requests for SearchAssets with any type of body
func NewSearchAssetsRequestWithBody(server string, params *SearchAssetsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/search/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewGetUploadLocationRequest calls the generic GetUploadLocation builder with application/json body
func NewGetUploadLocationRequest(server string, params *GetUploadLocationParams, body GetUploadLocationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetUploadLocationRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetUploadLocationRequestWithBody generates requests for GetUploadLocation with any type of body
func NewGetUploadLocationRequestWithBody(server string, params *GetUploadLocationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/upload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAssetWithResponse request
	GetAssetWithResponse(ctx context.Context, params *GetAssetParams) (*GetAssetResp, error)

	// RegisterAssetWithBodyWithResponse request with any body
	RegisterAssetWithBodyWithResponse(ctx context.Context, params *RegisterAssetParams, contentType string, body io.Reader) (*RegisterAssetResp, error)

	RegisterAssetWithResponse(ctx context.Context, params *RegisterAssetParams, body RegisterAssetJSONRequestBody) (*RegisterAssetResp, error)

	// SearchAssetsWithBodyWithResponse request with any body
	SearchAssetsWithBodyWithResponse(ctx context.Context, params *SearchAssetsParams, contentType string, body io.Reader) (*SearchAssetsResp, error)

	SearchAssetsWithResponse(ctx context.Context, params *SearchAssetsParams, body SearchAssetsJSONRequestBody) (*SearchAssetsResp, error)

	// GetUploadLocationWithBodyWithResponse request with any body
	GetUploadLocationWithBodyWithResponse(ctx context.Context, params *GetUploadLocationParams, contentType string, body io.Reader) (*GetUploadLocationResp, error)

	GetUploadLocationWithResponse(ctx context.Context, params *GetUploadLocationParams, body GetUploadLocationJSONRequestBody) (*GetUploadLocationResp, error)
}

type GetAssetResp struct {
	Body                                             []byte
	HTTPResponse                                     *http.Response
	ApplicationvndCreativeassetsgetresponseV3JSON200 *struct {
		AssetGlobal *CaAssetGlobal `json:"assetGlobal,omitempty"`

		// AssetVersionList The asset version list.
		AssetVersionList *CaAssetVersionList `json:"assetVersionList,omitempty"`
	}
	ApplicationvndCreativeassetsgetresponseV3JSON400 *CaBadRequest
	ApplicationvndCreativeassetsgetresponseV3JSON401 *CaUnauthorizedRequest
	ApplicationvndCreativeassetsgetresponseV3JSON403 *CaForbiddenRequest
	ApplicationvndCreativeassetsgetresponseV3JSON500 *CaInternalError
}

// Status returns HTTPResponse.Status
func (r GetAssetResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterAssetResp struct {
	Body                                                  []byte
	HTTPResponse                                          *http.Response
	ApplicationvndCreativeassetsregisterresponseV3JSON200 *struct {
		// AssetId The asset identifier.
		AssetId *CaAssetId `json:"assetId,omitempty"`

		// FailedSpecChecks Specification Checks for all programs
		FailedSpecChecks *CaProgramSpecificationsList `json:"failedSpecChecks,omitempty"`

		// VersionId The version of the asset.
		VersionId *CaVersion `json:"versionId,omitempty"`
	}
	ApplicationvndCreativeassetsregisterresponseV3JSON400 *CaBadRequest
	ApplicationvndCreativeassetsregisterresponseV3JSON401 *CaUnauthorizedRequest
	ApplicationvndCreativeassetsregisterresponseV3JSON403 *CaForbiddenRequest
	ApplicationvndCreativeassetsregisterresponseV3JSON404 *CaResourceNotFound
	ApplicationvndCreativeassetsregisterresponseV3JSON500 *CaInternalError
}

// Status returns HTTPResponse.Status
func (r RegisterAssetResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterAssetResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchAssetsResp struct {
	Body                                                      []byte
	HTTPResponse                                              *http.Response
	ApplicationvndCreativeassetssearchassetsresponseV3JSON200 *struct {
		AssetList    *[]CaAsset `json:"assetList,omitempty"`
		Token        *string    `json:"token,omitempty"`
		TotalRecords *int64     `json:"totalRecords,omitempty"`
	}
	ApplicationvndCreativeassetssearchassetsresponseV3JSON400 *CaBadRequest
	ApplicationvndCreativeassetssearchassetsresponseV3JSON401 *CaUnauthorizedRequest
	ApplicationvndCreativeassetssearchassetsresponseV3JSON403 *CaForbiddenRequest
	ApplicationvndCreativeassetssearchassetsresponseV3JSON500 *CaInternalError
}

// Status returns HTTPResponse.Status
func (r SearchAssetsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchAssetsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUploadLocationResp struct {
	Body                                                []byte
	HTTPResponse                                        *http.Response
	ApplicationvndCreativeassetsuploadresponseV3JSON200 *struct {
		// Url The url to upload the asset. The url expires in 15 minutes.
		Url *CaAssetUploadLocation `json:"url,omitempty"`
	}
	ApplicationvndCreativeassetsuploadresponseV3JSON400 *CaBadRequest
	ApplicationvndCreativeassetsuploadresponseV3JSON401 *CaUnauthorizedRequest
	ApplicationvndCreativeassetsuploadresponseV3JSON403 *CaForbiddenRequest
	ApplicationvndCreativeassetsuploadresponseV3JSON500 *CaInternalError
}

// Status returns HTTPResponse.Status
func (r GetUploadLocationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUploadLocationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAssetWithResponse request returning *GetAssetResp
func (c *ClientWithResponses) GetAssetWithResponse(ctx context.Context, params *GetAssetParams) (*GetAssetResp, error) {
	rsp, err := c.GetAsset(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetResp(rsp)
}

// RegisterAssetWithBodyWithResponse request with arbitrary body returning *RegisterAssetResp
func (c *ClientWithResponses) RegisterAssetWithBodyWithResponse(ctx context.Context, params *RegisterAssetParams, contentType string, body io.Reader) (*RegisterAssetResp, error) {
	rsp, err := c.RegisterAssetWithBody(ctx, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseRegisterAssetResp(rsp)
}

func (c *ClientWithResponses) RegisterAssetWithResponse(ctx context.Context, params *RegisterAssetParams, body RegisterAssetJSONRequestBody) (*RegisterAssetResp, error) {
	rsp, err := c.RegisterAsset(ctx, params, body)
	if err != nil {
		return nil, err
	}
	return ParseRegisterAssetResp(rsp)
}

// SearchAssetsWithBodyWithResponse request with arbitrary body returning *SearchAssetsResp
func (c *ClientWithResponses) SearchAssetsWithBodyWithResponse(ctx context.Context, params *SearchAssetsParams, contentType string, body io.Reader) (*SearchAssetsResp, error) {
	rsp, err := c.SearchAssetsWithBody(ctx, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseSearchAssetsResp(rsp)
}

func (c *ClientWithResponses) SearchAssetsWithResponse(ctx context.Context, params *SearchAssetsParams, body SearchAssetsJSONRequestBody) (*SearchAssetsResp, error) {
	rsp, err := c.SearchAssets(ctx, params, body)
	if err != nil {
		return nil, err
	}
	return ParseSearchAssetsResp(rsp)
}

// GetUploadLocationWithBodyWithResponse request with arbitrary body returning *GetUploadLocationResp
func (c *ClientWithResponses) GetUploadLocationWithBodyWithResponse(ctx context.Context, params *GetUploadLocationParams, contentType string, body io.Reader) (*GetUploadLocationResp, error) {
	rsp, err := c.GetUploadLocationWithBody(ctx, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGetUploadLocationResp(rsp)
}

func (c *ClientWithResponses) GetUploadLocationWithResponse(ctx context.Context, params *GetUploadLocationParams, body GetUploadLocationJSONRequestBody) (*GetUploadLocationResp, error) {
	rsp, err := c.GetUploadLocation(ctx, params, body)
	if err != nil {
		return nil, err
	}
	return ParseGetUploadLocationResp(rsp)
}

// ParseGetAssetResp parses an HTTP response from a GetAssetWithResponse call
func ParseGetAssetResp(rsp *http.Response) (*GetAssetResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AssetGlobal *CaAssetGlobal `json:"assetGlobal,omitempty"`

			// AssetVersionList The asset version list.
			AssetVersionList *CaAssetVersionList `json:"assetVersionList,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCreativeassetsgetresponseV3JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CaBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCreativeassetsgetresponseV3JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CaUnauthorizedRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCreativeassetsgetresponseV3JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CaForbiddenRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCreativeassetsgetresponseV3JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest CaInternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCreativeassetsgetresponseV3JSON500 = &dest

	}

	return response, nil
}

// ParseRegisterAssetResp parses an HTTP response from a RegisterAssetWithResponse call
func ParseRegisterAssetResp(rsp *http.Response) (*RegisterAssetResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterAssetResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AssetId The asset identifier.
			AssetId *CaAssetId `json:"assetId,omitempty"`

			// FailedSpecChecks Specification Checks for all programs
			FailedSpecChecks *CaProgramSpecificationsList `json:"failedSpecChecks,omitempty"`

			// VersionId The version of the asset.
			VersionId *CaVersion `json:"versionId,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCreativeassetsregisterresponseV3JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CaBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCreativeassetsregisterresponseV3JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CaUnauthorizedRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCreativeassetsregisterresponseV3JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CaForbiddenRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCreativeassetsregisterresponseV3JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest CaResourceNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCreativeassetsregisterresponseV3JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest CaInternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCreativeassetsregisterresponseV3JSON500 = &dest

	}

	return response, nil
}

// ParseSearchAssetsResp parses an HTTP response from a SearchAssetsWithResponse call
func ParseSearchAssetsResp(rsp *http.Response) (*SearchAssetsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchAssetsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AssetList    *[]CaAsset `json:"assetList,omitempty"`
			Token        *string    `json:"token,omitempty"`
			TotalRecords *int64     `json:"totalRecords,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCreativeassetssearchassetsresponseV3JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CaBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCreativeassetssearchassetsresponseV3JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CaUnauthorizedRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCreativeassetssearchassetsresponseV3JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CaForbiddenRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCreativeassetssearchassetsresponseV3JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest CaInternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCreativeassetssearchassetsresponseV3JSON500 = &dest

	}

	return response, nil
}

// ParseGetUploadLocationResp parses an HTTP response from a GetUploadLocationWithResponse call
func ParseGetUploadLocationResp(rsp *http.Response) (*GetUploadLocationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUploadLocationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Url The url to upload the asset. The url expires in 15 minutes.
			Url *CaAssetUploadLocation `json:"url,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCreativeassetsuploadresponseV3JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest CaBadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCreativeassetsuploadresponseV3JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest CaUnauthorizedRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCreativeassetsuploadresponseV3JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest CaForbiddenRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCreativeassetsuploadresponseV3JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest CaInternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndCreativeassetsuploadresponseV3JSON500 = &dest

	}

	return response, nil
}
