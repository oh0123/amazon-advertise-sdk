// Package storesanalyticsreport provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.15.0 DO NOT EDIT.
package storesanalyticsreport

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	runt "runtime"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
)

// Defines values for AsinEngagementDimension.
const (
	ASIN AsinEngagementDimension = "ASIN"
)

// Defines values for AsinEngagementMetric.
const (
	AsinEngagementMetricADDTOCARTS          AsinEngagementMetric = "ADD_TO_CARTS"
	AsinEngagementMetricAVERAGEINSTOCKPRICE AsinEngagementMetric = "AVERAGE_IN_STOCK_PRICE"
	AsinEngagementMetricAVERAGESALEPRICE    AsinEngagementMetric = "AVERAGE_SALE_PRICE"
	AsinEngagementMetricCLICKRATE           AsinEngagementMetric = "CLICK_RATE"
	AsinEngagementMetricCLICKS              AsinEngagementMetric = "CLICKS"
	AsinEngagementMetricCONVERSIONRATE      AsinEngagementMetric = "CONVERSION_RATE"
	AsinEngagementMetricINSTOCKRATE         AsinEngagementMetric = "IN_STOCK_RATE"
	AsinEngagementMetricINSTOCKVIEWS        AsinEngagementMetric = "IN_STOCK_VIEWS"
	AsinEngagementMetricORDERS              AsinEngagementMetric = "ORDERS"
	AsinEngagementMetricRENDERS             AsinEngagementMetric = "RENDERS"
	AsinEngagementMetricTOTALCLICKS         AsinEngagementMetric = "TOTAL_CLICKS"
	AsinEngagementMetricTOTALVIEWS          AsinEngagementMetric = "TOTAL_VIEWS"
	AsinEngagementMetricUNITS               AsinEngagementMetric = "UNITS"
	AsinEngagementMetricVIEWS               AsinEngagementMetric = "VIEWS"
)

// Defines values for InsightDimension.
const (
	DATE   InsightDimension = "DATE"
	PAGE   InsightDimension = "PAGE"
	SOURCE InsightDimension = "SOURCE"
	TAG    InsightDimension = "TAG"
)

// Defines values for InsightMetric.
const (
	InsightMetricCONTRIBUTORS        InsightMetric = "CONTRIBUTORS"
	InsightMetricDWELL               InsightMetric = "DWELL"
	InsightMetricORDERS              InsightMetric = "ORDERS"
	InsightMetricPEERDWELL           InsightMetric = "PEER_DWELL"
	InsightMetricPERCENTILEINPEERSET InsightMetric = "PERCENTILE_IN_PEERSET"
	InsightMetricRECOMMENDATIONS     InsightMetric = "RECOMMENDATIONS"
	InsightMetricSALES               InsightMetric = "SALES"
	InsightMetricSCORELEVEL          InsightMetric = "SCORE_LEVEL"
	InsightMetricUNITS               InsightMetric = "UNITS"
	InsightMetricVIEWS               InsightMetric = "VIEWS"
	InsightMetricVISITORS            InsightMetric = "VISITORS"
	InsightMetricVISITS              InsightMetric = "VISITS"
)

// Defines values for SortOrder.
const (
	ASC  SortOrder = "ASC"
	DESC SortOrder = "DESC"
)

// Defines values for TrafficSource.
const (
	ADS     TrafficSource = "ADS"
	ORGANIC TrafficSource = "ORGANIC"
	OTHER   TrafficSource = "OTHER"
)

// AsinEngagementDetail A key-value pair map which contains the dimension and metric information. The key is either dimension name or metric name, while the value is the corresponding dimension value or metric value.
type AsinEngagementDetail map[string]AsinEngagementDetail_AdditionalProperties

// AsinEngagementDetail0 defines model for .
type AsinEngagementDetail0 = string

// AsinEngagementDetail1 defines model for .
type AsinEngagementDetail1 = int

// AsinEngagementDetail2 defines model for .
type AsinEngagementDetail2 = float32

// AsinEngagementDetail_AdditionalProperties defines model for AsinEngagementDetail.AdditionalProperties.
type AsinEngagementDetail_AdditionalProperties struct {
	union json.RawMessage
}

// AsinEngagementDimension User can use dimensions to aggregate the engagement metrics. Supported dimension types:
//
//   - `ASIN` - Amazon Standard Identification Number.
//
//     When *dimension* is omitted, user can retrieve select metrics aggregated at the store level. See *metrics* for details.
type AsinEngagementDimension string

// AsinEngagementMetric Store Metric Types: Metrics aggregated at the store level. To be used with *dimension* omitted, otherwise a 422 response is returned.
//
//   - `TOTAL_VIEWS` - Total number of times customers viewed ASINs on the store’s pages. A view can happen once per store page visit.
//
//   - `TOTAL_CLICKS` - Total count of times a customer clicked an ASIN related widget on the store’s pages.
//
//     Asin Metric Types: Metrics aggregated at the ASIN level. To be used with a supported dimension type (see *dimension*), otherwise a 422 response is returned.
//
//   - `RENDERS` - Number of times the asin rendered on a store page, this does not guarentee the customer saw the asin.
//
//   - `VIEWS` - Number of times the a customer viewed an ASIN. Can happen once per page visit.
//
//   - `ORDERS` - Estimated total orders placed by Store visitors on the day of the ASIN view.
//     Orders can have one or more total units.
//
//   - `UNITS` - Estimated units purchased by Store visitors during attributed orders for the ASIN.
//
//   - `ADD_TO_CARTS` - Total number of times an asin was added to cart by a customer on a store page.
//
//   - `IN_STOCK_VIEWS` - Total views of an asin on a store page while the asin was in stock. For asins with variations, the customer must have selected a variation which as in stock to be counted.
//
//   - `AVERAGE_IN_STOCK_PRICE` - Average price in local currency the asin was viewed at by customers while it was in stock.
//
//   - `IN_STOCK_RATE` - Rate at which customers viewed an asin while it was in stock.
//
//   - `AVERAGE_SALE_PRICE` - Average price in local currency for which the asin sold for during the order.
//
//   - `CONVERSION_RATE` - Rate at which customers ordered a unit of the item over how many times customers clicked the item.
//
//   - `CLICKS` - Count of how many times a customer clicked an asin related widget on the store page.
//
//   - `CLICK_RATE` - Rate at which the asin was clicker per view. This ratio can be above one if the widget is interacted with on a widget with engaging features. (Product Showcase, Variation Selection in Product Grid, or Interactive Image)
type AsinEngagementMetric string

// GetAsinEngagementForStoreRequest defines model for GetAsinEngagementForStoreRequest.
type GetAsinEngagementForStoreRequest struct {
	// Dimension User can use dimensions to aggregate the engagement metrics. Supported dimension types:
	//   * `ASIN` - Amazon Standard Identification Number.
	//
	//   When *dimension* is omitted, user can retrieve select metrics aggregated at the store level. See *metrics* for details.
	Dimension *AsinEngagementDimension `json:"dimension,omitempty"`

	// EndDate The end date (inclusive) in YYYY-MM-DD format for the time period from when to fetch the insights.
	EndDate openapi_types.Date `json:"endDate"`

	// Metrics List of the engagement metrics to be fetched. At least one metric should be specified.
	Metrics []AsinEngagementMetric `json:"metrics"`

	// OrderBy Describes whether a sort should be ascending (ASC) or descending (DESC).
	OrderBy *SortOrder `json:"orderBy,omitempty"`

	// SortBy Nullable metric to sort on. If a value is provided, it must also appear in the metrics list. If no value is provided, the result is not guaranteed to be sorted. This field is only valid when the dimension is ASIN.
	SortBy *interface{} `json:"sortBy,omitempty"`

	// StartDate The start date (inclusive) in YYYY-MM-DD format for the time period from when to fetch the insights.
	StartDate openapi_types.Date `json:"startDate"`
}

// GetAsinEngagementForStoreResponse defines model for GetAsinEngagementForStoreResponse.
type GetAsinEngagementForStoreResponse struct {
	// Dimension User can use dimensions to aggregate the engagement metrics. Supported dimension types:
	//   * `ASIN` - Amazon Standard Identification Number.
	//
	//   When *dimension* is omitted, user can retrieve select metrics aggregated at the store level. See *metrics* for details.
	Dimension      *AsinEngagementDimension `json:"dimension,omitempty"`
	MetricsDetails *[]AsinEngagementDetail  `json:"metricsDetails,omitempty"`
}

// GetInsightsForStoreRequest defines model for GetInsightsForStoreRequest.
type GetInsightsForStoreRequest struct {
	// Dimension User can use dimensions to aggregate the insight metrics. Supported dimension types:
	//   * `DATE` - Date of the visitor’s visit.
	//   * `PAGE` - The Store page.
	//   * `SOURCE` - The traffic source from which the visitor arrived to the Store.
	//   * `TAG` - The traffic tag from which the visitor arrived to the Store.
	//
	// <br><br> Not all InsightMetrics can be aggregated using above dimensions. Below is the supported metrics for each dimension,
	// <table>
	//   <tr>
	//     <th>InsightDimension</th>
	//     <th>Supported InsightMetrics</th>
	//   </tr>
	//   <tr>
	//     <th>DATE</th>
	//     <th>All the InsightMetrics</th>
	//   </tr>
	//   <tr>
	//     <th>PAGE</th>
	//     <th>VIEWS, ORDERS, UNITS, SALES, VISITS</th>
	//   </tr>
	//   <tr>
	//     <th>SOURCE</th>
	//     <th>VIEWS, ORDERS, UNITS, SALES, VISITS</th>
	//   </tr>
	//   <tr>
	//     <th>TAG</th>
	//     <th>VIEWS, ORDERS, UNITS, SALES, VISITS</th>
	//   </tr>
	// </table>
	// <br><br>
	Dimension InsightDimension `json:"dimension"`

	// EndDate The end date (inclusive) in YYYY-MM-DD format for the time period from when to fetch the insights.
	EndDate openapi_types.Date `json:"endDate"`
	Filter  *InsightFilter     `json:"filter,omitempty"`

	// MaxResult The max number of result that will be returned in one response. The max allowed value will be 1500. If the parameter is not presented, it will be default to 1500.
	MaxResult *int `json:"maxResult,omitempty"`

	// Metrics List of the insight metrics to be fetched. Only one metric should be specified.
	Metrics []InsightMetric `json:"metrics"`

	// PaginationToken The token that last request returned. It will be used to fetch next page of response.
	PaginationToken *string `json:"paginationToken,omitempty"`

	// StartDate The start date (inclusive) in YYYY-MM-DD format for the time period from when to fetch the insights. The earliest date will be 2018-09-01, if the input is earlier, it will be default to 2018-09-01
	StartDate openapi_types.Date `json:"startDate"`
}

// GetInsightsForStoreResponse defines model for GetInsightsForStoreResponse.
type GetInsightsForStoreResponse struct {
	// Dimension User can use dimensions to aggregate the insight metrics. Supported dimension types:
	//   * `DATE` - Date of the visitor’s visit.
	//   * `PAGE` - The Store page.
	//   * `SOURCE` - The traffic source from which the visitor arrived to the Store.
	//   * `TAG` - The traffic tag from which the visitor arrived to the Store.
	//
	// <br><br> Not all InsightMetrics can be aggregated using above dimensions. Below is the supported metrics for each dimension,
	// <table>
	//   <tr>
	//     <th>InsightDimension</th>
	//     <th>Supported InsightMetrics</th>
	//   </tr>
	//   <tr>
	//     <th>DATE</th>
	//     <th>All the InsightMetrics</th>
	//   </tr>
	//   <tr>
	//     <th>PAGE</th>
	//     <th>VIEWS, ORDERS, UNITS, SALES, VISITS</th>
	//   </tr>
	//   <tr>
	//     <th>SOURCE</th>
	//     <th>VIEWS, ORDERS, UNITS, SALES, VISITS</th>
	//   </tr>
	//   <tr>
	//     <th>TAG</th>
	//     <th>VIEWS, ORDERS, UNITS, SALES, VISITS</th>
	//   </tr>
	// </table>
	// <br><br>
	Dimension *InsightDimension `json:"dimension,omitempty"`

	// Filter The filter to restrict the return data. Users can specifiy the pages/source/tags they feel interested in for the insights. The relationship between each field is 'AND'. E.g. The user can speficy {pageIds=[page1_id], sources=[source1]} to retrieve the related insights for page1 and source1. The user can specify {pageIds=[page1_id], tags=[tag1_name]} to retrieve related insights for page1 and tag1. <br><br> However, specifying both "sources" and "tags" is currently not supported. Users cannot retrieve insights for given sources and tags as all the tags belong to a specific source named "tagged".
	Filter         *InsightFilter          `json:"filter,omitempty"`
	MetricsDetails *[]InsightMetricsDetail `json:"metricsDetails,omitempty"`

	// PaginationToken The token can be directly used to fetch next page of the result. The token can only been used when the token is been created less than 24 hours and the request input is same as last request
	PaginationToken *string `json:"paginationToken,omitempty"`
}

// InsightDimension User can use dimensions to aggregate the insight metrics. Supported dimension types:
//   - `DATE` - Date of the visitor’s visit.
//   - `PAGE` - The Store page.
//   - `SOURCE` - The traffic source from which the visitor arrived to the Store.
//   - `TAG` - The traffic tag from which the visitor arrived to the Store.
//
// <br><br> Not all InsightMetrics can be aggregated using above dimensions. Below is the supported metrics for each dimension,
// <table>
//
//	<tr>
//	  <th>InsightDimension</th>
//	  <th>Supported InsightMetrics</th>
//	</tr>
//	<tr>
//	  <th>DATE</th>
//	  <th>All the InsightMetrics</th>
//	</tr>
//	<tr>
//	  <th>PAGE</th>
//	  <th>VIEWS, ORDERS, UNITS, SALES, VISITS</th>
//	</tr>
//	<tr>
//	  <th>SOURCE</th>
//	  <th>VIEWS, ORDERS, UNITS, SALES, VISITS</th>
//	</tr>
//	<tr>
//	  <th>TAG</th>
//	  <th>VIEWS, ORDERS, UNITS, SALES, VISITS</th>
//	</tr>
//
// </table>
// <br><br>
type InsightDimension string

// InsightFilter The filter to restrict the return data. Users can specifiy the pages/source/tags they feel interested in for the insights. The relationship between each field is 'AND'. E.g. The user can speficy {pageIds=[page1_id], sources=[source1]} to retrieve the related insights for page1 and source1. The user can specify {pageIds=[page1_id], tags=[tag1_name]} to retrieve related insights for page1 and tag1. <br><br> However, specifying both "sources" and "tags" is currently not supported. Users cannot retrieve insights for given sources and tags as all the tags belong to a specific source named "tagged".
type InsightFilter struct {
	// PageIds List of pages to be fetched for insight metrics. Users can first make request to the API with the same parameters but without the filter to retrieve all the available page ids.
	PageIds *[]string `json:"pageIds,omitempty"`

	// Sources List of sources to be fetched for insight metrics.
	Sources *[]TrafficSource `json:"sources,omitempty"`

	// Tags List of tags to be fetched for insight metrics. Users can first make request to the API with the same parameters but without the filter to retrieve all the available tag names.
	Tags *[]string `json:"tags,omitempty"`
}

// InsightMetric Insight Metric Type:
//   - `VIEWS` - Number of page views. Data is available from August 30, 2017. <br> "VIEW" metric can be aggregated by all InsightDimensions.
//   - `ORDERS` - Estimated total orders placed by Store visitors within 14 days of
//     their visit. Orders contain one or more units sold. Data is
//     available from April 15, 2018. <br> "ORDERS" metric can be aggregated by all the InsightDimensions.
//   - `UNITS` - Estimated units purchased by Store visitors within 14 days of their
//     last visit. Data is available from December 25, 2017. <br> "UNITS" metric can be aggregated by all the InsightDimensions.
//   - `SALES` - Estimated total sales generated by Store visitors within 14 days of
//     their last visit. Data is available from December 25, 2017. <br> "SALES" metric can be aggregated by all the InsightDimensions.
//   - `VISITS` - Total visits to a page or from a traffic source within a single day.
//     Each visitor can visit more than one page, and they can visit your
//     Store from more than one traffic source. Data is available from May
//     30, 2018. <br> "VISITS" metric can be aggregated by all the InsightDimensions.
//   - `VISITORS` - Total visitors to your Store within the selected date range,
//     calculated based on daily unique users or devices. One visitor can
//     visit more than one page, and they can visit your Store from more
//     than one traffic source. The total visitors by page or source may
//     sum up to a value larger than the total visitors by day to the Store
//     or to the page. Data is available from August 30, 2017. <br> "VISITORS" metric currently can only be aggregated by InsightDimention "Date". Users won't be able to get this metric when specifying other InsightDimensions. This is because number of visitors are measured at store level. This also means this metric won't be impacted by the InsightFilter.
//     <br> "SCORE_LEVEL" This metric is for Store Quality rating calculated on various factors by SEAS. It can be `HIGH`, `MEDIUM` or `LOW`.
//     <br> "PERCENTILE_IN_PEERSET" This metric is to show the percentile in similar(peer) stores. This is in Beta mode and will only be available for Insights Dashboard client.
//     <br> "RECOMMENDATIONS" This metric is an Array of Object containing two fields. First field, `recommendedAction` is a description of recommendation (for example `Add a video`) and second field, `actionWeight`, is the improvement it would bring in the overall store quality score This is in Beta mode and will only be available for Insights Dashboard client.
//     <br> "CONTRIBUTORS" This metric is the array of recommendations applied by the Store Owner which resulted in the improvement of overall store quality score. This is in Beta mode and will only be available for Insights Dashboard client.
//     <br> "DWELL" This metric is the time a customer spends on the store, on an average. This is in Beta mode and will only be available for Insights Dashboard client.
//     <br> "PEER_DWELL" This metric is the time a customer spends on the other similar (peer) stores the store, on an average.This is in Beta mode and will only be available for Insights Dashboard client.
type InsightMetric string

// InsightMetricsDetail A key-value pair map which contains the dimension and metric information. The key is either dimension name or metric name, while the value is the corresponding dimension value or metric value. Addition of boolean,Array and Object is solely for the Store Quality Score metrics purpose which are in BETA phase currently.
type InsightMetricsDetail map[string]InsightMetricsDetail_AdditionalProperties

// InsightMetricsDetail0 defines model for .
type InsightMetricsDetail0 = string

// InsightMetricsDetail1 defines model for .
type InsightMetricsDetail1 = int

// InsightMetricsDetail2 defines model for .
type InsightMetricsDetail2 = float32

// InsightMetricsDetail3 defines model for .
type InsightMetricsDetail3 = bool

// InsightMetricsDetail4 List of CONTRIBUTORS to the store quality score.
type InsightMetricsDetail4 = []string

// InsightMetricsDetail5 List of RECOMMENDATIONS to the store quality score.
type InsightMetricsDetail5 = []StoreQualityRecommendation

// InsightMetricsDetail_AdditionalProperties defines model for InsightMetricsDetail.AdditionalProperties.
type InsightMetricsDetail_AdditionalProperties struct {
	union json.RawMessage
}

// SortOrder Describes whether a sort should be ascending (ASC) or descending (DESC).
type SortOrder string

// StoreQualityRecommendation The Object containing recommendations to improve store quality score.
type StoreQualityRecommendation struct {
	// ActionWeight The weight by which store quality could improve by this recommendations.
	ActionWeight *float32 `json:"actionWeight,omitempty"`

	// RecommendedAction description of the recommendation.
	RecommendedAction *string `json:"recommendedAction,omitempty"`
}

// StoresAnalyticsAPIErrorResponse The error response object for analytics API.
type StoresAnalyticsAPIErrorResponse struct {
	// Code The HTTP status code of the response.
	Code *string `json:"code,omitempty"`

	// Details A human-readable description of the response.
	Details *string `json:"details,omitempty"`
}

// TrafficSource Traffic Source Type:
//   - `ADS` - Traffic from Sponsored Brands ads on Amazon.
//   - `ORGANIC` - Traffic originating from your brand link on Amazon product detail pages.
//   - `OTHER` - All other traffic sources not categorized.
type TrafficSource string

// GetAsinEngagementForStoreApplicationVndGetAsinEngagementForStoreRequestV1PlusJSONRequestBody defines body for GetAsinEngagementForStore for application/vnd.GetAsinEngagementForStoreRequest.v1+json ContentType.
type GetAsinEngagementForStoreApplicationVndGetAsinEngagementForStoreRequestV1PlusJSONRequestBody = GetAsinEngagementForStoreRequest

// GetInsightsForStoreAPIApplicationVndGetInsightsForStoreRequestV1PlusJSONRequestBody defines body for GetInsightsForStoreAPI for application/vnd.GetInsightsForStoreRequest.v1+json ContentType.
type GetInsightsForStoreAPIApplicationVndGetInsightsForStoreRequestV1PlusJSONRequestBody = GetInsightsForStoreRequest

// AsAsinEngagementDetail0 returns the union data inside the AsinEngagementDetail_AdditionalProperties as a AsinEngagementDetail0
func (t AsinEngagementDetail_AdditionalProperties) AsAsinEngagementDetail0() (AsinEngagementDetail0, error) {
	var body AsinEngagementDetail0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAsinEngagementDetail0 overwrites any union data inside the AsinEngagementDetail_AdditionalProperties as the provided AsinEngagementDetail0
func (t *AsinEngagementDetail_AdditionalProperties) FromAsinEngagementDetail0(v AsinEngagementDetail0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAsinEngagementDetail0 performs a merge with any union data inside the AsinEngagementDetail_AdditionalProperties, using the provided AsinEngagementDetail0
func (t *AsinEngagementDetail_AdditionalProperties) MergeAsinEngagementDetail0(v AsinEngagementDetail0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAsinEngagementDetail1 returns the union data inside the AsinEngagementDetail_AdditionalProperties as a AsinEngagementDetail1
func (t AsinEngagementDetail_AdditionalProperties) AsAsinEngagementDetail1() (AsinEngagementDetail1, error) {
	var body AsinEngagementDetail1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAsinEngagementDetail1 overwrites any union data inside the AsinEngagementDetail_AdditionalProperties as the provided AsinEngagementDetail1
func (t *AsinEngagementDetail_AdditionalProperties) FromAsinEngagementDetail1(v AsinEngagementDetail1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAsinEngagementDetail1 performs a merge with any union data inside the AsinEngagementDetail_AdditionalProperties, using the provided AsinEngagementDetail1
func (t *AsinEngagementDetail_AdditionalProperties) MergeAsinEngagementDetail1(v AsinEngagementDetail1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAsinEngagementDetail2 returns the union data inside the AsinEngagementDetail_AdditionalProperties as a AsinEngagementDetail2
func (t AsinEngagementDetail_AdditionalProperties) AsAsinEngagementDetail2() (AsinEngagementDetail2, error) {
	var body AsinEngagementDetail2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAsinEngagementDetail2 overwrites any union data inside the AsinEngagementDetail_AdditionalProperties as the provided AsinEngagementDetail2
func (t *AsinEngagementDetail_AdditionalProperties) FromAsinEngagementDetail2(v AsinEngagementDetail2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAsinEngagementDetail2 performs a merge with any union data inside the AsinEngagementDetail_AdditionalProperties, using the provided AsinEngagementDetail2
func (t *AsinEngagementDetail_AdditionalProperties) MergeAsinEngagementDetail2(v AsinEngagementDetail2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AsinEngagementDetail_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AsinEngagementDetail_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInsightMetricsDetail0 returns the union data inside the InsightMetricsDetail_AdditionalProperties as a InsightMetricsDetail0
func (t InsightMetricsDetail_AdditionalProperties) AsInsightMetricsDetail0() (InsightMetricsDetail0, error) {
	var body InsightMetricsDetail0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInsightMetricsDetail0 overwrites any union data inside the InsightMetricsDetail_AdditionalProperties as the provided InsightMetricsDetail0
func (t *InsightMetricsDetail_AdditionalProperties) FromInsightMetricsDetail0(v InsightMetricsDetail0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInsightMetricsDetail0 performs a merge with any union data inside the InsightMetricsDetail_AdditionalProperties, using the provided InsightMetricsDetail0
func (t *InsightMetricsDetail_AdditionalProperties) MergeInsightMetricsDetail0(v InsightMetricsDetail0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsInsightMetricsDetail1 returns the union data inside the InsightMetricsDetail_AdditionalProperties as a InsightMetricsDetail1
func (t InsightMetricsDetail_AdditionalProperties) AsInsightMetricsDetail1() (InsightMetricsDetail1, error) {
	var body InsightMetricsDetail1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInsightMetricsDetail1 overwrites any union data inside the InsightMetricsDetail_AdditionalProperties as the provided InsightMetricsDetail1
func (t *InsightMetricsDetail_AdditionalProperties) FromInsightMetricsDetail1(v InsightMetricsDetail1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInsightMetricsDetail1 performs a merge with any union data inside the InsightMetricsDetail_AdditionalProperties, using the provided InsightMetricsDetail1
func (t *InsightMetricsDetail_AdditionalProperties) MergeInsightMetricsDetail1(v InsightMetricsDetail1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsInsightMetricsDetail2 returns the union data inside the InsightMetricsDetail_AdditionalProperties as a InsightMetricsDetail2
func (t InsightMetricsDetail_AdditionalProperties) AsInsightMetricsDetail2() (InsightMetricsDetail2, error) {
	var body InsightMetricsDetail2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInsightMetricsDetail2 overwrites any union data inside the InsightMetricsDetail_AdditionalProperties as the provided InsightMetricsDetail2
func (t *InsightMetricsDetail_AdditionalProperties) FromInsightMetricsDetail2(v InsightMetricsDetail2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInsightMetricsDetail2 performs a merge with any union data inside the InsightMetricsDetail_AdditionalProperties, using the provided InsightMetricsDetail2
func (t *InsightMetricsDetail_AdditionalProperties) MergeInsightMetricsDetail2(v InsightMetricsDetail2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsInsightMetricsDetail3 returns the union data inside the InsightMetricsDetail_AdditionalProperties as a InsightMetricsDetail3
func (t InsightMetricsDetail_AdditionalProperties) AsInsightMetricsDetail3() (InsightMetricsDetail3, error) {
	var body InsightMetricsDetail3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInsightMetricsDetail3 overwrites any union data inside the InsightMetricsDetail_AdditionalProperties as the provided InsightMetricsDetail3
func (t *InsightMetricsDetail_AdditionalProperties) FromInsightMetricsDetail3(v InsightMetricsDetail3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInsightMetricsDetail3 performs a merge with any union data inside the InsightMetricsDetail_AdditionalProperties, using the provided InsightMetricsDetail3
func (t *InsightMetricsDetail_AdditionalProperties) MergeInsightMetricsDetail3(v InsightMetricsDetail3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsInsightMetricsDetail4 returns the union data inside the InsightMetricsDetail_AdditionalProperties as a InsightMetricsDetail4
func (t InsightMetricsDetail_AdditionalProperties) AsInsightMetricsDetail4() (InsightMetricsDetail4, error) {
	var body InsightMetricsDetail4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInsightMetricsDetail4 overwrites any union data inside the InsightMetricsDetail_AdditionalProperties as the provided InsightMetricsDetail4
func (t *InsightMetricsDetail_AdditionalProperties) FromInsightMetricsDetail4(v InsightMetricsDetail4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInsightMetricsDetail4 performs a merge with any union data inside the InsightMetricsDetail_AdditionalProperties, using the provided InsightMetricsDetail4
func (t *InsightMetricsDetail_AdditionalProperties) MergeInsightMetricsDetail4(v InsightMetricsDetail4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsInsightMetricsDetail5 returns the union data inside the InsightMetricsDetail_AdditionalProperties as a InsightMetricsDetail5
func (t InsightMetricsDetail_AdditionalProperties) AsInsightMetricsDetail5() (InsightMetricsDetail5, error) {
	var body InsightMetricsDetail5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInsightMetricsDetail5 overwrites any union data inside the InsightMetricsDetail_AdditionalProperties as the provided InsightMetricsDetail5
func (t *InsightMetricsDetail_AdditionalProperties) FromInsightMetricsDetail5(v InsightMetricsDetail5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInsightMetricsDetail5 performs a merge with any union data inside the InsightMetricsDetail_AdditionalProperties, using the provided InsightMetricsDetail5
func (t *InsightMetricsDetail_AdditionalProperties) MergeInsightMetricsDetail5(v InsightMetricsDetail5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t InsightMetricsDetail_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *InsightMetricsDetail_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// ResponseEditorFn is the function signature for the ResponseEditor callback function
type ResponseEditorFn func(ctx context.Context, rsp *http.Response) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn

	// A callback for modifying response which are generated after receive from the network.
	ResponseEditors []ResponseEditorFn

	// The user agent header identifies your application, its version number, and the platform and programming language you are using.
	// You must include a user agent header in each request submitted to the sales partner API.
	UserAgent string
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	// setting the default useragent
	if client.UserAgent == "" {
		client.UserAgent = fmt.Sprintf("selling-partner-api-sdk/v2.0 (Language=%s; Platform=%s-%s)", strings.Replace(runt.Version(), "go", "go/", -1), runt.GOOS, runt.GOARCH)
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// WithResponseEditorFn allows setting up a callback function, which will be
// called right after receive the response.
func WithResponseEditorFn(fn ResponseEditorFn) ClientOption {
	return func(c *Client) error {
		c.ResponseEditors = append(c.ResponseEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAsinEngagementForStoreWithBody request with any body
	GetAsinEngagementForStoreWithBody(ctx context.Context, brandEntityId string, contentType string, body io.Reader) (*http.Response, error)

	GetAsinEngagementForStoreWithApplicationVndGetAsinEngagementForStoreRequestV1PlusJSONBody(ctx context.Context, brandEntityId string, body GetAsinEngagementForStoreApplicationVndGetAsinEngagementForStoreRequestV1PlusJSONRequestBody) (*http.Response, error)

	// GetInsightsForStoreAPIWithBody request with any body
	GetInsightsForStoreAPIWithBody(ctx context.Context, brandEntityId string, contentType string, body io.Reader) (*http.Response, error)

	GetInsightsForStoreAPIWithApplicationVndGetInsightsForStoreRequestV1PlusJSONBody(ctx context.Context, brandEntityId string, body GetInsightsForStoreAPIApplicationVndGetInsightsForStoreRequestV1PlusJSONRequestBody) (*http.Response, error)
}

func (c *Client) GetAsinEngagementForStoreWithBody(ctx context.Context, brandEntityId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGetAsinEngagementForStoreRequestWithBody(c.Server, brandEntityId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetAsinEngagementForStoreWithApplicationVndGetAsinEngagementForStoreRequestV1PlusJSONBody(ctx context.Context, brandEntityId string, body GetAsinEngagementForStoreApplicationVndGetAsinEngagementForStoreRequestV1PlusJSONRequestBody) (*http.Response, error) {
	req, err := NewGetAsinEngagementForStoreRequestWithApplicationVndGetAsinEngagementForStoreRequestV1PlusJSONBody(c.Server, brandEntityId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetInsightsForStoreAPIWithBody(ctx context.Context, brandEntityId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGetInsightsForStoreAPIRequestWithBody(c.Server, brandEntityId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

func (c *Client) GetInsightsForStoreAPIWithApplicationVndGetInsightsForStoreRequestV1PlusJSONBody(ctx context.Context, brandEntityId string, body GetInsightsForStoreAPIApplicationVndGetInsightsForStoreRequestV1PlusJSONRequestBody) (*http.Response, error) {
	req, err := NewGetInsightsForStoreAPIRequestWithApplicationVndGetInsightsForStoreRequestV1PlusJSONBody(c.Server, brandEntityId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	req.Header.Set("User-Agent", c.UserAgent)
	if err := c.applyReqEditors(ctx, req); err != nil {
		return nil, err
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}
	if err := c.applyRspEditor(ctx, rsp); err != nil {
		return nil, err
	}
	return rsp, nil
}

// NewGetAsinEngagementForStoreRequestWithApplicationVndGetAsinEngagementForStoreRequestV1PlusJSONBody calls the generic GetAsinEngagementForStore builder with application/vnd.GetAsinEngagementForStoreRequest.v1+json body
func NewGetAsinEngagementForStoreRequestWithApplicationVndGetAsinEngagementForStoreRequestV1PlusJSONBody(server string, brandEntityId string, body GetAsinEngagementForStoreApplicationVndGetAsinEngagementForStoreRequestV1PlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetAsinEngagementForStoreRequestWithBody(server, brandEntityId, "application/vnd.GetAsinEngagementForStoreRequest.v1+json", bodyReader)
}

// NewGetAsinEngagementForStoreRequestWithBody generates requests for GetAsinEngagementForStore with any type of body
func NewGetAsinEngagementForStoreRequestWithBody(server string, brandEntityId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "brandEntityId", runtime.ParamLocationPath, brandEntityId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stores/%s/asinMetrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInsightsForStoreAPIRequestWithApplicationVndGetInsightsForStoreRequestV1PlusJSONBody calls the generic GetInsightsForStoreAPI builder with application/vnd.GetInsightsForStoreRequest.v1+json body
func NewGetInsightsForStoreAPIRequestWithApplicationVndGetInsightsForStoreRequestV1PlusJSONBody(server string, brandEntityId string, body GetInsightsForStoreAPIApplicationVndGetInsightsForStoreRequestV1PlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetInsightsForStoreAPIRequestWithBody(server, brandEntityId, "application/vnd.GetInsightsForStoreRequest.v1+json", bodyReader)
}

// NewGetInsightsForStoreAPIRequestWithBody generates requests for GetInsightsForStoreAPI with any type of body
func NewGetInsightsForStoreAPIRequestWithBody(server string, brandEntityId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "brandEntityId", runtime.ParamLocationPath, brandEntityId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stores/%s/insights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyReqEditors(ctx context.Context, req *http.Request) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) applyRspEditor(ctx context.Context, rsp *http.Response) error {
	for _, r := range c.ResponseEditors {
		if err := r(ctx, rsp); err != nil {
			return err
		}
	}
	return nil
} // ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAsinEngagementForStoreWithBodyWithResponse request with any body
	GetAsinEngagementForStoreWithBodyWithResponse(ctx context.Context, brandEntityId string, contentType string, body io.Reader) (*GetAsinEngagementForStoreResp, error)

	GetAsinEngagementForStoreWithApplicationVndGetAsinEngagementForStoreRequestV1PlusJSONBodyWithResponse(ctx context.Context, brandEntityId string, body GetAsinEngagementForStoreApplicationVndGetAsinEngagementForStoreRequestV1PlusJSONRequestBody) (*GetAsinEngagementForStoreResp, error)

	// GetInsightsForStoreAPIWithBodyWithResponse request with any body
	GetInsightsForStoreAPIWithBodyWithResponse(ctx context.Context, brandEntityId string, contentType string, body io.Reader) (*GetInsightsForStoreAPIResp, error)

	GetInsightsForStoreAPIWithApplicationVndGetInsightsForStoreRequestV1PlusJSONBodyWithResponse(ctx context.Context, brandEntityId string, body GetInsightsForStoreAPIApplicationVndGetInsightsForStoreRequestV1PlusJSONRequestBody) (*GetInsightsForStoreAPIResp, error)
}

type GetAsinEngagementForStoreResp struct {
	Body                                                     []byte
	HTTPResponse                                             *http.Response
	ApplicationvndGetAsinEngagementForStoreResponseV1JSON200 *GetAsinEngagementForStoreResponse
	JSON400                                                  *StoresAnalyticsAPIErrorResponse
	JSON401                                                  *StoresAnalyticsAPIErrorResponse
	JSON403                                                  *StoresAnalyticsAPIErrorResponse
	JSON404                                                  *StoresAnalyticsAPIErrorResponse
	JSON422                                                  *StoresAnalyticsAPIErrorResponse
	JSON429                                                  *StoresAnalyticsAPIErrorResponse
	JSON500                                                  *StoresAnalyticsAPIErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetAsinEngagementForStoreResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAsinEngagementForStoreResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInsightsForStoreAPIResp struct {
	Body                                               []byte
	HTTPResponse                                       *http.Response
	ApplicationvndGetInsightsForStoreResponseV1JSON200 *GetInsightsForStoreResponse
	JSON400                                            *StoresAnalyticsAPIErrorResponse
	JSON401                                            *StoresAnalyticsAPIErrorResponse
	JSON403                                            *StoresAnalyticsAPIErrorResponse
	JSON404                                            *StoresAnalyticsAPIErrorResponse
	JSON422                                            *StoresAnalyticsAPIErrorResponse
	JSON429                                            *StoresAnalyticsAPIErrorResponse
	JSON500                                            *StoresAnalyticsAPIErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetInsightsForStoreAPIResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInsightsForStoreAPIResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAsinEngagementForStoreWithBodyWithResponse request with arbitrary body returning *GetAsinEngagementForStoreResp
func (c *ClientWithResponses) GetAsinEngagementForStoreWithBodyWithResponse(ctx context.Context, brandEntityId string, contentType string, body io.Reader) (*GetAsinEngagementForStoreResp, error) {
	rsp, err := c.GetAsinEngagementForStoreWithBody(ctx, brandEntityId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGetAsinEngagementForStoreResp(rsp)
}

func (c *ClientWithResponses) GetAsinEngagementForStoreWithApplicationVndGetAsinEngagementForStoreRequestV1PlusJSONBodyWithResponse(ctx context.Context, brandEntityId string, body GetAsinEngagementForStoreApplicationVndGetAsinEngagementForStoreRequestV1PlusJSONRequestBody) (*GetAsinEngagementForStoreResp, error) {
	rsp, err := c.GetAsinEngagementForStoreWithApplicationVndGetAsinEngagementForStoreRequestV1PlusJSONBody(ctx, brandEntityId, body)
	if err != nil {
		return nil, err
	}
	return ParseGetAsinEngagementForStoreResp(rsp)
}

// GetInsightsForStoreAPIWithBodyWithResponse request with arbitrary body returning *GetInsightsForStoreAPIResp
func (c *ClientWithResponses) GetInsightsForStoreAPIWithBodyWithResponse(ctx context.Context, brandEntityId string, contentType string, body io.Reader) (*GetInsightsForStoreAPIResp, error) {
	rsp, err := c.GetInsightsForStoreAPIWithBody(ctx, brandEntityId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGetInsightsForStoreAPIResp(rsp)
}

func (c *ClientWithResponses) GetInsightsForStoreAPIWithApplicationVndGetInsightsForStoreRequestV1PlusJSONBodyWithResponse(ctx context.Context, brandEntityId string, body GetInsightsForStoreAPIApplicationVndGetInsightsForStoreRequestV1PlusJSONRequestBody) (*GetInsightsForStoreAPIResp, error) {
	rsp, err := c.GetInsightsForStoreAPIWithApplicationVndGetInsightsForStoreRequestV1PlusJSONBody(ctx, brandEntityId, body)
	if err != nil {
		return nil, err
	}
	return ParseGetInsightsForStoreAPIResp(rsp)
}

// ParseGetAsinEngagementForStoreResp parses an HTTP response from a GetAsinEngagementForStoreWithResponse call
func ParseGetAsinEngagementForStoreResp(rsp *http.Response) (*GetAsinEngagementForStoreResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAsinEngagementForStoreResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAsinEngagementForStoreResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndGetAsinEngagementForStoreResponseV1JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest StoresAnalyticsAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest StoresAnalyticsAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest StoresAnalyticsAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest StoresAnalyticsAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest StoresAnalyticsAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest StoresAnalyticsAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest StoresAnalyticsAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetInsightsForStoreAPIResp parses an HTTP response from a GetInsightsForStoreAPIWithResponse call
func ParseGetInsightsForStoreAPIResp(rsp *http.Response) (*GetInsightsForStoreAPIResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInsightsForStoreAPIResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetInsightsForStoreResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndGetInsightsForStoreResponseV1JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest StoresAnalyticsAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest StoresAnalyticsAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest StoresAnalyticsAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest StoresAnalyticsAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest StoresAnalyticsAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest StoresAnalyticsAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest StoresAnalyticsAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
