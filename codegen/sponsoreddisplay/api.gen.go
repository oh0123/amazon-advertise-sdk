// Package sponsoreddisplay provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.15.0 DO NOT EDIT.
package sponsoreddisplay

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes              = "bearerAuth.Scopes"
	Oauth2AuthorizationCodeScopes = "oauth2AuthorizationCode.Scopes"
)

// Defines values for AdGroupBidOptimization.
const (
	AdGroupBidOptimizationClicks      AdGroupBidOptimization = "clicks"
	AdGroupBidOptimizationConversions AdGroupBidOptimization = "conversions"
	AdGroupBidOptimizationReach       AdGroupBidOptimization = "reach"
)

// Defines values for AdGroupState.
const (
	AdGroupStateArchived AdGroupState = "archived"
	AdGroupStateEnabled  AdGroupState = "enabled"
	AdGroupStatePaused   AdGroupState = "paused"
)

// Defines values for AdGroupResponseExBidOptimization.
const (
	AdGroupResponseExBidOptimizationClicks      AdGroupResponseExBidOptimization = "clicks"
	AdGroupResponseExBidOptimizationConversions AdGroupResponseExBidOptimization = "conversions"
	AdGroupResponseExBidOptimizationReach       AdGroupResponseExBidOptimization = "reach"
)

// Defines values for AdGroupResponseExServingStatus.
const (
	AdGroupResponseExServingStatusACCOUNTOUTOFBUDGET              AdGroupResponseExServingStatus = "ACCOUNT_OUT_OF_BUDGET"
	AdGroupResponseExServingStatusADGROUPARCHIVED                 AdGroupResponseExServingStatus = "AD_GROUP_ARCHIVED"
	AdGroupResponseExServingStatusADGROUPINCOMPLETE               AdGroupResponseExServingStatus = "AD_GROUP_INCOMPLETE"
	AdGroupResponseExServingStatusADGROUPLOWBID                   AdGroupResponseExServingStatus = "AD_GROUP_LOW_BID"
	AdGroupResponseExServingStatusADGROUPPAUSED                   AdGroupResponseExServingStatus = "AD_GROUP_PAUSED"
	AdGroupResponseExServingStatusADGROUPPOLICINGCREATIVEREJECTED AdGroupResponseExServingStatus = "ADGROUP_POLICING_CREATIVE_REJECTED"
	AdGroupResponseExServingStatusADGROUPPOLICINGPENDINGREVIEW    AdGroupResponseExServingStatus = "ADGROUP_POLICING_PENDING_REVIEW"
	AdGroupResponseExServingStatusADGROUPSTATUSENABLED            AdGroupResponseExServingStatus = "AD_GROUP_STATUS_ENABLED"
	AdGroupResponseExServingStatusADPOLICINGPENDINGREVIEW         AdGroupResponseExServingStatus = "AD_POLICING_PENDING_REVIEW"
	AdGroupResponseExServingStatusADVERTISEREXCEEDSPENDSLIMIT     AdGroupResponseExServingStatus = "ADVERTISER_EXCEED_SPENDS_LIMIT"
	AdGroupResponseExServingStatusADVERTISERPAUSED                AdGroupResponseExServingStatus = "ADVERTISER_PAUSED"
	AdGroupResponseExServingStatusADVERTISERPAYMENTFAILURE        AdGroupResponseExServingStatus = "ADVERTISER_PAYMENT_FAILURE"
	AdGroupResponseExServingStatusADVERTISERSTATUSENABLED         AdGroupResponseExServingStatus = "ADVERTISER_STATUS_ENABLED"
	AdGroupResponseExServingStatusCAMPAIGNARCHIVED                AdGroupResponseExServingStatus = "CAMPAIGN_ARCHIVED"
	AdGroupResponseExServingStatusCAMPAIGNINCOMPLETE              AdGroupResponseExServingStatus = "CAMPAIGN_INCOMPLETE"
	AdGroupResponseExServingStatusCAMPAIGNOUTOFBUDGET             AdGroupResponseExServingStatus = "CAMPAIGN_OUT_OF_BUDGET"
	AdGroupResponseExServingStatusCAMPAIGNPAUSED                  AdGroupResponseExServingStatus = "CAMPAIGN_PAUSED"
	AdGroupResponseExServingStatusENDED                           AdGroupResponseExServingStatus = "ENDED"
	AdGroupResponseExServingStatusINELIGIBLE                      AdGroupResponseExServingStatus = "INELIGIBLE"
	AdGroupResponseExServingStatusPENDINGSTARTDATE                AdGroupResponseExServingStatus = "PENDING_START_DATE"
	AdGroupResponseExServingStatusPORTFOLIOENDED                  AdGroupResponseExServingStatus = "PORTFOLIO_ENDED"
	AdGroupResponseExServingStatusPORTFOLIOOUTOFBUDGET            AdGroupResponseExServingStatus = "PORTFOLIO_OUT_OF_BUDGET"
	AdGroupResponseExServingStatusSTATUSUNAVAILABLE               AdGroupResponseExServingStatus = "STATUS_UNAVAILABLE"
)

// Defines values for AdGroupResponseExState.
const (
	AdGroupResponseExStateArchived AdGroupResponseExState = "archived"
	AdGroupResponseExStateEnabled  AdGroupResponseExState = "enabled"
	AdGroupResponseExStatePaused   AdGroupResponseExState = "paused"
)

// Defines values for BaseAdGroupBidOptimization.
const (
	BaseAdGroupBidOptimizationClicks      BaseAdGroupBidOptimization = "clicks"
	BaseAdGroupBidOptimizationConversions BaseAdGroupBidOptimization = "conversions"
	BaseAdGroupBidOptimizationReach       BaseAdGroupBidOptimization = "reach"
)

// Defines values for BaseAdGroupState.
const (
	BaseAdGroupStateArchived BaseAdGroupState = "archived"
	BaseAdGroupStateEnabled  BaseAdGroupState = "enabled"
	BaseAdGroupStatePaused   BaseAdGroupState = "paused"
)

// Defines values for BaseCampaignBudgetType.
const (
	BaseCampaignBudgetTypeDaily BaseCampaignBudgetType = "daily"
)

// Defines values for BaseCampaignCostType.
const (
	BaseCampaignCostTypeCpc  BaseCampaignCostType = "cpc"
	BaseCampaignCostTypeVcpm BaseCampaignCostType = "vcpm"
)

// Defines values for BaseCampaignState.
const (
	BaseCampaignStateArchived BaseCampaignState = "archived"
	BaseCampaignStateEnabled  BaseCampaignState = "enabled"
	BaseCampaignStatePaused   BaseCampaignState = "paused"
)

// Defines values for BaseLocationState.
const (
	BaseLocationStateEnabled BaseLocationState = "enabled"
)

// Defines values for BaseNegativeTargetingClauseState.
const (
	BaseNegativeTargetingClauseStateArchived BaseNegativeTargetingClauseState = "archived"
	BaseNegativeTargetingClauseStateEnabled  BaseNegativeTargetingClauseState = "enabled"
	BaseNegativeTargetingClauseStatePaused   BaseNegativeTargetingClauseState = "paused"
)

// Defines values for BaseOptimizationRuleState.
const (
	BaseOptimizationRuleStateEnabled           BaseOptimizationRuleState = "enabled"
	BaseOptimizationRuleStatePausedCOMINGLATER BaseOptimizationRuleState = "paused [COMING LATER]"
)

// Defines values for BaseProductAdState.
const (
	BaseProductAdStateArchived BaseProductAdState = "archived"
	BaseProductAdStateEnabled  BaseProductAdState = "enabled"
	BaseProductAdStatePaused   BaseProductAdState = "paused"
)

// Defines values for BaseTargetingClauseState.
const (
	BaseTargetingClauseStateArchived BaseTargetingClauseState = "archived"
	BaseTargetingClauseStateEnabled  BaseTargetingClauseState = "enabled"
	BaseTargetingClauseStatePaused   BaseTargetingClauseState = "paused"
)

// Defines values for BrandSafetyDenyListDomainState.
const (
	ARCHIVED BrandSafetyDenyListDomainState = "ARCHIVED"
	ENABLED  BrandSafetyDenyListDomainState = "ENABLED"
)

// Defines values for BrandSafetyDenyListDomainType.
const (
	APP     BrandSafetyDenyListDomainType = "APP"
	WEBSITE BrandSafetyDenyListDomainType = "WEBSITE"
)

// Defines values for BrandSafetyDenyListDomainUpdateResultStatus.
const (
	BrandSafetyDenyListDomainUpdateResultStatusFAILURE BrandSafetyDenyListDomainUpdateResultStatus = "FAILURE"
	BrandSafetyDenyListDomainUpdateResultStatusSUCCESS BrandSafetyDenyListDomainUpdateResultStatus = "SUCCESS"
)

// Defines values for BrandSafetyRequestStatusStatus.
const (
	BrandSafetyRequestStatusStatusCOMPLETED  BrandSafetyRequestStatusStatus = "COMPLETED"
	BrandSafetyRequestStatusStatusFAILURE    BrandSafetyRequestStatusStatus = "FAILURE"
	BrandSafetyRequestStatusStatusINPROGRESS BrandSafetyRequestStatusStatus = "IN_PROGRESS"
)

// Defines values for BudgetChangeType.
const (
	PERCENT BudgetChangeType = "PERCENT"
)

// Defines values for CampaignBudgetType.
const (
	CampaignBudgetTypeDaily CampaignBudgetType = "daily"
)

// Defines values for CampaignCostType.
const (
	CampaignCostTypeCpc  CampaignCostType = "cpc"
	CampaignCostTypeVcpm CampaignCostType = "vcpm"
)

// Defines values for CampaignDeliveryProfile.
const (
	AsSoonAsPossible CampaignDeliveryProfile = "as_soon_as_possible"
)

// Defines values for CampaignState.
const (
	CampaignStateArchived CampaignState = "archived"
	CampaignStateEnabled  CampaignState = "enabled"
	CampaignStatePaused   CampaignState = "paused"
)

// Defines values for CampaignResponseExBudgetType.
const (
	CampaignResponseExBudgetTypeDaily CampaignResponseExBudgetType = "daily"
)

// Defines values for CampaignResponseExCostType.
const (
	CampaignResponseExCostTypeCpc  CampaignResponseExCostType = "cpc"
	CampaignResponseExCostTypeVcpm CampaignResponseExCostType = "vcpm"
)

// Defines values for CampaignResponseExServingStatus.
const (
	CampaignResponseExServingStatusACCOUNTOUTOFBUDGET          CampaignResponseExServingStatus = "ACCOUNT_OUT_OF_BUDGET"
	CampaignResponseExServingStatusADPOLICINGPENDINGREVIEW     CampaignResponseExServingStatus = "AD_POLICING_PENDING_REVIEW"
	CampaignResponseExServingStatusADVERTISEREXCEEDSPENDSLIMIT CampaignResponseExServingStatus = "ADVERTISER_EXCEED_SPENDS_LIMIT"
	CampaignResponseExServingStatusADVERTISERPAUSED            CampaignResponseExServingStatus = "ADVERTISER_PAUSED"
	CampaignResponseExServingStatusADVERTISERPAYMENTFAILURE    CampaignResponseExServingStatus = "ADVERTISER_PAYMENT_FAILURE"
	CampaignResponseExServingStatusADVERTISERSTATUSENABLED     CampaignResponseExServingStatus = "ADVERTISER_STATUS_ENABLED"
	CampaignResponseExServingStatusCAMPAIGNARCHIVED            CampaignResponseExServingStatus = "CAMPAIGN_ARCHIVED"
	CampaignResponseExServingStatusCAMPAIGNINCOMPLETE          CampaignResponseExServingStatus = "CAMPAIGN_INCOMPLETE"
	CampaignResponseExServingStatusCAMPAIGNOUTOFBUDGET         CampaignResponseExServingStatus = "CAMPAIGN_OUT_OF_BUDGET"
	CampaignResponseExServingStatusCAMPAIGNPAUSED              CampaignResponseExServingStatus = "CAMPAIGN_PAUSED"
	CampaignResponseExServingStatusENDED                       CampaignResponseExServingStatus = "ENDED"
	CampaignResponseExServingStatusINELIGIBLE                  CampaignResponseExServingStatus = "INELIGIBLE"
	CampaignResponseExServingStatusPENDINGSTARTDATE            CampaignResponseExServingStatus = "PENDING_START_DATE"
	CampaignResponseExServingStatusPORTFOLIOENDED              CampaignResponseExServingStatus = "PORTFOLIO_ENDED"
	CampaignResponseExServingStatusPORTFOLIOOUTOFBUDGET        CampaignResponseExServingStatus = "PORTFOLIO_OUT_OF_BUDGET"
	CampaignResponseExServingStatusSTATUSUNAVAILABLE           CampaignResponseExServingStatus = "STATUS_UNAVAILABLE"
)

// Defines values for CampaignResponseExState.
const (
	CampaignResponseExStateArchived CampaignResponseExState = "archived"
	CampaignResponseExStateEnabled  CampaignResponseExState = "enabled"
	CampaignResponseExStatePaused   CampaignResponseExState = "paused"
)

// Defines values for ComparisonOperator.
const (
	ComparisonOperatorGREATERTHAN          ComparisonOperator = "GREATER_THAN"
	ComparisonOperatorGREATERTHANOREQUALTO ComparisonOperator = "GREATER_THAN_OR_EQUAL_TO"
	ComparisonOperatorLESSTHAN             ComparisonOperator = "LESS_THAN"
	ComparisonOperatorLESSTHANOREQUALTO    ComparisonOperator = "LESS_THAN_OR_EQUAL_TO"
)

// Defines values for CreateAdGroupBidOptimization.
const (
	CreateAdGroupBidOptimizationClicks      CreateAdGroupBidOptimization = "clicks"
	CreateAdGroupBidOptimizationConversions CreateAdGroupBidOptimization = "conversions"
	CreateAdGroupBidOptimizationReach       CreateAdGroupBidOptimization = "reach"
)

// Defines values for CreateAdGroupState.
const (
	CreateAdGroupStateArchived CreateAdGroupState = "archived"
	CreateAdGroupStateEnabled  CreateAdGroupState = "enabled"
	CreateAdGroupStatePaused   CreateAdGroupState = "paused"
)

// Defines values for CreateCampaignBudgetType.
const (
	CreateCampaignBudgetTypeDaily CreateCampaignBudgetType = "daily"
)

// Defines values for CreateCampaignCostType.
const (
	CreateCampaignCostTypeCpc  CreateCampaignCostType = "cpc"
	CreateCampaignCostTypeVcpm CreateCampaignCostType = "vcpm"
)

// Defines values for CreateCampaignState.
const (
	CreateCampaignStateArchived CreateCampaignState = "archived"
	CreateCampaignStateEnabled  CreateCampaignState = "enabled"
	CreateCampaignStatePaused   CreateCampaignState = "paused"
)

// Defines values for CreateLocationState.
const (
	CreateLocationStateEnabled CreateLocationState = "enabled"
)

// Defines values for CreateNegativeTargetingClauseExpressionType.
const (
	CreateNegativeTargetingClauseExpressionTypeAuto   CreateNegativeTargetingClauseExpressionType = "auto"
	CreateNegativeTargetingClauseExpressionTypeManual CreateNegativeTargetingClauseExpressionType = "manual"
)

// Defines values for CreateNegativeTargetingClauseState.
const (
	CreateNegativeTargetingClauseStateArchived CreateNegativeTargetingClauseState = "archived"
	CreateNegativeTargetingClauseStateEnabled  CreateNegativeTargetingClauseState = "enabled"
	CreateNegativeTargetingClauseStatePaused   CreateNegativeTargetingClauseState = "paused"
)

// Defines values for CreateProductAdState.
const (
	CreateProductAdStateArchived CreateProductAdState = "archived"
	CreateProductAdStateEnabled  CreateProductAdState = "enabled"
	CreateProductAdStatePaused   CreateProductAdState = "paused"
)

// Defines values for CreateTargetingClauseExpressionType.
const (
	CreateTargetingClauseExpressionTypeAuto   CreateTargetingClauseExpressionType = "auto"
	CreateTargetingClauseExpressionTypeManual CreateTargetingClauseExpressionType = "manual"
)

// Defines values for CreateTargetingClauseState.
const (
	CreateTargetingClauseStateArchived CreateTargetingClauseState = "archived"
	CreateTargetingClauseStateEnabled  CreateTargetingClauseState = "enabled"
	CreateTargetingClauseStatePaused   CreateTargetingClauseState = "paused"
)

// Defines values for CreativeModerationStatus.
const (
	CreativeModerationStatusAPPROVED      CreativeModerationStatus = "APPROVED"
	CreativeModerationStatusPENDINGREVIEW CreativeModerationStatus = "PENDING_REVIEW"
	CreativeModerationStatusREJECTED      CreativeModerationStatus = "REJECTED"
)

// Defines values for CreativeModerationModerationStatus.
const (
	CreativeModerationModerationStatusAPPROVED      CreativeModerationModerationStatus = "APPROVED"
	CreativeModerationModerationStatusPENDINGREVIEW CreativeModerationModerationStatus = "PENDING_REVIEW"
	CreativeModerationModerationStatusREJECTED      CreativeModerationModerationStatus = "REJECTED"
)

// Defines values for CreativeType.
const (
	CreativeTypeIMAGE CreativeType = "IMAGE"
	CreativeTypeVIDEO CreativeType = "VIDEO"
)

// Defines values for CreativeTypeInCreativeRequest.
const (
	CreativeTypeInCreativeRequestIMAGE CreativeTypeInCreativeRequest = "IMAGE"
	CreativeTypeInCreativeRequestVIDEO CreativeTypeInCreativeRequest = "VIDEO"
)

// Defines values for CreativeTypeInCreativeResponse.
const (
	IMAGE CreativeTypeInCreativeResponse = "IMAGE"
	VIDEO CreativeTypeInCreativeResponse = "VIDEO"
)

// Defines values for DayOfWeek.
const (
	FRIDAY    DayOfWeek = "FRIDAY"
	MONDAY    DayOfWeek = "MONDAY"
	SATURDAY  DayOfWeek = "SATURDAY"
	SUNDAY    DayOfWeek = "SUNDAY"
	THURSDAY  DayOfWeek = "THURSDAY"
	TUESDAY   DayOfWeek = "TUESDAY"
	WEDNESDAY DayOfWeek = "WEDNESDAY"
)

// Defines values for ForecastMetric.
const (
	CLICKS      ForecastMetric = "CLICKS"
	CONVERSIONS ForecastMetric = "CONVERSIONS"
	IMPRESSIONS ForecastMetric = "IMPRESSIONS"
	REACH       ForecastMetric = "REACH"
)

// Defines values for LandingPageType.
const (
	MOMENT        LandingPageType = "MOMENT"
	OFFAMAZONLINK LandingPageType = "OFF_AMAZON_LINK"
	STORE         LandingPageType = "STORE"
)

// Defines values for Locale.
const (
	LocaleArAE Locale = "ar-AE"
	LocaleDeDE Locale = "de-DE"
	LocaleEnAE Locale = "en-AE"
	LocaleEnCA Locale = "en-CA"
	LocaleEnDE Locale = "en-DE"
	LocaleEnES Locale = "en-ES"
	LocaleEnFR Locale = "en-FR"
	LocaleEnGB Locale = "en-GB"
	LocaleEnIN Locale = "en-IN"
	LocaleEnIT Locale = "en-IT"
	LocaleEnJP Locale = "en-JP"
	LocaleEnUS Locale = "en-US"
	LocaleEsES Locale = "es-ES"
	LocaleEsMX Locale = "es-MX"
	LocaleFrCA Locale = "fr-CA"
	LocaleFrFR Locale = "fr-FR"
	LocaleHiIN Locale = "hi-IN"
	LocaleItIT Locale = "it-IT"
	LocaleJaJP Locale = "ja-JP"
	LocaleKoKR Locale = "ko-KR"
	LocaleZhCN Locale = "zh-CN"
)

// Defines values for LocationState.
const (
	LocationStateEnabled LocationState = "enabled"
)

// Defines values for LocationPredicate.
const (
	LocationPredicateLocation LocationPredicate = "location"
)

// Defines values for NegativeTargetingClauseExpressionType.
const (
	NegativeTargetingClauseExpressionTypeAuto   NegativeTargetingClauseExpressionType = "auto"
	NegativeTargetingClauseExpressionTypeManual NegativeTargetingClauseExpressionType = "manual"
)

// Defines values for NegativeTargetingClauseState.
const (
	NegativeTargetingClauseStateArchived NegativeTargetingClauseState = "archived"
	NegativeTargetingClauseStateEnabled  NegativeTargetingClauseState = "enabled"
	NegativeTargetingClauseStatePaused   NegativeTargetingClauseState = "paused"
)

// Defines values for NegativeTargetingClauseExExpressionType.
const (
	NegativeTargetingClauseExExpressionTypeAsinBrandSameAs NegativeTargetingClauseExExpressionType = "asinBrandSameAs"
	NegativeTargetingClauseExExpressionTypeAsinSameAs      NegativeTargetingClauseExExpressionType = "asinSameAs"
)

// Defines values for NegativeTargetingClauseExRenameExpressionType.
const (
	NegativeTargetingClauseExRenameExpressionTypeAuto   NegativeTargetingClauseExRenameExpressionType = "auto"
	NegativeTargetingClauseExRenameExpressionTypeManual NegativeTargetingClauseExRenameExpressionType = "manual"
)

// Defines values for NegativeTargetingClauseExServingStatus.
const (
	NegativeTargetingClauseExServingStatusACCOUNTOUTOFBUDGET          NegativeTargetingClauseExServingStatus = "ACCOUNT_OUT_OF_BUDGET"
	NegativeTargetingClauseExServingStatusADGROUPARCHIVED             NegativeTargetingClauseExServingStatus = "AD_GROUP_ARCHIVED"
	NegativeTargetingClauseExServingStatusADGROUPINCOMPLETE           NegativeTargetingClauseExServingStatus = "AD_GROUP_INCOMPLETE"
	NegativeTargetingClauseExServingStatusADGROUPLOWBID               NegativeTargetingClauseExServingStatus = "AD_GROUP_LOW_BID"
	NegativeTargetingClauseExServingStatusADGROUPPAUSED               NegativeTargetingClauseExServingStatus = "AD_GROUP_PAUSED"
	NegativeTargetingClauseExServingStatusADGROUPSTATUSENABLED        NegativeTargetingClauseExServingStatus = "AD_GROUP_STATUS_ENABLED"
	NegativeTargetingClauseExServingStatusADPOLICINGPENDINGREVIEW     NegativeTargetingClauseExServingStatus = "AD_POLICING_PENDING_REVIEW"
	NegativeTargetingClauseExServingStatusADVERTISEREXCEEDSPENDSLIMIT NegativeTargetingClauseExServingStatus = "ADVERTISER_EXCEED_SPENDS_LIMIT"
	NegativeTargetingClauseExServingStatusADVERTISERPAUSED            NegativeTargetingClauseExServingStatus = "ADVERTISER_PAUSED"
	NegativeTargetingClauseExServingStatusADVERTISERPAYMENTFAILURE    NegativeTargetingClauseExServingStatus = "ADVERTISER_PAYMENT_FAILURE"
	NegativeTargetingClauseExServingStatusADVERTISERSTATUSENABLED     NegativeTargetingClauseExServingStatus = "ADVERTISER_STATUS_ENABLED"
	NegativeTargetingClauseExServingStatusCAMPAIGNARCHIVED            NegativeTargetingClauseExServingStatus = "CAMPAIGN_ARCHIVED"
	NegativeTargetingClauseExServingStatusCAMPAIGNINCOMPLETE          NegativeTargetingClauseExServingStatus = "CAMPAIGN_INCOMPLETE"
	NegativeTargetingClauseExServingStatusCAMPAIGNOUTOFBUDGET         NegativeTargetingClauseExServingStatus = "CAMPAIGN_OUT_OF_BUDGET"
	NegativeTargetingClauseExServingStatusCAMPAIGNPAUSED              NegativeTargetingClauseExServingStatus = "CAMPAIGN_PAUSED"
	NegativeTargetingClauseExServingStatusENDED                       NegativeTargetingClauseExServingStatus = "ENDED"
	NegativeTargetingClauseExServingStatusINELIGIBLE                  NegativeTargetingClauseExServingStatus = "INELIGIBLE"
	NegativeTargetingClauseExServingStatusPENDINGSTARTDATE            NegativeTargetingClauseExServingStatus = "PENDING_START_DATE"
	NegativeTargetingClauseExServingStatusPORTFOLIOENDED              NegativeTargetingClauseExServingStatus = "PORTFOLIO_ENDED"
	NegativeTargetingClauseExServingStatusPORTFOLIOOUTOFBUDGET        NegativeTargetingClauseExServingStatus = "PORTFOLIO_OUT_OF_BUDGET"
	NegativeTargetingClauseExServingStatusSTATUSUNAVAILABLE           NegativeTargetingClauseExServingStatus = "STATUS_UNAVAILABLE"
	NegativeTargetingClauseExServingStatusTARGETSTATUSARCHIVED        NegativeTargetingClauseExServingStatus = "TARGET_STATUS_ARCHIVED"
	NegativeTargetingClauseExServingStatusTARGETSTATUSLIVE            NegativeTargetingClauseExServingStatus = "TARGET_STATUS_LIVE"
	NegativeTargetingClauseExServingStatusTARGETSTATUSPAUSED          NegativeTargetingClauseExServingStatus = "TARGET_STATUS_PAUSED"
)

// Defines values for NegativeTargetingClauseExState.
const (
	NegativeTargetingClauseExStateArchived NegativeTargetingClauseExState = "archived"
	NegativeTargetingClauseExStateEnabled  NegativeTargetingClauseExState = "enabled"
	NegativeTargetingClauseExStatePaused   NegativeTargetingClauseExState = "paused"
)

// Defines values for NegativeTargetingExpressionType.
const (
	NegativeTargetingExpressionTypeAsinBrandSameAs NegativeTargetingExpressionType = "asinBrandSameAs"
	NegativeTargetingExpressionTypeAsinSameAs      NegativeTargetingExpressionType = "asinSameAs"
)

// Defines values for OptimizationRuleState.
const (
	OptimizationRuleStateEnabled           OptimizationRuleState = "enabled"
	OptimizationRuleStatePausedCOMINGLATER OptimizationRuleState = "paused [COMING LATER]"
)

// Defines values for PerformanceMetric.
const (
	ACOS PerformanceMetric = "ACOS"
	CTR  PerformanceMetric = "CTR"
	CVR  PerformanceMetric = "CVR"
	ROAS PerformanceMetric = "ROAS"
)

// Defines values for ProductAdState.
const (
	ProductAdStateArchived ProductAdState = "archived"
	ProductAdStateEnabled  ProductAdState = "enabled"
	ProductAdStatePaused   ProductAdState = "paused"
)

// Defines values for ProductAdResponseExServingStatus.
const (
	ProductAdResponseExServingStatusACCOUNTOUTOFBUDGET          ProductAdResponseExServingStatus = "ACCOUNT_OUT_OF_BUDGET"
	ProductAdResponseExServingStatusADGROUPARCHIVED             ProductAdResponseExServingStatus = "AD_GROUP_ARCHIVED"
	ProductAdResponseExServingStatusADGROUPINCOMPLETE           ProductAdResponseExServingStatus = "AD_GROUP_INCOMPLETE"
	ProductAdResponseExServingStatusADGROUPLOWBID               ProductAdResponseExServingStatus = "AD_GROUP_LOW_BID"
	ProductAdResponseExServingStatusADGROUPPAUSED               ProductAdResponseExServingStatus = "AD_GROUP_PAUSED"
	ProductAdResponseExServingStatusADGROUPSTATUSENABLED        ProductAdResponseExServingStatus = "AD_GROUP_STATUS_ENABLED"
	ProductAdResponseExServingStatusADPOLICINGPENDINGREVIEW     ProductAdResponseExServingStatus = "AD_POLICING_PENDING_REVIEW"
	ProductAdResponseExServingStatusADSTATUSARCHIVED            ProductAdResponseExServingStatus = "AD_STATUS_ARCHIVED"
	ProductAdResponseExServingStatusADSTATUSLIVE                ProductAdResponseExServingStatus = "AD_STATUS_LIVE"
	ProductAdResponseExServingStatusADSTATUSPAUSED              ProductAdResponseExServingStatus = "AD_STATUS_PAUSED"
	ProductAdResponseExServingStatusADVERTISEREXCEEDSPENDSLIMIT ProductAdResponseExServingStatus = "ADVERTISER_EXCEED_SPENDS_LIMIT"
	ProductAdResponseExServingStatusADVERTISERPAUSED            ProductAdResponseExServingStatus = "ADVERTISER_PAUSED"
	ProductAdResponseExServingStatusADVERTISERPAYMENTFAILURE    ProductAdResponseExServingStatus = "ADVERTISER_PAYMENT_FAILURE"
	ProductAdResponseExServingStatusADVERTISERSTATUSENABLED     ProductAdResponseExServingStatus = "ADVERTISER_STATUS_ENABLED"
	ProductAdResponseExServingStatusCAMPAIGNARCHIVED            ProductAdResponseExServingStatus = "CAMPAIGN_ARCHIVED"
	ProductAdResponseExServingStatusCAMPAIGNINCOMPLETE          ProductAdResponseExServingStatus = "CAMPAIGN_INCOMPLETE"
	ProductAdResponseExServingStatusCAMPAIGNOUTOFBUDGET         ProductAdResponseExServingStatus = "CAMPAIGN_OUT_OF_BUDGET"
	ProductAdResponseExServingStatusCAMPAIGNPAUSED              ProductAdResponseExServingStatus = "CAMPAIGN_PAUSED"
	ProductAdResponseExServingStatusENDED                       ProductAdResponseExServingStatus = "ENDED"
	ProductAdResponseExServingStatusINELIGIBLE                  ProductAdResponseExServingStatus = "INELIGIBLE"
	ProductAdResponseExServingStatusMISSINGDECORATION           ProductAdResponseExServingStatus = "MISSING_DECORATION"
	ProductAdResponseExServingStatusMISSINGIMAGE                ProductAdResponseExServingStatus = "MISSING_IMAGE"
	ProductAdResponseExServingStatusNOTBUYABLE                  ProductAdResponseExServingStatus = "NOT_BUYABLE"
	ProductAdResponseExServingStatusNOTINBUYBOX                 ProductAdResponseExServingStatus = "NOT_IN_BUYBOX"
	ProductAdResponseExServingStatusNOTINPOLICY                 ProductAdResponseExServingStatus = "NOT_IN_POLICY"
	ProductAdResponseExServingStatusOUTOFSTOCK                  ProductAdResponseExServingStatus = "OUT_OF_STOCK"
	ProductAdResponseExServingStatusPENDINGSTARTDATE            ProductAdResponseExServingStatus = "PENDING_START_DATE"
	ProductAdResponseExServingStatusPORTFOLIOENDED              ProductAdResponseExServingStatus = "PORTFOLIO_ENDED"
	ProductAdResponseExServingStatusPORTFOLIOOUTOFBUDGET        ProductAdResponseExServingStatus = "PORTFOLIO_OUT_OF_BUDGET"
	ProductAdResponseExServingStatusSTATUSUNAVAILABLE           ProductAdResponseExServingStatus = "STATUS_UNAVAILABLE"
)

// Defines values for ProductAdResponseExState.
const (
	ProductAdResponseExStateArchived ProductAdResponseExState = "archived"
	ProductAdResponseExStateEnabled  ProductAdResponseExState = "enabled"
	ProductAdResponseExStatePaused   ProductAdResponseExState = "paused"
)

// Defines values for RecurrenceType.
const (
	DAILY  RecurrenceType = "DAILY"
	WEEKLY RecurrenceType = "WEEKLY"
)

// Defines values for ReportResponseRecordType.
const (
	ADGROUP   ReportResponseRecordType = "AD_GROUP"
	CAMPAIGN  ReportResponseRecordType = "CAMPAIGN"
	PRODUCTAD ReportResponseRecordType = "PRODUCT_AD"
)

// Defines values for ReportResponseStatus.
const (
	ReportResponseStatusFAILURE    ReportResponseStatus = "FAILURE"
	ReportResponseStatusINPROGRESS ReportResponseStatus = "IN_PROGRESS"
	ReportResponseStatusSUCCESS    ReportResponseStatus = "SUCCESS"
)

// Defines values for RuleConditionComparisonOperator.
const (
	RuleConditionComparisonOperatorLESSTHANOREQUALTO RuleConditionComparisonOperator = "LESS_THAN_OR_EQUAL_TO"
)

// Defines values for RuleConditionMetricName.
const (
	COSTPERCLICK                       RuleConditionMetricName = "COST_PER_CLICK"
	COSTPERORDER                       RuleConditionMetricName = "COST_PER_ORDER"
	COSTPERTHOUSANDVIEWABLEIMPRESSIONS RuleConditionMetricName = "COST_PER_THOUSAND_VIEWABLE_IMPRESSIONS"
)

// Defines values for SDAudienceCategory.
const (
	InMarket  SDAudienceCategory = "In-market"
	Interest  SDAudienceCategory = "Interest"
	LifeEvent SDAudienceCategory = "Life event"
	Lifestyle SDAudienceCategory = "Lifestyle"
)

// Defines values for SDBidOptimizationV32.
const (
	SDBidOptimizationV32Clicks      SDBidOptimizationV32 = "clicks"
	SDBidOptimizationV32Conversions SDBidOptimizationV32 = "conversions"
	SDBidOptimizationV32Reach       SDBidOptimizationV32 = "reach"
)

// Defines values for SDCostTypeV31.
const (
	SDCostTypeV31Cpc  SDCostTypeV31 = "cpc"
	SDCostTypeV31Vcpm SDCostTypeV31 = "vcpm"
)

// Defines values for SDProductTargetingThemeExpressionType.
const (
	SDProductTargetingThemeExpressionTypeAsinBrandSameAs            SDProductTargetingThemeExpressionType = "asinBrandSameAs"
	SDProductTargetingThemeExpressionTypeAsinGlanceViewsGreaterThan SDProductTargetingThemeExpressionType = "asinGlanceViewsGreaterThan"
	SDProductTargetingThemeExpressionTypeAsinPriceGreaterThan       SDProductTargetingThemeExpressionType = "asinPriceGreaterThan"
	SDProductTargetingThemeExpressionTypeAsinReviewRatingLessThan   SDProductTargetingThemeExpressionType = "asinReviewRatingLessThan"
)

// Defines values for SDRecommendationType.
const (
	SDRecommendationTypePRODUCT SDRecommendationType = "PRODUCT"
)

// Defines values for SDRecommendationTypeV31.
const (
	SDRecommendationTypeV31CATEGORY SDRecommendationTypeV31 = "CATEGORY"
	SDRecommendationTypeV31PRODUCT  SDRecommendationTypeV31 = "PRODUCT"
)

// Defines values for SDRecommendationTypeV32.
const (
	AUDIENCE SDRecommendationTypeV32 = "AUDIENCE"
	CATEGORY SDRecommendationTypeV32 = "CATEGORY"
	PRODUCT  SDRecommendationTypeV32 = "PRODUCT"
)

// Defines values for SDRuleType.
const (
	PERFORMANCE SDRuleType = "PERFORMANCE"
	SCHEDULE    SDRuleType = "SCHEDULE"
)

// Defines values for SDTactic.
const (
	SDTacticT00020 SDTactic = "T00020"
)

// Defines values for SDTacticV31.
const (
	SDTacticV31T00020 SDTacticV31 = "T00020"
	SDTacticV31T00030 SDTacticV31 = "T00030"
)

// Defines values for SDTargetingClauseV31ExpressionType.
const (
	SDTargetingClauseV31ExpressionTypeAuto   SDTargetingClauseV31ExpressionType = "auto"
	SDTargetingClauseV31ExpressionTypeManual SDTargetingClauseV31ExpressionType = "manual"
)

// Defines values for SDTargetingPredicateBaseV31Type.
const (
	SDTargetingPredicateBaseV31TypeAsinAgeRangeSameAs          SDTargetingPredicateBaseV31Type = "asinAgeRangeSameAs"
	SDTargetingPredicateBaseV31TypeAsinBrandSameAs             SDTargetingPredicateBaseV31Type = "asinBrandSameAs"
	SDTargetingPredicateBaseV31TypeAsinCategorySameAs          SDTargetingPredicateBaseV31Type = "asinCategorySameAs"
	SDTargetingPredicateBaseV31TypeAsinGenreSameAs             SDTargetingPredicateBaseV31Type = "asinGenreSameAs"
	SDTargetingPredicateBaseV31TypeAsinIsPrimeShippingEligible SDTargetingPredicateBaseV31Type = "asinIsPrimeShippingEligible"
	SDTargetingPredicateBaseV31TypeAsinPriceBetween            SDTargetingPredicateBaseV31Type = "asinPriceBetween"
	SDTargetingPredicateBaseV31TypeAsinPriceGreaterThan        SDTargetingPredicateBaseV31Type = "asinPriceGreaterThan"
	SDTargetingPredicateBaseV31TypeAsinPriceLessThan           SDTargetingPredicateBaseV31Type = "asinPriceLessThan"
	SDTargetingPredicateBaseV31TypeAsinReviewRatingBetween     SDTargetingPredicateBaseV31Type = "asinReviewRatingBetween"
	SDTargetingPredicateBaseV31TypeAsinReviewRatingGreaterThan SDTargetingPredicateBaseV31Type = "asinReviewRatingGreaterThan"
	SDTargetingPredicateBaseV31TypeAsinReviewRatingLessThan    SDTargetingPredicateBaseV31Type = "asinReviewRatingLessThan"
	SDTargetingPredicateBaseV31TypeAudienceSameAs              SDTargetingPredicateBaseV31Type = "audienceSameAs"
	SDTargetingPredicateBaseV31TypeExactProduct                SDTargetingPredicateBaseV31Type = "exactProduct"
	SDTargetingPredicateBaseV31TypeLookback                    SDTargetingPredicateBaseV31Type = "lookback"
	SDTargetingPredicateBaseV31TypeRelatedProduct              SDTargetingPredicateBaseV31Type = "relatedProduct"
	SDTargetingPredicateBaseV31TypeSimilarProduct              SDTargetingPredicateBaseV31Type = "similarProduct"
)

// Defines values for SDTargetingPredicateNestedV31Type.
const (
	SDTargetingPredicateNestedV31TypeAudience  SDTargetingPredicateNestedV31Type = "audience"
	SDTargetingPredicateNestedV31TypePurchases SDTargetingPredicateNestedV31Type = "purchases"
	SDTargetingPredicateNestedV31TypeViews     SDTargetingPredicateNestedV31Type = "views"
)

// Defines values for SDTargetingPredicateV31Type.
const (
	SDTargetingPredicateV31TypeAsinAgeRangeSameAs          SDTargetingPredicateV31Type = "asinAgeRangeSameAs"
	SDTargetingPredicateV31TypeAsinBrandSameAs             SDTargetingPredicateV31Type = "asinBrandSameAs"
	SDTargetingPredicateV31TypeAsinCategorySameAs          SDTargetingPredicateV31Type = "asinCategorySameAs"
	SDTargetingPredicateV31TypeAsinGenreSameAs             SDTargetingPredicateV31Type = "asinGenreSameAs"
	SDTargetingPredicateV31TypeAsinIsPrimeShippingEligible SDTargetingPredicateV31Type = "asinIsPrimeShippingEligible"
	SDTargetingPredicateV31TypeAsinPriceBetween            SDTargetingPredicateV31Type = "asinPriceBetween"
	SDTargetingPredicateV31TypeAsinPriceGreaterThan        SDTargetingPredicateV31Type = "asinPriceGreaterThan"
	SDTargetingPredicateV31TypeAsinPriceLessThan           SDTargetingPredicateV31Type = "asinPriceLessThan"
	SDTargetingPredicateV31TypeAsinReviewRatingBetween     SDTargetingPredicateV31Type = "asinReviewRatingBetween"
	SDTargetingPredicateV31TypeAsinReviewRatingGreaterThan SDTargetingPredicateV31Type = "asinReviewRatingGreaterThan"
	SDTargetingPredicateV31TypeAsinReviewRatingLessThan    SDTargetingPredicateV31Type = "asinReviewRatingLessThan"
	SDTargetingPredicateV31TypeAsinSameAs                  SDTargetingPredicateV31Type = "asinSameAs"
)

// Defines values for SDTargetingRecommendationsLocale.
const (
	SDTargetingRecommendationsLocaleArAE SDTargetingRecommendationsLocale = "ar_AE"
	SDTargetingRecommendationsLocaleDeDE SDTargetingRecommendationsLocale = "de_DE"
	SDTargetingRecommendationsLocaleEnAE SDTargetingRecommendationsLocale = "en_AE"
	SDTargetingRecommendationsLocaleEnAU SDTargetingRecommendationsLocale = "en_AU"
	SDTargetingRecommendationsLocaleEnCA SDTargetingRecommendationsLocale = "en_CA"
	SDTargetingRecommendationsLocaleEnGB SDTargetingRecommendationsLocale = "en_GB"
	SDTargetingRecommendationsLocaleEnIN SDTargetingRecommendationsLocale = "en_IN"
	SDTargetingRecommendationsLocaleEnSG SDTargetingRecommendationsLocale = "en_SG"
	SDTargetingRecommendationsLocaleEnUS SDTargetingRecommendationsLocale = "en_US"
	SDTargetingRecommendationsLocaleEsES SDTargetingRecommendationsLocale = "es_ES"
	SDTargetingRecommendationsLocaleEsMX SDTargetingRecommendationsLocale = "es_MX"
	SDTargetingRecommendationsLocaleFrCA SDTargetingRecommendationsLocale = "fr_CA"
	SDTargetingRecommendationsLocaleFrFR SDTargetingRecommendationsLocale = "fr_FR"
	SDTargetingRecommendationsLocaleHiIN SDTargetingRecommendationsLocale = "hi_IN"
	SDTargetingRecommendationsLocaleItIT SDTargetingRecommendationsLocale = "it_IT"
	SDTargetingRecommendationsLocaleJaJP SDTargetingRecommendationsLocale = "ja_JP"
	SDTargetingRecommendationsLocaleKoKR SDTargetingRecommendationsLocale = "ko_KR"
	SDTargetingRecommendationsLocaleNlNL SDTargetingRecommendationsLocale = "nl_NL"
	SDTargetingRecommendationsLocalePlPL SDTargetingRecommendationsLocale = "pl_PL"
	SDTargetingRecommendationsLocalePtBR SDTargetingRecommendationsLocale = "pt_BR"
	SDTargetingRecommendationsLocaleSvSE SDTargetingRecommendationsLocale = "sv_SE"
	SDTargetingRecommendationsLocaleTaIN SDTargetingRecommendationsLocale = "ta_IN"
	SDTargetingRecommendationsLocaleThTH SDTargetingRecommendationsLocale = "th_TH"
	SDTargetingRecommendationsLocaleTrTR SDTargetingRecommendationsLocale = "tr_TR"
	SDTargetingRecommendationsLocaleViVN SDTargetingRecommendationsLocale = "vi_VN"
	SDTargetingRecommendationsLocaleZhCN SDTargetingRecommendationsLocale = "zh_CN"
)

// Defines values for Segment.
const (
	MatchedTarget Segment = "matchedTarget"
)

// Defines values for SnapshotRequestStateFilter.
const (
	SnapshotRequestStateFilterArchived SnapshotRequestStateFilter = "archived"
	SnapshotRequestStateFilterEnabled  SnapshotRequestStateFilter = "enabled"
	SnapshotRequestStateFilterPaused   SnapshotRequestStateFilter = "paused"
)

// Defines values for SnapshotResponseRecordType.
const (
	SnapshotResponseRecordTypeAdgroups   SnapshotResponseRecordType = "adgroups"
	SnapshotResponseRecordTypeCampaigns  SnapshotResponseRecordType = "campaigns"
	SnapshotResponseRecordTypeProductAds SnapshotResponseRecordType = "productAds"
	SnapshotResponseRecordTypeTargets    SnapshotResponseRecordType = "targets"
)

// Defines values for SnapshotResponseStatus.
const (
	SnapshotResponseStatusFAILURE    SnapshotResponseStatus = "FAILURE"
	SnapshotResponseStatusINPROGRESS SnapshotResponseStatus = "IN_PROGRESS"
	SnapshotResponseStatusSUCCESS    SnapshotResponseStatus = "SUCCESS"
)

// Defines values for Tactic.
const (
	TacticT00020 Tactic = "T00020"
	TacticT00030 Tactic = "T00030"
)

// Defines values for TacticFilter.
const (
	TacticFilterT00020       TacticFilter = "T00020"
	TacticFilterT00020T00030 TacticFilter = "T00020,T00030"
	TacticFilterT00030       TacticFilter = "T00030"
)

// Defines values for TacticReport.
const (
	T00020 TacticReport = "T00020"
	T00030 TacticReport = "T00030"
)

// Defines values for TargetingClauseExpressionType.
const (
	TargetingClauseExpressionTypeAuto   TargetingClauseExpressionType = "auto"
	TargetingClauseExpressionTypeManual TargetingClauseExpressionType = "manual"
)

// Defines values for TargetingClauseState.
const (
	TargetingClauseStateArchived TargetingClauseState = "archived"
	TargetingClauseStateEnabled  TargetingClauseState = "enabled"
	TargetingClauseStatePaused   TargetingClauseState = "paused"
)

// Defines values for TargetingClauseExExpressionType.
const (
	Auto   TargetingClauseExExpressionType = "auto"
	Manual TargetingClauseExExpressionType = "manual"
)

// Defines values for TargetingClauseExServingStatus.
const (
	ACCOUNTOUTOFBUDGET          TargetingClauseExServingStatus = "ACCOUNT_OUT_OF_BUDGET"
	ADGROUPARCHIVED             TargetingClauseExServingStatus = "AD_GROUP_ARCHIVED"
	ADGROUPINCOMPLETE           TargetingClauseExServingStatus = "AD_GROUP_INCOMPLETE"
	ADGROUPLOWBID               TargetingClauseExServingStatus = "AD_GROUP_LOW_BID"
	ADGROUPPAUSED               TargetingClauseExServingStatus = "AD_GROUP_PAUSED"
	ADGROUPSTATUSENABLED        TargetingClauseExServingStatus = "AD_GROUP_STATUS_ENABLED"
	ADPOLICINGPENDINGREVIEW     TargetingClauseExServingStatus = "AD_POLICING_PENDING_REVIEW"
	ADVERTISEREXCEEDSPENDSLIMIT TargetingClauseExServingStatus = "ADVERTISER_EXCEED_SPENDS_LIMIT"
	ADVERTISERPAUSED            TargetingClauseExServingStatus = "ADVERTISER_PAUSED"
	ADVERTISERPAYMENTFAILURE    TargetingClauseExServingStatus = "ADVERTISER_PAYMENT_FAILURE"
	ADVERTISERSTATUSENABLED     TargetingClauseExServingStatus = "ADVERTISER_STATUS_ENABLED"
	CAMPAIGNARCHIVED            TargetingClauseExServingStatus = "CAMPAIGN_ARCHIVED"
	CAMPAIGNINCOMPLETE          TargetingClauseExServingStatus = "CAMPAIGN_INCOMPLETE"
	CAMPAIGNOUTOFBUDGET         TargetingClauseExServingStatus = "CAMPAIGN_OUT_OF_BUDGET"
	CAMPAIGNPAUSED              TargetingClauseExServingStatus = "CAMPAIGN_PAUSED"
	ENDED                       TargetingClauseExServingStatus = "ENDED"
	INELIGIBLE                  TargetingClauseExServingStatus = "INELIGIBLE"
	PENDINGSTARTDATE            TargetingClauseExServingStatus = "PENDING_START_DATE"
	PORTFOLIOENDED              TargetingClauseExServingStatus = "PORTFOLIO_ENDED"
	PORTFOLIOOUTOFBUDGET        TargetingClauseExServingStatus = "PORTFOLIO_OUT_OF_BUDGET"
	STATUSUNAVAILABLE           TargetingClauseExServingStatus = "STATUS_UNAVAILABLE"
	TARGETSTATUSARCHIVED        TargetingClauseExServingStatus = "TARGET_STATUS_ARCHIVED"
	TARGETSTATUSLIVE            TargetingClauseExServingStatus = "TARGET_STATUS_LIVE"
	TARGETSTATUSPAUSED          TargetingClauseExServingStatus = "TARGET_STATUS_PAUSED"
)

// Defines values for TargetingClauseExState.
const (
	TargetingClauseExStateArchived TargetingClauseExState = "archived"
	TargetingClauseExStateEnabled  TargetingClauseExState = "enabled"
	TargetingClauseExStatePaused   TargetingClauseExState = "paused"
)

// Defines values for TargetingPredicateType.
const (
	TargetingPredicateTypeAsinAgeRangeSameAs          TargetingPredicateType = "asinAgeRangeSameAs"
	TargetingPredicateTypeAsinBrandSameAs             TargetingPredicateType = "asinBrandSameAs"
	TargetingPredicateTypeAsinCategorySameAs          TargetingPredicateType = "asinCategorySameAs"
	TargetingPredicateTypeAsinGenreSameAs             TargetingPredicateType = "asinGenreSameAs"
	TargetingPredicateTypeAsinIsPrimeShippingEligible TargetingPredicateType = "asinIsPrimeShippingEligible"
	TargetingPredicateTypeAsinPriceBetween            TargetingPredicateType = "asinPriceBetween"
	TargetingPredicateTypeAsinPriceGreaterThan        TargetingPredicateType = "asinPriceGreaterThan"
	TargetingPredicateTypeAsinPriceLessThan           TargetingPredicateType = "asinPriceLessThan"
	TargetingPredicateTypeAsinReviewRatingBetween     TargetingPredicateType = "asinReviewRatingBetween"
	TargetingPredicateTypeAsinReviewRatingGreaterThan TargetingPredicateType = "asinReviewRatingGreaterThan"
	TargetingPredicateTypeAsinReviewRatingLessThan    TargetingPredicateType = "asinReviewRatingLessThan"
	TargetingPredicateTypeAsinSameAs                  TargetingPredicateType = "asinSameAs"
	TargetingPredicateTypeSimilarProduct              TargetingPredicateType = "similarProduct"
)

// Defines values for TargetingPredicateBaseType.
const (
	TargetingPredicateBaseTypeAsinAgeRangeSameAs          TargetingPredicateBaseType = "asinAgeRangeSameAs"
	TargetingPredicateBaseTypeAsinBrandSameAs             TargetingPredicateBaseType = "asinBrandSameAs"
	TargetingPredicateBaseTypeAsinCategorySameAs          TargetingPredicateBaseType = "asinCategorySameAs"
	TargetingPredicateBaseTypeAsinGenreSameAs             TargetingPredicateBaseType = "asinGenreSameAs"
	TargetingPredicateBaseTypeAsinIsPrimeShippingEligible TargetingPredicateBaseType = "asinIsPrimeShippingEligible"
	TargetingPredicateBaseTypeAsinPriceBetween            TargetingPredicateBaseType = "asinPriceBetween"
	TargetingPredicateBaseTypeAsinPriceGreaterThan        TargetingPredicateBaseType = "asinPriceGreaterThan"
	TargetingPredicateBaseTypeAsinPriceLessThan           TargetingPredicateBaseType = "asinPriceLessThan"
	TargetingPredicateBaseTypeAsinReviewRatingBetween     TargetingPredicateBaseType = "asinReviewRatingBetween"
	TargetingPredicateBaseTypeAsinReviewRatingGreaterThan TargetingPredicateBaseType = "asinReviewRatingGreaterThan"
	TargetingPredicateBaseTypeAsinReviewRatingLessThan    TargetingPredicateBaseType = "asinReviewRatingLessThan"
	TargetingPredicateBaseTypeAudienceSameAs              TargetingPredicateBaseType = "audienceSameAs"
	TargetingPredicateBaseTypeExactProduct                TargetingPredicateBaseType = "exactProduct"
	TargetingPredicateBaseTypeLookback                    TargetingPredicateBaseType = "lookback"
	TargetingPredicateBaseTypeNegative                    TargetingPredicateBaseType = "negative"
	TargetingPredicateBaseTypeRelatedProduct              TargetingPredicateBaseType = "relatedProduct"
	TargetingPredicateBaseTypeSimilarProduct              TargetingPredicateBaseType = "similarProduct"
)

// Defines values for TargetingPredicateLegacyEventType.
const (
	TargetingPredicateLegacyEventTypeViews TargetingPredicateLegacyEventType = "views"
)

// Defines values for TargetingPredicateLegacyType.
const (
	TargetingPredicateLegacyTypeAsinAgeRangeSameAs          TargetingPredicateLegacyType = "asinAgeRangeSameAs"
	TargetingPredicateLegacyTypeAsinBrandSameAs             TargetingPredicateLegacyType = "asinBrandSameAs"
	TargetingPredicateLegacyTypeAsinCategorySameAs          TargetingPredicateLegacyType = "asinCategorySameAs"
	TargetingPredicateLegacyTypeAsinGenreSameAs             TargetingPredicateLegacyType = "asinGenreSameAs"
	TargetingPredicateLegacyTypeAsinIsPrimeShippingEligible TargetingPredicateLegacyType = "asinIsPrimeShippingEligible"
	TargetingPredicateLegacyTypeAsinPriceBetween            TargetingPredicateLegacyType = "asinPriceBetween"
	TargetingPredicateLegacyTypeAsinPriceGreaterThan        TargetingPredicateLegacyType = "asinPriceGreaterThan"
	TargetingPredicateLegacyTypeAsinPriceLessThan           TargetingPredicateLegacyType = "asinPriceLessThan"
	TargetingPredicateLegacyTypeAsinReviewRatingBetween     TargetingPredicateLegacyType = "asinReviewRatingBetween"
	TargetingPredicateLegacyTypeAsinReviewRatingGreaterThan TargetingPredicateLegacyType = "asinReviewRatingGreaterThan"
	TargetingPredicateLegacyTypeAsinReviewRatingLessThan    TargetingPredicateLegacyType = "asinReviewRatingLessThan"
	TargetingPredicateLegacyTypeAsinSameAs                  TargetingPredicateLegacyType = "asinSameAs"
	TargetingPredicateLegacyTypeExactProduct                TargetingPredicateLegacyType = "exactProduct"
	TargetingPredicateLegacyTypeSimilarProduct              TargetingPredicateLegacyType = "similarProduct"
)

// Defines values for TargetingPredicateNestedType.
const (
	Audience  TargetingPredicateNestedType = "audience"
	Purchases TargetingPredicateNestedType = "purchases"
	Views     TargetingPredicateNestedType = "views"
)

// Defines values for UpdateAdGroupBidOptimization.
const (
	UpdateAdGroupBidOptimizationClicks      UpdateAdGroupBidOptimization = "clicks"
	UpdateAdGroupBidOptimizationConversions UpdateAdGroupBidOptimization = "conversions"
	UpdateAdGroupBidOptimizationReach       UpdateAdGroupBidOptimization = "reach"
)

// Defines values for UpdateAdGroupState.
const (
	UpdateAdGroupStateArchived UpdateAdGroupState = "archived"
	UpdateAdGroupStateEnabled  UpdateAdGroupState = "enabled"
	UpdateAdGroupStatePaused   UpdateAdGroupState = "paused"
)

// Defines values for UpdateCampaignBudgetType.
const (
	Daily UpdateCampaignBudgetType = "daily"
)

// Defines values for UpdateCampaignCostType.
const (
	UpdateCampaignCostTypeCpc  UpdateCampaignCostType = "cpc"
	UpdateCampaignCostTypeVcpm UpdateCampaignCostType = "vcpm"
)

// Defines values for UpdateCampaignState.
const (
	UpdateCampaignStateArchived UpdateCampaignState = "archived"
	UpdateCampaignStateEnabled  UpdateCampaignState = "enabled"
	UpdateCampaignStatePaused   UpdateCampaignState = "paused"
)

// Defines values for UpdateNegativeTargetingClauseState.
const (
	UpdateNegativeTargetingClauseStateArchived UpdateNegativeTargetingClauseState = "archived"
	UpdateNegativeTargetingClauseStateEnabled  UpdateNegativeTargetingClauseState = "enabled"
	UpdateNegativeTargetingClauseStatePaused   UpdateNegativeTargetingClauseState = "paused"
)

// Defines values for UpdateOptimizationRuleState.
const (
	UpdateOptimizationRuleStateEnabled           UpdateOptimizationRuleState = "enabled"
	UpdateOptimizationRuleStatePausedCOMINGLATER UpdateOptimizationRuleState = "paused [COMING LATER]"
)

// Defines values for UpdateProductAdState.
const (
	UpdateProductAdStateArchived UpdateProductAdState = "archived"
	UpdateProductAdStateEnabled  UpdateProductAdState = "enabled"
	UpdateProductAdStatePaused   UpdateProductAdState = "paused"
)

// Defines values for UpdateTargetingClauseState.
const (
	UpdateTargetingClauseStateArchived UpdateTargetingClauseState = "archived"
	UpdateTargetingClauseStateEnabled  UpdateTargetingClauseState = "enabled"
	UpdateTargetingClauseStatePaused   UpdateTargetingClauseState = "paused"
)

// Defines values for State.
const (
	ACTIVE State = "ACTIVE"
	PAUSED State = "PAUSED"
)

// Defines values for ListAdGroupsParamsStateFilter.
const (
	ListAdGroupsParamsStateFilterArchived              ListAdGroupsParamsStateFilter = "archived"
	ListAdGroupsParamsStateFilterEnabled               ListAdGroupsParamsStateFilter = "enabled"
	ListAdGroupsParamsStateFilterEnabledArchived       ListAdGroupsParamsStateFilter = "enabled, archived"
	ListAdGroupsParamsStateFilterEnabledPaused         ListAdGroupsParamsStateFilter = "enabled, paused"
	ListAdGroupsParamsStateFilterEnabledPausedArchived ListAdGroupsParamsStateFilter = "enabled, paused, archived"
	ListAdGroupsParamsStateFilterPaused                ListAdGroupsParamsStateFilter = "paused"
	ListAdGroupsParamsStateFilterPausedArchived        ListAdGroupsParamsStateFilter = "paused, archived"
)

// Defines values for ListAdGroupsExParamsStateFilter.
const (
	ListAdGroupsExParamsStateFilterArchived              ListAdGroupsExParamsStateFilter = "archived"
	ListAdGroupsExParamsStateFilterEnabled               ListAdGroupsExParamsStateFilter = "enabled"
	ListAdGroupsExParamsStateFilterEnabledArchived       ListAdGroupsExParamsStateFilter = "enabled, archived"
	ListAdGroupsExParamsStateFilterEnabledPaused         ListAdGroupsExParamsStateFilter = "enabled, paused"
	ListAdGroupsExParamsStateFilterEnabledPausedArchived ListAdGroupsExParamsStateFilter = "enabled, paused, archived"
	ListAdGroupsExParamsStateFilterPaused                ListAdGroupsExParamsStateFilter = "paused"
	ListAdGroupsExParamsStateFilterPausedArchived        ListAdGroupsExParamsStateFilter = "paused, archived"
)

// Defines values for ListCampaignsParamsStateFilter.
const (
	ListCampaignsParamsStateFilterArchived              ListCampaignsParamsStateFilter = "archived"
	ListCampaignsParamsStateFilterEnabled               ListCampaignsParamsStateFilter = "enabled"
	ListCampaignsParamsStateFilterEnabledArchived       ListCampaignsParamsStateFilter = "enabled, archived"
	ListCampaignsParamsStateFilterEnabledPaused         ListCampaignsParamsStateFilter = "enabled, paused"
	ListCampaignsParamsStateFilterEnabledPausedArchived ListCampaignsParamsStateFilter = "enabled, paused, archived"
	ListCampaignsParamsStateFilterPaused                ListCampaignsParamsStateFilter = "paused"
	ListCampaignsParamsStateFilterPausedArchived        ListCampaignsParamsStateFilter = "paused, archived"
)

// Defines values for ListCampaignsExParamsStateFilter.
const (
	ListCampaignsExParamsStateFilterArchived              ListCampaignsExParamsStateFilter = "archived"
	ListCampaignsExParamsStateFilterEnabled               ListCampaignsExParamsStateFilter = "enabled"
	ListCampaignsExParamsStateFilterEnabledArchived       ListCampaignsExParamsStateFilter = "enabled, archived"
	ListCampaignsExParamsStateFilterEnabledPaused         ListCampaignsExParamsStateFilter = "enabled, paused"
	ListCampaignsExParamsStateFilterEnabledPausedArchived ListCampaignsExParamsStateFilter = "enabled, paused, archived"
	ListCampaignsExParamsStateFilterPaused                ListCampaignsExParamsStateFilter = "paused"
	ListCampaignsExParamsStateFilterPausedArchived        ListCampaignsExParamsStateFilter = "paused, archived"
)

// Defines values for ListLocationsParamsStateFilter.
const (
	ListLocationsParamsStateFilterEnabled ListLocationsParamsStateFilter = "enabled"
)

// Defines values for ListNegativeTargetingClausesParamsStateFilter.
const (
	ListNegativeTargetingClausesParamsStateFilterArchived              ListNegativeTargetingClausesParamsStateFilter = "archived"
	ListNegativeTargetingClausesParamsStateFilterEnabled               ListNegativeTargetingClausesParamsStateFilter = "enabled"
	ListNegativeTargetingClausesParamsStateFilterEnabledArchived       ListNegativeTargetingClausesParamsStateFilter = "enabled, archived"
	ListNegativeTargetingClausesParamsStateFilterEnabledPaused         ListNegativeTargetingClausesParamsStateFilter = "enabled, paused"
	ListNegativeTargetingClausesParamsStateFilterEnabledPausedArchived ListNegativeTargetingClausesParamsStateFilter = "enabled, paused, archived"
	ListNegativeTargetingClausesParamsStateFilterPaused                ListNegativeTargetingClausesParamsStateFilter = "paused"
	ListNegativeTargetingClausesParamsStateFilterPausedArchived        ListNegativeTargetingClausesParamsStateFilter = "paused, archived"
)

// Defines values for ListNegativeTargetingClausesExParamsStateFilter.
const (
	ListNegativeTargetingClausesExParamsStateFilterArchived              ListNegativeTargetingClausesExParamsStateFilter = "archived"
	ListNegativeTargetingClausesExParamsStateFilterEnabled               ListNegativeTargetingClausesExParamsStateFilter = "enabled"
	ListNegativeTargetingClausesExParamsStateFilterEnabledArchived       ListNegativeTargetingClausesExParamsStateFilter = "enabled, archived"
	ListNegativeTargetingClausesExParamsStateFilterEnabledPaused         ListNegativeTargetingClausesExParamsStateFilter = "enabled, paused"
	ListNegativeTargetingClausesExParamsStateFilterEnabledPausedArchived ListNegativeTargetingClausesExParamsStateFilter = "enabled, paused, archived"
	ListNegativeTargetingClausesExParamsStateFilterPaused                ListNegativeTargetingClausesExParamsStateFilter = "paused"
	ListNegativeTargetingClausesExParamsStateFilterPausedArchived        ListNegativeTargetingClausesExParamsStateFilter = "paused, archived"
)

// Defines values for ListProductAdsParamsStateFilter.
const (
	ListProductAdsParamsStateFilterArchived              ListProductAdsParamsStateFilter = "archived"
	ListProductAdsParamsStateFilterEnabled               ListProductAdsParamsStateFilter = "enabled"
	ListProductAdsParamsStateFilterEnabledArchived       ListProductAdsParamsStateFilter = "enabled, archived"
	ListProductAdsParamsStateFilterEnabledPaused         ListProductAdsParamsStateFilter = "enabled, paused"
	ListProductAdsParamsStateFilterEnabledPausedArchived ListProductAdsParamsStateFilter = "enabled, paused, archived"
	ListProductAdsParamsStateFilterPaused                ListProductAdsParamsStateFilter = "paused"
	ListProductAdsParamsStateFilterPausedArchived        ListProductAdsParamsStateFilter = "paused, archived"
)

// Defines values for ListProductAdsExParamsStateFilter.
const (
	ListProductAdsExParamsStateFilterArchived              ListProductAdsExParamsStateFilter = "archived"
	ListProductAdsExParamsStateFilterEnabled               ListProductAdsExParamsStateFilter = "enabled"
	ListProductAdsExParamsStateFilterEnabledArchived       ListProductAdsExParamsStateFilter = "enabled, archived"
	ListProductAdsExParamsStateFilterEnabledPaused         ListProductAdsExParamsStateFilter = "enabled, paused"
	ListProductAdsExParamsStateFilterEnabledPausedArchived ListProductAdsExParamsStateFilter = "enabled, paused, archived"
	ListProductAdsExParamsStateFilterPaused                ListProductAdsExParamsStateFilter = "paused"
	ListProductAdsExParamsStateFilterPausedArchived        ListProductAdsExParamsStateFilter = "paused, archived"
)

// Defines values for ListTargetingClausesParamsStateFilter.
const (
	ListTargetingClausesParamsStateFilterArchived              ListTargetingClausesParamsStateFilter = "archived"
	ListTargetingClausesParamsStateFilterEnabled               ListTargetingClausesParamsStateFilter = "enabled"
	ListTargetingClausesParamsStateFilterEnabledArchived       ListTargetingClausesParamsStateFilter = "enabled, archived"
	ListTargetingClausesParamsStateFilterEnabledPaused         ListTargetingClausesParamsStateFilter = "enabled, paused"
	ListTargetingClausesParamsStateFilterEnabledPausedArchived ListTargetingClausesParamsStateFilter = "enabled, paused, archived"
	ListTargetingClausesParamsStateFilterPaused                ListTargetingClausesParamsStateFilter = "paused"
	ListTargetingClausesParamsStateFilterPausedArchived        ListTargetingClausesParamsStateFilter = "paused, archived"
)

// Defines values for ListTargetingClausesExParamsStateFilter.
const (
	Archived              ListTargetingClausesExParamsStateFilter = "archived"
	Enabled               ListTargetingClausesExParamsStateFilter = "enabled"
	EnabledArchived       ListTargetingClausesExParamsStateFilter = "enabled, archived"
	EnabledPaused         ListTargetingClausesExParamsStateFilter = "enabled, paused"
	EnabledPausedArchived ListTargetingClausesExParamsStateFilter = "enabled, paused, archived"
	Paused                ListTargetingClausesExParamsStateFilter = "paused"
	PausedArchived        ListTargetingClausesExParamsStateFilter = "paused, archived"
)

// Defines values for RequestReportParamsRecordType.
const (
	RequestReportParamsRecordTypeAdGroups   RequestReportParamsRecordType = "adGroups"
	RequestReportParamsRecordTypeAsins      RequestReportParamsRecordType = "asins"
	RequestReportParamsRecordTypeCampaigns  RequestReportParamsRecordType = "campaigns"
	RequestReportParamsRecordTypeProductAds RequestReportParamsRecordType = "productAds"
	RequestReportParamsRecordTypeTargets    RequestReportParamsRecordType = "targets"
)

// AdGroup defines model for AdGroup.
type AdGroup struct {
	// AdGroupId The identifier of the ad group.
	AdGroupId *AdGroupId `json:"adGroupId,omitempty"`

	// BidOptimization Bid Optimization for the Adgroup. Default behavior is to optimize for clicks.
	// |Name|CostType|Description|
	// |----|--------|-----------|
	// |reach |vcpm|Optimize for viewable impressions. $1 is the minimum bid for vCPM.|
	// |clicks |cpc|[Default] Optimize for page visits.|
	// |conversions |cpc|Optimize for conversion.|
	BidOptimization *AdGroupBidOptimization `json:"bidOptimization,omitempty"`

	// CampaignId The identifier of the campaign.
	CampaignId *CampaignId `json:"campaignId,omitempty"`

	// CreativeType The type of the associated creative. If the field is empty or null, a default value of IMAGE will be used. One ad group only supports one type (VIDEO or IMAGE) of creativeType at a time.
	// |Name|Description|
	// |----|-----------|
	// |IMAGE |The creative will display static assets (e.g. headline, brandLogo or custom image).|
	// |VIDEO |The creative will display video assets. This type of creative must have a video asset provided. Only supported when using productAds with ASIN or SKU.|
	CreativeType *CreativeType `json:"creativeType"`

	// DefaultBid The amount of the default bid associated with the ad group. Used if no bid is specified.
	DefaultBid *float64 `json:"defaultBid,omitempty"`

	// Name The name of the ad group.
	Name *string `json:"name,omitempty"`

	// State The state of the ad group.
	State *AdGroupState `json:"state,omitempty"`

	// Tactic The advertising tactic associated with the campaign. The following table lists available tactic names:
	// |Tactic Name|Type|Description|
	// |-----------|-----|-----------|
	// |T00020     |Contextual targeting | Choose individual products to show your ads in placements related to those products.<br> Choose individual categories to show your ads in placements related to those categories on and off Amazon.|
	// |T00030     |Audiences targeting | Select individual audiences to show your ads.|
	Tactic *Tactic `json:"tactic,omitempty"`
}

// AdGroupBidOptimization Bid Optimization for the Adgroup. Default behavior is to optimize for clicks.
// |Name|CostType|Description|
// |----|--------|-----------|
// |reach |vcpm|Optimize for viewable impressions. $1 is the minimum bid for vCPM.|
// |clicks |cpc|[Default] Optimize for page visits.|
// |conversions |cpc|Optimize for conversion.|
type AdGroupBidOptimization string

// AdGroupState The state of the ad group.
type AdGroupState string

// AdGroupId The identifier of the ad group.
type AdGroupId = int64

// AdGroupResponse defines model for AdGroupResponse.
type AdGroupResponse struct {
	// AdGroupId The identifier of the ad group.
	AdGroupId *AdGroupId `json:"adGroupId,omitempty"`

	// Code The HTTP status code of the response.
	Code *string `json:"code,omitempty"`

	// Description A human-readable description of the response.
	Description *string `json:"description,omitempty"`
}

// AdGroupResponseEx Object containing an extended set of data fields for an Ad Group.
type AdGroupResponseEx struct {
	// AdGroupId The identifier of the ad group.
	AdGroupId *float32 `json:"adGroupId,omitempty"`

	// BidOptimization Bid optimization type for the Adgroup. Default behavior is to optimize for clicks. Note, reach and clicks are only accepted with productAds that include landingPageURL OFF_AMAZON_LINK.
	// |Name|CostType|Description|
	// |----|--------|-----------|
	// |reach|vcpm|Optimize for viewable impressions. $1 is the minimum bid for vCPM.|
	// |clicks [Default]|cpc|Optimize for page visits.|
	// |conversions|cpc|Optimize for conversion.|
	// |leads |cpc| [PREVIEW ONLY] Optimize for lead generation.|
	BidOptimization *AdGroupResponseExBidOptimization `json:"bidOptimization,omitempty"`

	// CampaignId The identifier of the campaign that this ad group is associated with.
	CampaignId *float32 `json:"campaignId,omitempty"`

	// CreationDate Epoch time the ad group was created.
	CreationDate *int64 `json:"creationDate,omitempty"`

	// CreativeType
	// The type of the creative.
	// |Name|Description|
	// |----|-----------|
	// |IMAGE |The creative will display static assets (e.g. headline, brandLogo or custom image).|
	// |VIDEO |The creative will display video assets. This type of creative must have video assets provided.|
	CreativeType *CreativeTypeInCreativeResponse `json:"creativeType,omitempty"`

	// DefaultBid The amount of the default bid associated with the ad group. Used if no bid is specified.
	DefaultBid *float64 `json:"defaultBid,omitempty"`

	// LastUpdatedDate Epoch time any property in the ad group was last updated.
	LastUpdatedDate *int64 `json:"lastUpdatedDate,omitempty"`

	// Name The name of the ad group.
	Name *string `json:"name,omitempty"`

	// ServingStatus The status of the ad group.
	ServingStatus *AdGroupResponseExServingStatus `json:"servingStatus,omitempty"`

	// State The delivery state of the ad group.
	State *AdGroupResponseExState `json:"state,omitempty"`

	// Tactic The advertising tactic associated with the campaign. The following table lists available tactic names:
	// |Tactic Name|Type|Description|
	// |-----------|-----|-----------|
	// |T00020     |Contextual targeting | Choose individual products to show your ads in placements related to those products.<br> Choose individual categories to show your ads in placements related to those categories on and off Amazon.|
	// |T00030     |Audiences targeting | Select individual audiences to show your ads.|
	Tactic *Tactic `json:"tactic,omitempty"`
}

// AdGroupResponseExBidOptimization Bid optimization type for the Adgroup. Default behavior is to optimize for clicks. Note, reach and clicks are only accepted with productAds that include landingPageURL OFF_AMAZON_LINK.
// |Name|CostType|Description|
// |----|--------|-----------|
// |reach|vcpm|Optimize for viewable impressions. $1 is the minimum bid for vCPM.|
// |clicks [Default]|cpc|Optimize for page visits.|
// |conversions|cpc|Optimize for conversion.|
// |leads |cpc| [PREVIEW ONLY] Optimize for lead generation.|
type AdGroupResponseExBidOptimization string

// AdGroupResponseExServingStatus The status of the ad group.
type AdGroupResponseExServingStatus string

// AdGroupResponseExState The delivery state of the ad group.
type AdGroupResponseExState string

// AdId The identifier of the product ad.
type AdId = int64

// AdName The name of the ad. Note that this field is not supported when using ASIN or SKU fields.
type AdName = string

// BaseAdGroup defines model for BaseAdGroup.
type BaseAdGroup struct {
	// BidOptimization Bid Optimization for the Adgroup. Default behavior is to optimize for clicks.
	// |Name|CostType|Description|
	// |----|--------|-----------|
	// |reach |vcpm|Optimize for viewable impressions. $1 is the minimum bid for vCPM.|
	// |clicks |cpc|[Default] Optimize for page visits.|
	// |conversions |cpc|Optimize for conversion.|
	BidOptimization *BaseAdGroupBidOptimization `json:"bidOptimization,omitempty"`

	// CampaignId The identifier of the campaign.
	CampaignId *CampaignId `json:"campaignId,omitempty"`

	// DefaultBid The amount of the default bid associated with the ad group. Used if no bid is specified.
	DefaultBid *float64 `json:"defaultBid,omitempty"`

	// Name The name of the ad group.
	Name *string `json:"name,omitempty"`

	// State The state of the ad group.
	State *BaseAdGroupState `json:"state,omitempty"`
}

// BaseAdGroupBidOptimization Bid Optimization for the Adgroup. Default behavior is to optimize for clicks.
// |Name|CostType|Description|
// |----|--------|-----------|
// |reach |vcpm|Optimize for viewable impressions. $1 is the minimum bid for vCPM.|
// |clicks |cpc|[Default] Optimize for page visits.|
// |conversions |cpc|Optimize for conversion.|
type BaseAdGroupBidOptimization string

// BaseAdGroupState The state of the ad group.
type BaseAdGroupState string

// BaseCampaign defines model for BaseCampaign.
type BaseCampaign struct {
	// Budget The amount of the budget.
	Budget *float64 `json:"budget,omitempty"`

	// BudgetType The time period over which the amount specified in the `budget` property is allocated.
	BudgetType *BaseCampaignBudgetType `json:"budgetType,omitempty"`

	// CostType Determines how the campaign will bid and charge.
	// |Name|Description|
	// |----|----------|
	// |cpc |[Default] The performance of this campaign is measured by the clicks triggered by the ad.|
	// |vcpm |The performance of this campaign is measured by the viewed impressions triggered by the ad. |
	//
	// To view minimum and maximum bids based on the costType, see [Limits](https://advertising.amazon.com/API/docs/en-us/concepts/limits#bid-constraints-by-marketplace).
	CostType *BaseCampaignCostType `json:"costType,omitempty"`

	// EndDate The YYYYMMDD end date of the campaign.
	EndDate *string `json:"endDate"`

	// Name The name of the campaign.
	Name *string `json:"name,omitempty"`

	// PortfolioId Identifier of the portfolio that will be associated with the campaign. If null then the campaign will be disassociated from existing portfolio. Campaigns with CPC and vCPM costType are supported.
	PortfolioId *int64 `json:"portfolioId"`

	// StartDate The YYYYMMDD start date of the campaign. The date must be today or in the future.
	StartDate *string `json:"startDate,omitempty"`

	// State The state of the campaign.
	State *BaseCampaignState `json:"state,omitempty"`
}

// BaseCampaignBudgetType The time period over which the amount specified in the `budget` property is allocated.
type BaseCampaignBudgetType string

// BaseCampaignCostType Determines how the campaign will bid and charge.
// |Name|Description|
// |----|----------|
// |cpc |[Default] The performance of this campaign is measured by the clicks triggered by the ad.|
// |vcpm |The performance of this campaign is measured by the viewed impressions triggered by the ad. |
//
// To view minimum and maximum bids based on the costType, see [Limits](https://advertising.amazon.com/API/docs/en-us/concepts/limits#bid-constraints-by-marketplace).
type BaseCampaignCostType string

// BaseCampaignState The state of the campaign.
type BaseCampaignState string

// BaseLocation defines model for BaseLocation.
type BaseLocation struct {
	State *BaseLocationState `json:"state,omitempty"`
}

// BaseLocationState defines model for BaseLocation.State.
type BaseLocationState string

// BaseNegativeTargetingClause defines model for BaseNegativeTargetingClause.
type BaseNegativeTargetingClause struct {
	State *BaseNegativeTargetingClauseState `json:"state,omitempty"`
}

// BaseNegativeTargetingClauseState defines model for BaseNegativeTargetingClause.State.
type BaseNegativeTargetingClauseState string

// BaseOptimizationRule defines model for BaseOptimizationRule.
type BaseOptimizationRule struct {
	// RuleConditions A list of rule conditions that define the advertiser's intent for the outcome of the rule. The rule uses 'AND' logic to combine every condition in this list, and will validate the combination when the rule is created or updated.
	RuleConditions *[]RuleCondition `json:"ruleConditions,omitempty"`

	// RuleName The name of the optimization rule.
	RuleName *string `json:"ruleName,omitempty"`

	// State The state of the optimization rule.
	State *BaseOptimizationRuleState `json:"state,omitempty"`
}

// BaseOptimizationRuleState The state of the optimization rule.
type BaseOptimizationRuleState string

// BaseProductAd defines model for BaseProductAd.
type BaseProductAd struct {
	// State The state of the campaign associated with the product ad.
	State *BaseProductAdState `json:"state,omitempty"`
}

// BaseProductAdState The state of the campaign associated with the product ad.
type BaseProductAdState string

// BaseTargetingClause defines model for BaseTargetingClause.
type BaseTargetingClause struct {
	// Bid The bid will override the adGroup bid if specified. This field is not used for negative targeting clauses. The bid must be less than the maximum allowable bid for the campaign's marketplace; for a list of maximum allowable bids, find the ["Bid constraints by marketplace" table in our documentation overview](https://advertising.amazon.com/API/docs/en-us/concepts/limits#bid-constraints-by-marketplace). You cannot manually set a bid when the targeting clause's adGroup has an enabled optimization rule.
	Bid   *float32                  `json:"bid"`
	State *BaseTargetingClauseState `json:"state,omitempty"`
}

// BaseTargetingClauseState defines model for BaseTargetingClause.State.
type BaseTargetingClauseState string

// BrandSafetyDenyListDomain defines model for BrandSafetyDenyListDomain.
type BrandSafetyDenyListDomain struct {
	// Name The website or app identifier. This can be in the form of full domain (eg. 'example.com' or 'example.net'), or mobile app identifier (eg. 'com.example.app' for Android apps or '1234567890' for iOS apps)
	Name string `json:"name"`

	// Type The domain type.
	Type BrandSafetyDenyListDomainType `json:"type"`
}

// BrandSafetyDenyListDomainState The state of the domain.
type BrandSafetyDenyListDomainState string

// BrandSafetyDenyListDomainType The domain type.
type BrandSafetyDenyListDomainType string

// BrandSafetyDenyListDomainUpdateResultStatus The state of the domain.
type BrandSafetyDenyListDomainUpdateResultStatus string

// BrandSafetyDenyListProcessedDomain defines model for BrandSafetyDenyListProcessedDomain.
type BrandSafetyDenyListProcessedDomain struct {
	// CreatedAt The date time the domain was created at. Format YYYY-MM-ddT:HH:mm:ssZ
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// DomainId The identifier of the Brand Safety List domain.
	DomainId *int64 `json:"domainId,omitempty"`

	// LastModified The date time the domain was last modified. Format YYYY-MM-ddT:HH:mm:ssZ
	LastModified *time.Time `json:"lastModified,omitempty"`

	// Name The website or app identifier. This can be in the form of full domain (eg. 'example.com' or 'example.net'), or mobile app identifier (eg. 'com.example.app' for Android apps or '1234567890' for iOS apps)
	Name *string `json:"name,omitempty"`

	// State The state of the domain.
	State *BrandSafetyDenyListDomainState `json:"state,omitempty"`

	// Type The domain type.
	Type *BrandSafetyDenyListDomainType `json:"type,omitempty"`
}

// BrandSafetyGetResponse Response for Brand Safety Deny List GET requests
type BrandSafetyGetResponse struct {
	// Domains List of Brand Safety Deny List Domains
	Domains *[]BrandSafetyDenyListProcessedDomain `json:"domains,omitempty"`

	// Pagination Response pagination info for Brand Safety Deny List GET requests
	Pagination *BrandSafetyGetResponsePagination `json:"pagination,omitempty"`
}

// BrandSafetyGetResponsePagination Response pagination info for Brand Safety Deny List GET requests
type BrandSafetyGetResponsePagination struct {
	// Limit The maximum number of deny list domains returned from GET request
	Limit *int `json:"limit,omitempty"`

	// Offset The number of deny list domains skipped
	Offset *int `json:"offset,omitempty"`

	// Total The total number of deny list domains created by the advertiser
	Total *int `json:"total,omitempty"`
}

// BrandSafetyListRequestStatusResponse List of all requests' status.
type BrandSafetyListRequestStatusResponse struct {
	// RequestStatusList List of all requests' status.
	RequestStatusList *[]BrandSafetyRequestStatus `json:"requestStatusList,omitempty"`
}

// BrandSafetyPostRequest POST Request for Brand Safety
type BrandSafetyPostRequest struct {
	Domains []BrandSafetyDenyListDomain `json:"domains"`
}

// BrandSafetyRequestResult defines model for BrandSafetyRequestResult.
type BrandSafetyRequestResult struct {
	// Details A human-readable description of the response.
	Details *string `json:"details,omitempty"`

	// DomainId The identifier of the Brand Safety Deny List Domain.
	DomainId *int64 `json:"domainId,omitempty"`

	// Name The website or app identifier.
	Name *string `json:"name,omitempty"`

	// Status The state of the domain.
	Status *BrandSafetyDenyListDomainUpdateResultStatus `json:"status,omitempty"`
}

// BrandSafetyRequestResultsResponse defines model for BrandSafetyRequestResultsResponse.
type BrandSafetyRequestResultsResponse struct {
	// Results A list of results for the given requestId
	Results *[]BrandSafetyRequestResult `json:"results,omitempty"`
}

// BrandSafetyRequestStatus defines model for BrandSafetyRequestStatus.
type BrandSafetyRequestStatus struct {
	// RequestId Request ID
	RequestId *string `json:"requestId,omitempty"`

	// Status The status of the request
	Status *BrandSafetyRequestStatusStatus `json:"status,omitempty"`

	// StatusDetails Details related to the request status
	StatusDetails *string `json:"statusDetails,omitempty"`

	// Timestamp Request timestamp
	Timestamp *string `json:"timestamp,omitempty"`
}

// BrandSafetyRequestStatusStatus The status of the request
type BrandSafetyRequestStatusStatus string

// BrandSafetyRequestStatusResponse The status of the request.
type BrandSafetyRequestStatusResponse struct {
	RequestStatus *BrandSafetyRequestStatus `json:"requestStatus,omitempty"`
}

// BrandSafetyUpdateResponse Response for Brand Safety POST and DELETE requests
type BrandSafetyUpdateResponse struct {
	// RequestId The identifier of the request
	RequestId *string `json:"requestId,omitempty"`
}

// BudgetChangeType The value by which to update the budget of the budget rule.
type BudgetChangeType string

// BudgetRuleError The Error Response Object.
type BudgetRuleError struct {
	// Code An enumerated error code for machine use.
	Code *string `json:"code,omitempty"`

	// Details A human-readable description of the response.
	Details *string `json:"details,omitempty"`
}

// BudgetRuleResponse defines model for BudgetRuleResponse.
type BudgetRuleResponse struct {
	AssociatedCampaignIds *[]string `json:"associatedCampaignIds,omitempty"`

	// Code An enumerated success or error code for machine use.
	Code *string `json:"code,omitempty"`

	// Details A human-readable description of the error, if unsuccessful
	Details *string `json:"details,omitempty"`

	// RuleId The rule identifier.
	RuleId *string `json:"ruleId,omitempty"`
}

// BudgetUsageCampaign defines model for BudgetUsageCampaign.
type BudgetUsageCampaign struct {
	// Budget Budget amount of resource requested
	Budget *float32 `json:"budget,omitempty"`

	// BudgetUsagePercent Budget usage percentage (spend / available budget) for the given budget policy.
	BudgetUsagePercent *float32 `json:"budgetUsagePercent,omitempty"`

	// CampaignId ID of requested resource
	CampaignId *string `json:"campaignId,omitempty"`

	// Index An index to maintain order of the campaignIds
	Index *float32 `json:"index,omitempty"`

	// UsageUpdatedTimestamp Last evaluation time for budget usage
	UsageUpdatedTimestamp *time.Time `json:"usageUpdatedTimestamp,omitempty"`
}

// BudgetUsageCampaignBatchError defines model for BudgetUsageCampaignBatchError.
type BudgetUsageCampaignBatchError struct {
	// CampaignId ID of requested resource
	CampaignId *string `json:"campaignId,omitempty"`

	// Code An enumerated error code for machine use.
	Code *string `json:"code,omitempty"`

	// Details A human-readable description of the response.
	Details *string `json:"details,omitempty"`

	// Index An index to maintain order of the campaignIds
	Index *float32 `json:"index,omitempty"`
}

// BudgetUsageCampaignRequest defines model for BudgetUsageCampaignRequest.
type BudgetUsageCampaignRequest struct {
	// CampaignIds A list of campaign IDs
	CampaignIds *[]string `json:"campaignIds,omitempty"`
}

// BudgetUsageCampaignResponse defines model for BudgetUsageCampaignResponse.
type BudgetUsageCampaignResponse struct {
	// Error List of budget usage percentages that failed to pull
	Error *[]BudgetUsageCampaignBatchError `json:"error,omitempty"`

	// Success List of budget usage percentages that were successfully pulled
	Success *[]BudgetUsageCampaign `json:"success,omitempty"`
}

// BudgetUsageError The Error Response Object.
type BudgetUsageError struct {
	// Code An enumerated error code for machine use.
	Code *string `json:"code,omitempty"`

	// Details A human-readable description of the response.
	Details *string `json:"details,omitempty"`
}

// Campaign defines model for Campaign.
type Campaign struct {
	// Budget The amount of the budget.
	Budget *float64 `json:"budget,omitempty"`

	// BudgetType The time period over which the amount specified in the `budget` property is allocated.
	BudgetType *CampaignBudgetType `json:"budgetType,omitempty"`

	// CampaignId The identifier of the campaign.
	CampaignId *CampaignId `json:"campaignId,omitempty"`

	// CostType Determines how the campaign will bid and charge.
	// |Name|Description|
	// |----|----------|
	// |cpc |[Default] The performance of this campaign is measured by the clicks triggered by the ad.|
	// |vcpm |The performance of this campaign is measured by the viewed impressions triggered by the ad. |
	//
	// To view minimum and maximum bids based on the costType, see [Limits](https://advertising.amazon.com/API/docs/en-us/concepts/limits#bid-constraints-by-marketplace).
	CostType        *CampaignCostType        `json:"costType,omitempty"`
	DeliveryProfile *CampaignDeliveryProfile `json:"deliveryProfile,omitempty"`

	// EndDate The YYYYMMDD end date of the campaign.
	EndDate *string `json:"endDate"`

	// Name The name of the campaign.
	Name *string `json:"name,omitempty"`

	// PortfolioId Identifier of the portfolio that will be associated with the campaign. If null then the campaign will be disassociated from existing portfolio. Campaigns with CPC and vCPM costType are supported.
	PortfolioId     *int64           `json:"portfolioId"`
	RuleBasedBudget *RuleBasedBudget `json:"ruleBasedBudget,omitempty"`

	// StartDate The YYYYMMDD start date of the campaign. The date must be today or in the future.
	StartDate *string `json:"startDate,omitempty"`

	// State The state of the campaign.
	State *CampaignState `json:"state,omitempty"`

	// Tactic The advertising tactic associated with the campaign. The following table lists available tactic names:
	// |Tactic Name|Type|Description|
	// |-----------|-----|-----------|
	// |T00020     |Contextual targeting | Choose individual products to show your ads in placements related to those products.<br> Choose individual categories to show your ads in placements related to those categories on and off Amazon.|
	// |T00030     |Audiences targeting | Select individual audiences to show your ads.|
	Tactic *Tactic `json:"tactic,omitempty"`
}

// CampaignBudgetType The time period over which the amount specified in the `budget` property is allocated.
type CampaignBudgetType string

// CampaignCostType Determines how the campaign will bid and charge.
// |Name|Description|
// |----|----------|
// |cpc |[Default] The performance of this campaign is measured by the clicks triggered by the ad.|
// |vcpm |The performance of this campaign is measured by the viewed impressions triggered by the ad. |
//
// To view minimum and maximum bids based on the costType, see [Limits](https://advertising.amazon.com/API/docs/en-us/concepts/limits#bid-constraints-by-marketplace).
type CampaignCostType string

// CampaignDeliveryProfile defines model for Campaign.DeliveryProfile.
type CampaignDeliveryProfile string

// CampaignState The state of the campaign.
type CampaignState string

// CampaignId The identifier of the campaign.
type CampaignId = int64

// CampaignResponse defines model for CampaignResponse.
type CampaignResponse struct {
	// CampaignId The identifier of the campaign.
	CampaignId *CampaignId `json:"campaignId,omitempty"`

	// Code The HTTP status code of the response.
	Code *string `json:"code,omitempty"`

	// Description A human-readable description of the response.
	Description *string `json:"description,omitempty"`
}

// CampaignResponseEx defines model for CampaignResponseEx.
type CampaignResponseEx struct {
	// Budget The amount of the budget.
	Budget *float64 `json:"budget,omitempty"`

	// BudgetType The time period over which the amount specified in the `budget` property is allocated.
	BudgetType *CampaignResponseExBudgetType `json:"budgetType,omitempty"`

	// CampaignId The identifier of the campaign.
	CampaignId *float32 `json:"campaignId,omitempty"`

	// CostType Determines how the campaign will bid and charge.
	// |Name|Description|
	// |----|----------|-----------|
	// |cpc |[Default] The performance of this campaign is measured by the clicks triggered by the ad.|
	// |vcpm|The performance of this campaign is measured by the viewed impressions triggered by the ad. $1 is the minimum bid for vCPM.|
	CostType *CampaignResponseExCostType `json:"costType,omitempty"`

	// CreationDate Epoch date the campaign was created.
	CreationDate *int64 `json:"creationDate,omitempty"`

	// EndDate The YYYYMMDD end date of the campaign.
	EndDate *string `json:"endDate,omitempty"`

	// LastUpdatedDate Epoch date of the last update to any property associated with the campaign.
	LastUpdatedDate *int64 `json:"lastUpdatedDate,omitempty"`

	// Name The name of the campaign.
	Name *string `json:"name,omitempty"`

	// PortfolioId Identifier of the portfolio that will be associated with the campaign. If null then the campaign will be disassociated from existing portfolio. Campaigns with CPC and vCPM costType are supported.
	PortfolioId     *int64           `json:"portfolioId,omitempty"`
	RuleBasedBudget *RuleBasedBudget `json:"ruleBasedBudget,omitempty"`

	// ServingStatus The status of the campaign.
	ServingStatus *CampaignResponseExServingStatus `json:"servingStatus,omitempty"`

	// StartDate The YYYYMMDD start date of the campaign. The date must be today or in the future.
	StartDate *string `json:"startDate,omitempty"`

	// State The state of the campaign.
	State *CampaignResponseExState `json:"state,omitempty"`

	// Tactic The advertising tactic associated with the campaign. The following table lists available tactic names:
	// |Tactic Name|Type|Description|
	// |-----------|-----|-----------|
	// |T00020     |Contextual targeting | Choose individual products to show your ads in placements related to those products.<br> Choose individual categories to show your ads in placements related to those categories on and off Amazon.|
	// |T00030     |Audiences targeting | Select individual audiences to show your ads.|
	Tactic *Tactic `json:"tactic,omitempty"`
}

// CampaignResponseExBudgetType The time period over which the amount specified in the `budget` property is allocated.
type CampaignResponseExBudgetType string

// CampaignResponseExCostType Determines how the campaign will bid and charge.
// |Name|Description|
// |----|----------|-----------|
// |cpc |[Default] The performance of this campaign is measured by the clicks triggered by the ad.|
// |vcpm|The performance of this campaign is measured by the viewed impressions triggered by the ad. $1 is the minimum bid for vCPM.|
type CampaignResponseExCostType string

// CampaignResponseExServingStatus The status of the campaign.
type CampaignResponseExServingStatus string

// CampaignResponseExState The state of the campaign.
type CampaignResponseExState string

// ComparisonOperator The comparison operator.
type ComparisonOperator string

// CreateAdGroup defines model for CreateAdGroup.
type CreateAdGroup struct {
	// BidOptimization Bid Optimization for the Adgroup. Default behavior is to optimize for clicks.
	// |Name|CostType|Description|
	// |----|--------|-----------|
	// |reach |vcpm|Optimize for viewable impressions. $1 is the minimum bid for vCPM.|
	// |clicks |cpc|[Default] Optimize for page visits.|
	// |conversions |cpc|Optimize for conversion.|
	BidOptimization *CreateAdGroupBidOptimization `json:"bidOptimization,omitempty"`

	// CampaignId The identifier of the campaign.
	CampaignId *CampaignId `json:"campaignId,omitempty"`

	// CreativeType The type of the associated creative. If the field is empty or null, a default value of IMAGE will be used. One ad group only supports one type (VIDEO or IMAGE) of creativeType at a time.
	// |Name|Description|
	// |----|-----------|
	// |IMAGE |The creative will display static assets (e.g. headline, brandLogo or custom image).|
	// |VIDEO |The creative will display video assets. This type of creative must have a video asset provided. Only supported when using productAds with ASIN or SKU.|
	CreativeType *CreativeType `json:"creativeType"`

	// DefaultBid The amount of the default bid associated with the ad group. Used if no bid is specified.
	DefaultBid *float64 `json:"defaultBid,omitempty"`

	// Name The name of the ad group.
	Name *string `json:"name,omitempty"`

	// State The state of the ad group.
	State *CreateAdGroupState `json:"state,omitempty"`
}

// CreateAdGroupBidOptimization Bid Optimization for the Adgroup. Default behavior is to optimize for clicks.
// |Name|CostType|Description|
// |----|--------|-----------|
// |reach |vcpm|Optimize for viewable impressions. $1 is the minimum bid for vCPM.|
// |clicks |cpc|[Default] Optimize for page visits.|
// |conversions |cpc|Optimize for conversion.|
type CreateAdGroupBidOptimization string

// CreateAdGroupState The state of the ad group.
type CreateAdGroupState string

// CreateAssociatedOptimizationRulesRequest defines model for CreateAssociatedOptimizationRulesRequest.
type CreateAssociatedOptimizationRulesRequest struct {
	// OptimizationRuleIds A list of optimization rule identifiers.
	OptimizationRuleIds *[]RuleId `json:"optimizationRuleIds,omitempty"`
}

// CreateBudgetRulesResponse defines model for CreateBudgetRulesResponse.
type CreateBudgetRulesResponse struct {
	Responses *[]BudgetRuleResponse `json:"responses,omitempty"`
}

// CreateCampaign defines model for CreateCampaign.
type CreateCampaign struct {
	// Budget The amount of the budget.
	Budget *float64 `json:"budget,omitempty"`

	// BudgetType The time period over which the amount specified in the `budget` property is allocated.
	BudgetType *CreateCampaignBudgetType `json:"budgetType,omitempty"`

	// CostType Determines how the campaign will bid and charge.
	// |Name|Description|
	// |----|----------|
	// |cpc |[Default] The performance of this campaign is measured by the clicks triggered by the ad.|
	// |vcpm |The performance of this campaign is measured by the viewed impressions triggered by the ad. |
	//
	// To view minimum and maximum bids based on the costType, see [Limits](https://advertising.amazon.com/API/docs/en-us/concepts/limits#bid-constraints-by-marketplace).
	CostType *CreateCampaignCostType `json:"costType,omitempty"`

	// EndDate The YYYYMMDD end date of the campaign.
	EndDate *string `json:"endDate"`

	// Name The name of the campaign.
	Name *string `json:"name,omitempty"`

	// PortfolioId Identifier of the portfolio that will be associated with the campaign. If null then the campaign will be disassociated from existing portfolio. Campaigns with CPC and vCPM costType are supported.
	PortfolioId *int64 `json:"portfolioId"`

	// StartDate The YYYYMMDD start date of the campaign. The date must be today or in the future.
	StartDate *string `json:"startDate,omitempty"`

	// State The state of the campaign.
	State *CreateCampaignState `json:"state,omitempty"`

	// Tactic The advertising tactic associated with the campaign. The following table lists available tactic names:
	// |Tactic Name|Type|Description|
	// |-----------|-----|-----------|
	// |T00020     |Contextual targeting | Choose individual products to show your ads in placements related to those products.<br> Choose individual categories to show your ads in placements related to those categories on and off Amazon.|
	// |T00030     |Audiences targeting | Select individual audiences to show your ads.|
	Tactic *Tactic `json:"tactic,omitempty"`
}

// CreateCampaignBudgetType The time period over which the amount specified in the `budget` property is allocated.
type CreateCampaignBudgetType string

// CreateCampaignCostType Determines how the campaign will bid and charge.
// |Name|Description|
// |----|----------|
// |cpc |[Default] The performance of this campaign is measured by the clicks triggered by the ad.|
// |vcpm |The performance of this campaign is measured by the viewed impressions triggered by the ad. |
//
// To view minimum and maximum bids based on the costType, see [Limits](https://advertising.amazon.com/API/docs/en-us/concepts/limits#bid-constraints-by-marketplace).
type CreateCampaignCostType string

// CreateCampaignState The state of the campaign.
type CreateCampaignState string

// CreateCreative Creative create model.
type CreateCreative struct {
	// AdGroupId Unqiue identifier for the ad group associated with the creative.
	AdGroupId float32 `json:"adGroupId"`

	// CreativeType The type of the creative.
	// |Name|Description|
	// |----|-----------|
	// |IMAGE |The creative will display static assets (e.g. headline, brandLogo or custom image).|
	// |VIDEO |The creative will display video assets. This type of creative must have video assets provided. Only supported when using productAds with ASIN or SKU.|
	CreativeType *CreativeTypeInCreativeRequest `json:"creativeType"`

	// Properties Select customizations on your creative from any combination of headline, logo, and custom image.
	Properties CreativeProperties `json:"properties"`
}

// CreateLocation defines model for CreateLocation.
type CreateLocation struct {
	// AdGroupId The identifier of the ad group.
	AdGroupId *AdGroupId `json:"adGroupId,omitempty"`

	// Expression The location definition.
	Expression *[]LocationExpression `json:"expression,omitempty"`
	State      *CreateLocationState  `json:"state,omitempty"`
}

// CreateLocationState defines model for CreateLocation.State.
type CreateLocationState string

// CreateNegativeTargetingClause defines model for CreateNegativeTargetingClause.
type CreateNegativeTargetingClause struct {
	// AdGroupId The identifier of the ad group.
	AdGroupId *AdGroupId `json:"adGroupId,omitempty"`

	// Expression The expression to negatively match against.
	// * Only one brand may be specified per targeting expression.
	// * Only one asin may be specified per targeting expression.
	// * To exclude a brand from a targeting expression, you must create a negative targeting expression in the same ad group as the positive targeting expression.
	Expression     *[]NegativeTargetingExpression               `json:"expression,omitempty"`
	ExpressionType *CreateNegativeTargetingClauseExpressionType `json:"expressionType,omitempty"`
	State          *CreateNegativeTargetingClauseState          `json:"state,omitempty"`
}

// CreateNegativeTargetingClauseExpressionType defines model for CreateNegativeTargetingClause.ExpressionType.
type CreateNegativeTargetingClauseExpressionType string

// CreateNegativeTargetingClauseState defines model for CreateNegativeTargetingClause.State.
type CreateNegativeTargetingClauseState string

// CreateOptimizationRule defines model for CreateOptimizationRule.
type CreateOptimizationRule = BaseOptimizationRule

// CreateProductAd defines model for CreateProductAd.
type CreateProductAd struct {
	// AdGroupId The identifier of the ad group.
	AdGroupId *AdGroupId `json:"adGroupId,omitempty"`

	// AdName The name of the ad. Note that this field is not supported when using ASIN or SKU fields.
	AdName *AdName `json:"adName,omitempty"`

	// Asin The ASIN of the product advertised by the product ad.
	Asin *string `json:"asin,omitempty"`

	// CampaignId The identifier of the campaign.
	CampaignId *CampaignId `json:"campaignId,omitempty"`

	// LandingPageType The type of the landingPage used. This field is completely optional and will be set in conjunction with the LandingPageURL to indicate the type of landing page that will be set. This field is not supported when using ASIN or SKU fields.
	LandingPageType *LandingPageType `json:"landingPageType,omitempty"`

	// LandingPageURL The URL where customers will land after clicking on its link. Must be provided if a LandingPageType is set. Please note that if a single product ad sets the landing page url, only one product ad can be added to the ad group. This field is not supported when using ASIN or SKU fields.
	// ||Specifications|
	// |------------------|------------------|
	// |LandingPageType| Description|
	// |STORE| Not yet supported. The url should be in the format of https://www.amazon.com/stores/* (using a correct Amazon url based on the marketplace)|
	// |MOMENT| Not yet supported. The url should be in the format of https://www.amazon.com/moments/promotion/{campaignId} (using a correct Amazon url based on the marketplace)|
	// |OFF_AMAZON_LINK| The url should be in the format of https://www.****.com. Note that this LandingPageType is not supported when using ASIN or SKU fields. A custom creative of headline, logo, image are require for this LandingPageType. |
	LandingPageURL *LandingPageURL `json:"landingPageURL,omitempty"`

	// Sku The SKU of the product advertised by the product ad.
	Sku *string `json:"sku,omitempty"`

	// State The state of the campaign associated with the product ad.
	State *CreateProductAdState `json:"state,omitempty"`
}

// CreateProductAdState The state of the campaign associated with the product ad.
type CreateProductAdState string

// CreateSDBudgetRulesRequest defines model for CreateSDBudgetRulesRequest.
type CreateSDBudgetRulesRequest struct {
	// BudgetRulesDetails A list of budget rule details.
	BudgetRulesDetails *[]SDBudgetRuleDetails `json:"budgetRulesDetails,omitempty"`
}

// CreateTargetingClause defines model for CreateTargetingClause.
type CreateTargetingClause struct {
	// AdGroupId The identifier of the ad group.
	AdGroupId *AdGroupId `json:"adGroupId,omitempty"`

	// Bid The bid will override the adGroup bid if specified. This field is not used for negative targeting clauses. The bid must be less than the maximum allowable bid for the campaign's marketplace; for a list of maximum allowable bids, find the ["Bid constraints by marketplace" table in our documentation overview](https://advertising.amazon.com/API/docs/en-us/concepts/limits#bid-constraints-by-marketplace). You cannot manually set a bid when the targeting clause's adGroup has an enabled optimization rule.
	Bid *float32 `json:"bid"`

	// Expression The targeting expression to match against.
	//
	// ------- Applicable to contextual targeting (T00020) -------
	// * A 'TargetingExpression' in a contextual targeting campaign can only contain 'TargetingPredicate' components.
	// * Expressions must specify either a category predicate or an ASIN predicate, but never both.
	// * Only one category may be specified per targeting expression.
	// * Only one brand may be specified per targeting expression.
	// * Only one asin may be specified per targeting expression.
	// * To exclude a brand from a targeting expression you must create a negative targeting expression in the same ad group as the positive targeting expression.
	//
	// ------- Applicable to audience targeting (T00030) -------
	// * A 'TargetingExpression' in an audience campaign can only contain 'TargetingPredicateNested' components.
	// * Expressions must specify either auto ASIN-grain (exact products), manual ASIN-grain (similar products), or manual category-grain targeting.
	Expression *CreateTargetingExpression `json:"expression,omitempty"`

	// ExpressionType Tactic T00020 ad groups only allow manual targeting.
	ExpressionType *CreateTargetingClauseExpressionType `json:"expressionType,omitempty"`
	State          *CreateTargetingClauseState          `json:"state,omitempty"`
}

// CreateTargetingClauseExpressionType Tactic T00020 ad groups only allow manual targeting.
type CreateTargetingClauseExpressionType string

// CreateTargetingClauseState defines model for CreateTargetingClause.State.
type CreateTargetingClauseState string

// CreateTargetingExpression The targeting expression to match against.
//
// ------- Applicable to contextual targeting (T00020) -------
// * A 'TargetingExpression' in a contextual targeting campaign can only contain 'TargetingPredicate' components.
// * Expressions must specify either a category predicate or an ASIN predicate, but never both.
// * Only one category may be specified per targeting expression.
// * Only one brand may be specified per targeting expression.
// * Only one asin may be specified per targeting expression.
// * To exclude a brand from a targeting expression you must create a negative targeting expression in the same ad group as the positive targeting expression.
//
// ------- Applicable to audience targeting (T00030) -------
// * A 'TargetingExpression' in an audience campaign can only contain 'TargetingPredicateNested' components.
// * Expressions must specify either auto ASIN-grain (exact products), manual ASIN-grain (similar products), or manual category-grain targeting.
type CreateTargetingExpression = []CreateTargetingExpression_Item

// CreateTargetingExpression_Item defines model for CreateTargetingExpression.Item.
type CreateTargetingExpression_Item struct {
	union json.RawMessage
}

// Creative Creative model.
type Creative struct {
	// AdGroupId The identifier of the ad group.
	AdGroupId AdGroupId `json:"adGroupId"`

	// CreativeId Unique identifier of the creative.
	CreativeId float32 `json:"creativeId"`

	// CreativeType
	// The type of the creative.
	// |Name|Description|
	// |----|-----------|
	// |IMAGE |The creative will display static assets (e.g. headline, brandLogo or custom image).|
	// |VIDEO |The creative will display video assets. This type of creative must have video assets provided.|
	CreativeType CreativeTypeInCreativeResponse `json:"creativeType"`

	// ModerationStatus The moderation status of the creative
	ModerationStatus CreativeModerationStatus `json:"moderationStatus"`

	// Properties Select customizations on your creative from any combination of headline, logo, and custom image.
	Properties CreativeProperties `json:"properties"`
}

// CreativeModerationStatus The moderation status of the creative
type CreativeModerationStatus string

// CreativeModeration System generated Creative moderation.
type CreativeModeration struct {
	// CreativeId Unique identifier of the creative.
	CreativeId float32 `json:"creativeId"`

	// CreativeType
	// The type of the creative.
	// |Name|Description|
	// |----|-----------|
	// |IMAGE |The creative will display static assets (e.g. headline, brandLogo or custom image).|
	// |VIDEO |The creative will display video assets. This type of creative must have video assets provided.|
	CreativeType CreativeTypeInCreativeResponse `json:"creativeType"`

	// EtaForModeration Expected date and time by which moderation will be complete.
	EtaForModeration time.Time `json:"etaForModeration"`

	// ModerationStatus The moderation status of the creative.
	// |Status|Description|
	// |------|-----------|
	// |APPROVED|Moderation for the creative is complete.|
	// |IN_PROGRESS|Moderation for the creative is in progress. The expected date and time for completion are specfied in the `etaForModeration` field.|
	// |REJECTED|The creative has failed moderation. Specific information about the content that violated policy is available in `policyViolations`.|
	ModerationStatus CreativeModerationModerationStatus `json:"moderationStatus"`

	// PolicyViolations A list of policy violations for a creative that has failed moderation.
	PolicyViolations []struct {
		// PolicyDescription A human-readable description of the policy.
		PolicyDescription *string `json:"policyDescription,omitempty"`

		// PolicyLinkUrl Address of the policy documentation. Follow the link to learn more about the specified policy.
		PolicyLinkUrl *string `json:"policyLinkUrl,omitempty"`

		// ViolatingBrandLogoContents Information about the brand logo that violates the specified policy.
		ViolatingBrandLogoContents *[]struct {
			ImageEvidences *[]struct {
				ViolatingImageCrop *struct {
					// Height The height of the content that violates the specfied policy within the image.
					Height *int `json:"height,omitempty"`

					// TopLeftX The top left X-coordinate of the content that violates the specfied policy within the image.
					TopLeftX *int `json:"topLeftX,omitempty"`

					// TopLeftY The top left Y-coordinate of the content that violates the specfied policy within the image.
					TopLeftY *int `json:"topLeftY,omitempty"`

					// Width The width of the content that violates the specfied policy within the image.
					Width *int `json:"width,omitempty"`
				} `json:"violatingImageCrop,omitempty"`
			} `json:"imageEvidences,omitempty"`

			// ReviewedImageUrl Address of the image reviewed during moderation.
			ReviewedImageUrl *string `json:"reviewedImageUrl,omitempty"`
		} `json:"violatingBrandLogoContents,omitempty"`

		// ViolatingCustomImageContents Information about the custom image that violates the specified policy.
		ViolatingCustomImageContents *[]struct {
			ImageEvidences *[]struct {
				ViolatingImageCrop *struct {
					// Height The height of the content that violates the specfied policy within the image.
					Height *int `json:"height,omitempty"`

					// TopLeftX The top left X-coordinate of the content that violates the specfied policy within the image.
					TopLeftX *int `json:"topLeftX,omitempty"`

					// TopLeftY The top left Y-coordinate of the content that violates the specfied policy within the image.
					TopLeftY *int `json:"topLeftY,omitempty"`

					// Width The width of the content that violates the specfied policy within the image.
					Width *int `json:"width,omitempty"`
				} `json:"violatingImageCrop,omitempty"`
			} `json:"imageEvidences,omitempty"`

			// ReviewedImageUrl Address of the image reviewed during moderation.
			ReviewedImageUrl *string `json:"reviewedImageUrl,omitempty"`
		} `json:"violatingCustomImageContents,omitempty"`

		// ViolatingHeadlineContents Information about the headline text that violates the specified policy.
		ViolatingHeadlineContents *[]struct {
			// ReviewedText The specific text reviewed during moderation.
			ReviewedText *string `json:"reviewedText,omitempty"`
			TextEvidence *[]struct {
				// ViolatingText The specific text determined to violate the specified policy in reviewedText
				ViolatingText         *string `json:"violatingText,omitempty"`
				ViolatingTextPosition *struct {
					// End Zero-based index into the text in reviewedText where the text specified in violatingText ends
					End *int `json:"end,omitempty"`

					// Start Zero-based index into the text in reviewedText where the text specified in violatingText starts
					Start *int `json:"start,omitempty"`
				} `json:"violatingTextPosition,omitempty"`
			} `json:"textEvidence,omitempty"`
		} `json:"violatingHeadlineContents,omitempty"`

		// ViolatingVideoContents Information about the video that violates the specified policy.
		ViolatingVideoContents *[]struct {
			// ReviewedVideoUrl Address of the video reviewed during moderation.
			ReviewedVideoUrl *string `json:"reviewedVideoUrl,omitempty"`
			VideoEvidences   *[]struct {
				ViolatingVideoPosition *struct {
					// End Time at which policy violation within the video asset ends.
					End *int `json:"end,omitempty"`

					// Start Time at which policy violation within video asset starts.
					Start *int `json:"start,omitempty"`
				} `json:"violatingVideoPosition,omitempty"`
			} `json:"videoEvidences,omitempty"`
		} `json:"violatingVideoContents,omitempty"`
	} `json:"policyViolations"`
}

// CreativeModerationModerationStatus The moderation status of the creative.
// |Status|Description|
// |------|-----------|
// |APPROVED|Moderation for the creative is complete.|
// |IN_PROGRESS|Moderation for the creative is in progress. The expected date and time for completion are specfied in the `etaForModeration` field.|
// |REJECTED|The creative has failed moderation. Specific information about the content that violated policy is available in `policyViolations`.|
type CreativeModerationModerationStatus string

// CreativePreviewConfiguration Optional configuration for creative preview.
type CreativePreviewConfiguration struct {
	// AdName The name of the ad. Note that this field is not supported when using ASIN or SKU fields.
	AdName *AdName `json:"adName,omitempty"`

	// IsMobile Preview the creative as if it is on a mobile environment.
	IsMobile *bool `json:"isMobile,omitempty"`

	// IsOnAmazon Preview the creative as if it is on an amazon site or third party site. The main difference is whether the preview will contain an AdChoices icon.
	IsOnAmazon *bool `json:"isOnAmazon,omitempty"`

	// LandingPageType The type of the landingPage used. This field is completely optional and will be set in conjunction with the LandingPageURL to indicate the type of landing page that will be set. This field is not supported when using ASIN or SKU fields.
	LandingPageType *LandingPageType `json:"landingPageType,omitempty"`

	// LandingPageURL The URL where customers will land after clicking on its link. Must be provided if a LandingPageType is set. Please note that if a single product ad sets the landing page url, only one product ad can be added to the ad group. This field is not supported when using ASIN or SKU fields.
	// ||Specifications|
	// |------------------|------------------|
	// |LandingPageType| Description|
	// |STORE| Not yet supported. The url should be in the format of https://www.amazon.com/stores/* (using a correct Amazon url based on the marketplace)|
	// |MOMENT| Not yet supported. The url should be in the format of https://www.amazon.com/moments/promotion/{campaignId} (using a correct Amazon url based on the marketplace)|
	// |OFF_AMAZON_LINK| The url should be in the format of https://www.****.com. Note that this LandingPageType is not supported when using ASIN or SKU fields. A custom creative of headline, logo, image are require for this LandingPageType. |
	LandingPageURL *LandingPageURL `json:"landingPageURL,omitempty"`

	// Products The products to preview. Currently only the first product is previewable.
	Products *[]struct {
		// Asin The ASIN of the product.
		Asin *string `json:"asin,omitempty"`
	} `json:"products,omitempty"`

	// Size The slot dimension to render the creative. Sponsored Display creatives are responsive to a limited list of width and height pairs, including 300x250, 650x130, 245x250, 414x125, 600x160, 600x300, 728x90, 980x55, 320x50, 970x250 and 270x150.
	Size *struct {
		Height *int `json:"height,omitempty"`
		Width  *int `json:"width,omitempty"`
	} `json:"size,omitempty"`
}

// CreativePreviewConfigurations defines model for CreativePreviewConfigurations.
type CreativePreviewConfigurations = []CreativePreviewConfiguration

// CreativePreviewRequest defines model for CreativePreviewRequest.
type CreativePreviewRequest struct {
	// Creative Creative model for preview.
	Creative PreviewCreativeModel `json:"creative"`

	// PreviewConfiguration Optional configuration for creative preview.
	PreviewConfiguration  CreativePreviewConfiguration   `json:"previewConfiguration"`
	PreviewConfigurations *CreativePreviewConfigurations `json:"previewConfigurations,omitempty"`
}

// CreativePreviewResponse defines model for CreativePreviewResponse.
type CreativePreviewResponse struct {
	PreviewHtml  string    `json:"previewHtml"`
	PreviewHtmls *[]string `json:"previewHtmls,omitempty"`
}

// CreativeProperties Select customizations on your creative from any combination of headline, logo, and custom image.
type CreativeProperties struct {
	union json.RawMessage
}

// CreativeResponse defines model for CreativeResponse.
type CreativeResponse struct {
	// Code The HTTP status code of the response.
	Code *string `json:"code,omitempty"`

	// CreativeId The identifier of the creative.
	CreativeId *float32 `json:"creativeId,omitempty"`

	// Description A human-readable description of the response.
	Description *string `json:"description,omitempty"`
}

// CreativeType The type of the associated creative. If the field is empty or null, a default value of IMAGE will be used. One ad group only supports one type (VIDEO or IMAGE) of creativeType at a time.
// |Name|Description|
// |----|-----------|
// |IMAGE |The creative will display static assets (e.g. headline, brandLogo or custom image).|
// |VIDEO |The creative will display video assets. This type of creative must have a video asset provided. Only supported when using productAds with ASIN or SKU.|
type CreativeType string

// CreativeTypeInCreativeRequest The type of the creative.
// |Name|Description|
// |----|-----------|
// |IMAGE |The creative will display static assets (e.g. headline, brandLogo or custom image).|
// |VIDEO |The creative will display video assets. This type of creative must have video assets provided. Only supported when using productAds with ASIN or SKU.|
type CreativeTypeInCreativeRequest string

// CreativeTypeInCreativeResponse
// The type of the creative.
// |Name|Description|
// |----|-----------|
// |IMAGE |The creative will display static assets (e.g. headline, brandLogo or custom image).|
// |VIDEO |The creative will display video assets. This type of creative must have video assets provided.|
type CreativeTypeInCreativeResponse string

// CreativeUpdate Creative update model.
type CreativeUpdate struct {
	// CreativeId Unique identifier of the creative.
	CreativeId float32 `json:"creativeId"`

	// CreativeType The type of the creative.
	// |Name|Description|
	// |----|-----------|
	// |IMAGE |The creative will display static assets (e.g. headline, brandLogo or custom image).|
	// |VIDEO |The creative will display video assets. This type of creative must have video assets provided. Only supported when using productAds with ASIN or SKU.|
	CreativeType *CreativeTypeInCreativeRequest `json:"creativeType"`

	// Properties Select customizations on your creative from any combination of headline, logo, and custom image.
	Properties CreativeProperties `json:"properties"`
}

// CustomImageCreativeProperties User-customizable properties of a custom image creative.
type CustomImageCreativeProperties struct {
	// LandscapeImages An optional collection of 16:9 landscape images which are displayed on the ad. This operation is a PREVIEW ONLY. This note will be removed once this functionality becomes available.
	LandscapeImages *[]Image `json:"landscapeImages,omitempty"`

	// PortraitImages An optional collection of 9:16 portrait images which are displayed on the ad. This operation is a PREVIEW ONLY. This note will be removed once this functionality becomes available.
	PortraitImages *[]Image `json:"portraitImages,omitempty"`

	// RectCustomImage This field denotes image which is displayed on the ad. This can either be a brand logo or a custom image. This field is optional and mutable. For custom image, both rectCustomImage and squareCustomImage should use the same asset id and asset version. Specific restrictions based on the Image type are listed in the following table.
	// |Image type|Maximum file size|Minimum width|Minimum height|Accepted file formats|
	// |------|-----------|-----------|-----------|-----------|
	// |Custom Image|5MB|1200|628|JPEG, JPG, PNG, GIF|
	// |Brand Logo|1MB|600|100|JPEG, JPG, PNG|
	// Note: For square custom images the cropped image should be 628x628 at minimum.
	RectCustomImage *Image `json:"rectCustomImage,omitempty"`

	// SquareCustomImage This field denotes image which is displayed on the ad. This can either be a brand logo or a custom image. This field is optional and mutable. For custom image, both rectCustomImage and squareCustomImage should use the same asset id and asset version. Specific restrictions based on the Image type are listed in the following table.
	// |Image type|Maximum file size|Minimum width|Minimum height|Accepted file formats|
	// |------|-----------|-----------|-----------|-----------|
	// |Custom Image|5MB|1200|628|JPEG, JPG, PNG, GIF|
	// |Brand Logo|1MB|600|100|JPEG, JPG, PNG|
	// Note: For square custom images the cropped image should be 628x628 at minimum.
	SquareCustomImage *Image `json:"squareCustomImage,omitempty"`

	// SquareImages An optional collection of 1:1 square images which are displayed on the ad. This operation is a PREVIEW ONLY. This note will be removed once this functionality becomes available.
	SquareImages *[]Image `json:"squareImages,omitempty"`
}

// DateRangeTypeRuleDuration Object representing date range type rule duration.
type DateRangeTypeRuleDuration struct {
	// EndDate The end date of the budget rule in YYYYMMDD format. The end date is inclusive. Required to be equal or greater than `startDate`.
	EndDate *string `json:"endDate,omitempty"`

	// StartDate The start date of the budget rule in YYYYMMDD format. The start date is inclusive. Required to be greater than or equal to current date.
	StartDate string `json:"startDate"`
}

// DayOfWeek The day of the week.
type DayOfWeek string

// Error The error response object.
type Error struct {
	// Code The HTTP status code of the response.
	Code *string `json:"code,omitempty"`

	// Details A human-readable description of the response.
	Details *string `json:"details,omitempty"`
}

// EventTypeRuleDuration Object representing event type rule duration.
type EventTypeRuleDuration struct {
	// EndDate The event end date in YYYYMMDD format. Read-only.
	EndDate *string `json:"endDate,omitempty"`

	// EventId The event identifier. This value is available from the budget rules recommendation API.
	EventId string `json:"eventId"`

	// EventName The event name. Read-only.
	EventName *string `json:"eventName,omitempty"`

	// StartDate The event start date in YYYYMMDD format. Read-only. Note that this field is present only for announced events.
	StartDate *string `json:"startDate,omitempty"`
}

// Forecast Forecast impressions, clicks, reach, or conversions.
type Forecast struct {
	// Metric Describes which metric is forecasted.
	// |Name|Description|
	// |-----------|------------------------|
	// |IMPRESSIONS|Available impressions|
	// |REACH      |[Preview only] Delivered viewable impressions|
	// |CLICKS     |[Preview only] Delivered page visits|
	// |CONVERSIONS|[Preview only] Delivered conversions|
	Metric *ForecastMetric `json:"metric,omitempty"`

	// Value Forecast range values.
	Value *ForecastRange `json:"value,omitempty"`
}

// ForecastMetric Describes which metric is forecasted.
// |Name|Description|
// |-----------|------------------------|
// |IMPRESSIONS|Available impressions|
// |REACH      |[Preview only] Delivered viewable impressions|
// |CLICKS     |[Preview only] Delivered page visits|
// |CONVERSIONS|[Preview only] Delivered conversions|
type ForecastMetric string

// ForecastRange Forecast range values.
type ForecastRange struct {
	Max *int64 `json:"max,omitempty"`
	Min *int64 `json:"min,omitempty"`
}

// GetSDBudgetRuleResponse defines model for GetSDBudgetRuleResponse.
type GetSDBudgetRuleResponse struct {
	BudgetRule *SDBudgetRule `json:"budgetRule,omitempty"`
}

// GetSDBudgetRulesForAdvertiserResponse defines model for GetSDBudgetRulesForAdvertiserResponse.
type GetSDBudgetRulesForAdvertiserResponse struct {
	// BudgetRulesForAdvertiserResponse A list of rules created by the advertiser.
	BudgetRulesForAdvertiserResponse *[]SDBudgetRule `json:"budgetRulesForAdvertiserResponse,omitempty"`

	// NextToken To retrieve the next page of results, call the same operation and specify this token in the request. If the `nextToken` field is empty, there are no further results.
	NextToken *string `json:"nextToken,omitempty"`
}

// HeadlineCreativeProperties User-customizable properties of a creative with headline.
type HeadlineCreativeProperties struct {
	// Headline A marketing phrase to display on the ad. This field is optional and mutable. Maximum number of characters allowed is 50.
	Headline *string `json:"headline,omitempty"`
}

// Image This field denotes image which is displayed on the ad. This can either be a brand logo or a custom image. This field is optional and mutable. For custom image, both rectCustomImage and squareCustomImage should use the same asset id and asset version. Specific restrictions based on the Image type are listed in the following table.
// |Image type|Maximum file size|Minimum width|Minimum height|Accepted file formats|
// |------|-----------|-----------|-----------|-----------|
// |Custom Image|5MB|1200|628|JPEG, JPG, PNG, GIF|
// |Brand Logo|1MB|600|100|JPEG, JPG, PNG|
// Note: For square custom images the cropped image should be 628x628 at minimum.
type Image struct {
	// AssetId The unique identifier of the image asset. This assetId comes from the Creative Asset Library.
	AssetId string `json:"assetId"`

	// AssetVersion The identifier of the particular image assetversion.
	AssetVersion string `json:"assetVersion"`

	// CroppingCoordinates Optional cropping coordinates to apply to the image.
	CroppingCoordinates *struct {
		// Height Pixel height of the cropping zone.
		Height int `json:"height"`

		// Left Pixel distance from the left edge of the cropping zone to the left edge of the original image.
		Left int `json:"left"`

		// Top Pixel distance from the top edge of the cropping zone to the top edge of the original image.
		Top int `json:"top"`

		// Width Pixel width of the cropping zone.
		Width int `json:"width"`
	} `json:"croppingCoordinates,omitempty"`
}

// LandingPageType The type of the landingPage used. This field is completely optional and will be set in conjunction with the LandingPageURL to indicate the type of landing page that will be set. This field is not supported when using ASIN or SKU fields.
type LandingPageType string

// LandingPageURL The URL where customers will land after clicking on its link. Must be provided if a LandingPageType is set. Please note that if a single product ad sets the landing page url, only one product ad can be added to the ad group. This field is not supported when using ASIN or SKU fields.
// ||Specifications|
// |------------------|------------------|
// |LandingPageType| Description|
// |STORE| Not yet supported. The url should be in the format of https://www.amazon.com/stores/* (using a correct Amazon url based on the marketplace)|
// |MOMENT| Not yet supported. The url should be in the format of https://www.amazon.com/moments/promotion/{campaignId} (using a correct Amazon url based on the marketplace)|
// |OFF_AMAZON_LINK| The url should be in the format of https://www.****.com. Note that this LandingPageType is not supported when using ASIN or SKU fields. A custom creative of headline, logo, image are require for this LandingPageType. |
type LandingPageURL = string

// Locale Locale string as described in [BCP 47](https://tools.ietf.org/html/bcp47). For example, `en-US`
type Locale string

// Location defines model for Location.
type Location struct {
	// AdGroupId The identifier of the ad group.
	AdGroupId *AdGroupId `json:"adGroupId,omitempty"`

	// Expression The Location definition.
	Expression *[]LocationExpression `json:"expression,omitempty"`

	// LocationExpressionId The identifier of the location.
	LocationExpressionId *LocationExpressionId `json:"locationExpressionId,omitempty"`

	// ResolvedExpression The human-readable location definition.
	ResolvedExpression *[]ResolvedLocationExpression `json:"resolvedExpression,omitempty"`
	State              *LocationState                `json:"state,omitempty"`
}

// LocationState defines model for Location.State.
type LocationState string

// LocationExpression defines model for LocationExpression.
type LocationExpression struct {
	// Type The location category.
	Type *LocationPredicate `json:"type,omitempty"`

	// Value The location identifier. Currently, this can correspond to either a 'city', 'state', 'dma', 'postal code', or 'country'. Its value is discoverable using the GET /locations API.
	Value *string `json:"value,omitempty"`
}

// LocationExpressionId The identifier of the location.
type LocationExpressionId = int64

// LocationPredicate The location category.
type LocationPredicate string

// LogoCreativeProperties User-customizable properties of a creative with a logo.
type LogoCreativeProperties struct {
	// BrandLogo This field denotes image which is displayed on the ad. This can either be a brand logo or a custom image. This field is optional and mutable. For custom image, both rectCustomImage and squareCustomImage should use the same asset id and asset version. Specific restrictions based on the Image type are listed in the following table.
	// |Image type|Maximum file size|Minimum width|Minimum height|Accepted file formats|
	// |------|-----------|-----------|-----------|-----------|
	// |Custom Image|5MB|1200|628|JPEG, JPG, PNG, GIF|
	// |Brand Logo|1MB|600|100|JPEG, JPG, PNG|
	// Note: For square custom images the cropped image should be 628x628 at minimum.
	BrandLogo *Image `json:"brandLogo,omitempty"`
}

// NegativeTargetingClause defines model for NegativeTargetingClause.
type NegativeTargetingClause struct {
	// AdGroupId The identifier of the ad group.
	AdGroupId *AdGroupId `json:"adGroupId,omitempty"`

	// Expression The expression to negatively match against.
	// * Only one brand may be specified per targeting expression.
	// * Only one asin may be specified per targeting expression.
	// * To exclude a brand from a targeting expression, you must create a negative targeting expression in the same ad group as the positive targeting expression.
	Expression     *[]NegativeTargetingExpression         `json:"expression,omitempty"`
	ExpressionType *NegativeTargetingClauseExpressionType `json:"expressionType,omitempty"`

	// ResolvedExpression The resolved negative targeting expression.
	ResolvedExpression *[]NegativeTargetingExpression `json:"resolvedExpression,omitempty"`
	State              *NegativeTargetingClauseState  `json:"state,omitempty"`
	TargetId           *TargetId                      `json:"targetId,omitempty"`
}

// NegativeTargetingClauseExpressionType defines model for NegativeTargetingClause.ExpressionType.
type NegativeTargetingClauseExpressionType string

// NegativeTargetingClauseState defines model for NegativeTargetingClause.State.
type NegativeTargetingClauseState string

// NegativeTargetingClauseEx defines model for NegativeTargetingClauseEx.
type NegativeTargetingClauseEx struct {
	AdGroupId *float32 `json:"adGroupId,omitempty"`

	// CreationDate Epoch date the target was created.
	CreationDate *int64 `json:"creationDate,omitempty"`

	// Expression The expression to negatively match against.
	// * Only one brand may be specified per targeting expression.
	// * Only one asin may be specified per targeting expression.
	// * To exclude a brand from a targeting expression, you must create a negative targeting expression in the same ad group as the positive targeting expression.
	Expression *[]struct {
		// Type The intent type. See the [targeting topic](https://advertising.amazon.com/help#GQCBASRVERXSARL3) in the Amazon Ads support center for more information.
		Type *NegativeTargetingClauseExExpressionType `json:"type,omitempty"`

		// Value The value to be negatively targeted. Used only in manual expressions.
		Value *string `json:"value,omitempty"`
	} `json:"expression,omitempty"`

	// LastUpdatedDate Epoch date of the last update to any property associated with the target.
	LastUpdatedDate      *int64                                         `json:"lastUpdatedDate,omitempty"`
	RenameExpressionType *NegativeTargetingClauseExRenameExpressionType `json:"renameExpressionType,omitempty"`

	// ServingStatus The status of the target.
	ServingStatus *NegativeTargetingClauseExServingStatus `json:"servingStatus,omitempty"`
	State         *NegativeTargetingClauseExState         `json:"state,omitempty"`
	TargetId      *float32                                `json:"targetId,omitempty"`
}

// NegativeTargetingClauseExExpressionType The intent type. See the [targeting topic](https://advertising.amazon.com/help#GQCBASRVERXSARL3) in the Amazon Ads support center for more information.
type NegativeTargetingClauseExExpressionType string

// NegativeTargetingClauseExRenameExpressionType defines model for NegativeTargetingClauseEx.RenameExpressionType.
type NegativeTargetingClauseExRenameExpressionType string

// NegativeTargetingClauseExServingStatus The status of the target.
type NegativeTargetingClauseExServingStatus string

// NegativeTargetingClauseExState defines model for NegativeTargetingClauseEx.State.
type NegativeTargetingClauseExState string

// NegativeTargetingExpression defines model for NegativeTargetingExpression.
type NegativeTargetingExpression struct {
	// Type The intent type. See the [targeting topic](https://advertising.amazon.com/help#GQCBASRVERXSARL3) in the Amazon Ads support center for more information.
	Type *NegativeTargetingExpressionType `json:"type,omitempty"`

	// Value The value to be negatively targeted. Used only in manual expressions.
	Value *string `json:"value,omitempty"`
}

// NegativeTargetingExpressionType The intent type. See the [targeting topic](https://advertising.amazon.com/help#GQCBASRVERXSARL3) in the Amazon Ads support center for more information.
type NegativeTargetingExpressionType string

// OptimizationRule defines model for OptimizationRule.
type OptimizationRule struct {
	// RuleConditions A list of rule conditions that define the advertiser's intent for the outcome of the rule. The rule uses 'AND' logic to combine every condition in this list, and will validate the combination when the rule is created or updated.
	RuleConditions *[]RuleCondition `json:"ruleConditions,omitempty"`

	// RuleId The identifier of the optimization rule.
	RuleId *RuleId `json:"ruleId,omitempty"`

	// RuleName The name of the optimization rule.
	RuleName *string `json:"ruleName,omitempty"`

	// State The state of the optimization rule.
	State *OptimizationRuleState `json:"state,omitempty"`
}

// OptimizationRuleState The state of the optimization rule.
type OptimizationRuleState string

// OptimizationRuleResponse defines model for OptimizationRuleResponse.
type OptimizationRuleResponse struct {
	// Code The HTTP status code of the response.
	Code *string `json:"code,omitempty"`

	// Description A human-readable description of the response.
	Description *string `json:"description,omitempty"`

	// RuleId The identifier of the optimization rule.
	RuleId *RuleId `json:"ruleId,omitempty"`
}

// PerformanceMeasureCondition defines model for PerformanceMeasureCondition.
type PerformanceMeasureCondition struct {
	// ComparisonOperator The comparison operator.
	ComparisonOperator ComparisonOperator `json:"comparisonOperator"`

	// MetricName The advertising performance metric.
	MetricName PerformanceMetric `json:"metricName"`

	// Threshold The performance threshold value.
	Threshold float64 `json:"threshold"`
}

// PerformanceMetric The advertising performance metric.
type PerformanceMetric string

// PerformanceMetricValue An object giving the name of the performance metric and its value when the rule was evaluated
type PerformanceMetricValue struct {
	// Name Name of the performance metric
	Name *string `json:"name,omitempty"`

	// Value Value of the performance metric
	Value *float64 `json:"value,omitempty"`
}

// PreviewCreativeModel Creative model for preview.
type PreviewCreativeModel struct {
	// CreativeType The type of the creative.
	// |Name|Description|
	// |----|-----------|
	// |IMAGE |The creative will display static assets (e.g. headline, brandLogo or custom image).|
	// |VIDEO |The creative will display video assets. This type of creative must have video assets provided. Only supported when using productAds with ASIN or SKU.|
	CreativeType *CreativeTypeInCreativeRequest `json:"creativeType"`

	// Properties Select customizations on your creative from any combination of headline, logo, and custom image.
	Properties *CreativeProperties `json:"properties,omitempty"`
}

// ProductAd defines model for ProductAd.
type ProductAd struct {
	// AdGroupId The identifier of the ad group.
	AdGroupId *AdGroupId `json:"adGroupId,omitempty"`

	// AdId The identifier of the product ad.
	AdId *AdId `json:"adId,omitempty"`

	// AdName The name of the ad. Note that this field is not supported when using ASIN or SKU fields.
	AdName *AdName `json:"adName,omitempty"`

	// Asin The Amazon ASIN of the product advertised by the product ad.
	Asin *string `json:"asin,omitempty"`

	// CampaignId The identifier of the campaign.
	CampaignId *CampaignId `json:"campaignId,omitempty"`

	// LandingPageType The type of the landingPage used. This field is completely optional and will be set in conjunction with the LandingPageURL to indicate the type of landing page that will be set. This field is not supported when using ASIN or SKU fields.
	LandingPageType *LandingPageType `json:"landingPageType,omitempty"`

	// LandingPageURL The URL where customers will land after clicking on its link. Must be provided if a LandingPageType is set. Please note that if a single product ad sets the landing page url, only one product ad can be added to the ad group. This field is not supported when using ASIN or SKU fields.
	// ||Specifications|
	// |------------------|------------------|
	// |LandingPageType| Description|
	// |STORE| Not yet supported. The url should be in the format of https://www.amazon.com/stores/* (using a correct Amazon url based on the marketplace)|
	// |MOMENT| Not yet supported. The url should be in the format of https://www.amazon.com/moments/promotion/{campaignId} (using a correct Amazon url based on the marketplace)|
	// |OFF_AMAZON_LINK| The url should be in the format of https://www.****.com. Note that this LandingPageType is not supported when using ASIN or SKU fields. A custom creative of headline, logo, image are require for this LandingPageType. |
	LandingPageURL *LandingPageURL `json:"landingPageURL,omitempty"`

	// Sku The Amazon SKU of the product advertised by the product ad.
	Sku *string `json:"sku,omitempty"`

	// State The state of the campaign associated with the product ad.
	State *ProductAdState `json:"state,omitempty"`
}

// ProductAdState The state of the campaign associated with the product ad.
type ProductAdState string

// ProductAdResponse defines model for ProductAdResponse.
type ProductAdResponse struct {
	// AdId The identifier of the ad.
	AdId *float32 `json:"adId,omitempty"`

	// Code The HTTP status code of the response.
	Code *string `json:"code,omitempty"`

	// Description A human-readable description of the response.
	Description *string `json:"description,omitempty"`
}

// ProductAdResponseEx defines model for ProductAdResponseEx.
type ProductAdResponseEx struct {
	// AdGroupId The identifier of the ad group associated with the ad.
	AdGroupId *float32 `json:"adGroupId,omitempty"`

	// AdId The identifier of the ad.
	AdId *float32 `json:"adId,omitempty"`

	// AdName The name of the ad. Note that this field is not supported when using ASIN or SKU fields.
	AdName *AdName `json:"adName,omitempty"`

	// Asin The ASIN of the product being advertised.
	Asin *string `json:"asin,omitempty"`

	// CampaignId The identifier of the campaign associated with the ad.
	CampaignId *float32 `json:"campaignId,omitempty"`

	// CreationDate Epoch date the product ad was created.
	CreationDate *int64 `json:"creationDate,omitempty"`

	// LandingPageType The type of the landingPage used. This field is completely optional and will be set in conjunction with the LandingPageURL to indicate the type of landing page that will be set. This field is not supported when using ASIN or SKU fields.
	LandingPageType *LandingPageType `json:"landingPageType,omitempty"`

	// LandingPageURL The URL where customers will land after clicking on its link. Must be provided if a LandingPageType is set. Please note that if a single product ad sets the landing page url, only one product ad can be added to the ad group. This field is not supported when using ASIN or SKU fields.
	// ||Specifications|
	// |------------------|------------------|
	// |LandingPageType| Description|
	// |STORE| Not yet supported. The url should be in the format of https://www.amazon.com/stores/* (using a correct Amazon url based on the marketplace)|
	// |MOMENT| Not yet supported. The url should be in the format of https://www.amazon.com/moments/promotion/{campaignId} (using a correct Amazon url based on the marketplace)|
	// |OFF_AMAZON_LINK| The url should be in the format of https://www.****.com. Note that this LandingPageType is not supported when using ASIN or SKU fields. A custom creative of headline, logo, image are require for this LandingPageType. |
	LandingPageURL *LandingPageURL `json:"landingPageURL,omitempty"`

	// LastUpdatedDate Epoch date of the last update to any property associated with the product ad.
	LastUpdatedDate *int64 `json:"lastUpdatedDate,omitempty"`

	// ServingStatus The status of the product ad.
	ServingStatus *ProductAdResponseExServingStatus `json:"servingStatus,omitempty"`

	// Sku The SKU of the product being advertised.
	Sku *string `json:"sku,omitempty"`

	// State The state of the product ad.
	State *ProductAdResponseExState `json:"state,omitempty"`
}

// ProductAdResponseExServingStatus The status of the product ad.
type ProductAdResponseExServingStatus string

// ProductAdResponseExState The state of the product ad.
type ProductAdResponseExState string

// Recurrence defines model for Recurrence.
type Recurrence struct {
	// DaysOfWeek Object representing days of the week for weekly type rule. It is not required for daily recurrence type
	DaysOfWeek *[]DayOfWeek `json:"daysOfWeek,omitempty"`

	// Type depicts the type of recurrence
	Type *RecurrenceType `json:"type,omitempty"`
}

// RecurrenceType depicts the type of recurrence
type RecurrenceType string

// ReportRequest defines model for ReportRequest.
type ReportRequest struct {
	// Metrics A comma-separated list of the metrics to be included in the report.
	//
	// Each report type supports different metrics. **To understand supported metrics for each report type, see [Report types](/API/docs/en-us/guides/reporting/v2/report-types).**
	//
	// **Note**: Campaigns with vCPM costType should use view+click based metrics (viewAttributedConversions14d, viewAttributedDetailPageView14d, viewAttributedSales14d, viewAttributedUnitsOrdered14d, viewImpressions).
	//
	// **Note**: Detail page view metrics (attributedDetailPageView14d, viewAttributedDetailPageView14d) have an SLA of 3 days.
	//
	// **Tip**: Use new-to-brand (NTB) metrics to calculate how efficient your campaigns are at driving new shoppers:
	//
	//   1. Percentage of NTB orders = attributedOrdersNewToBrand14d / attributedConversions14d
	//   2. Percentage NTB sales = attributedSalesNewToBrand14d / attributedSales14d
	//   3. Percentage NTB units = attributedUnitsOrderedNewToBrand14d / attributedUnitsOrdered14d
	//   4. NTB order rate = attributedOrdersNewToBrand14 / impressions
	Metrics *string `json:"metrics,omitempty"`

	// ReportDate Date in YYYYMMDD format. The report contains only metrics generated on the specified date. Note that the time zone used for date calculation is the one associated with the profile used to make the request.
	ReportDate *string `json:"reportDate,omitempty"`

	// Segment Optional. A dimension used to further segment certain types of reports.
	//
	// Note: matchedTarget reports only return targets that have generated at least one click.
	// | Dimension | Report types | Tactics | Metrics | Description |
	// |---------|------------------|-------------|-------------|------------|
	// | matchedTarget | campaigns, adGroups, targets | T00020, T00030 | Existing metrics for each report type are accepted. |  Segments a report based on the ASIN of the product page where the ad appeared.|
	Segment *Segment `json:"segment,omitempty"`

	// Tactic The advertising tactic associated with the campaign. The following table lists available tactic names:
	// |Tactic Name|Type|Description|
	// |-----------|-----|-----------|
	// |T00020     |Contextual targeting | Choose individual products to show your ads in placements related to those products.<br> Choose individual categories to show your ads in placements related to those categories on and off Amazon.|
	// |T00030     |Audiences targeting | Select individual audiences to show your ads.|
	Tactic *TacticReport `json:"tactic,omitempty"`
}

// ReportResponse defines model for ReportResponse.
type ReportResponse struct {
	// Expiration Epoch date of the expiration of the URI in the `location` property.
	Expiration *int64 `json:"expiration,omitempty"`

	// FileSize The size of the report file, in bytes.
	FileSize *int64 `json:"fileSize,omitempty"`

	// Location The URI location of the report.
	Location *string `json:"location,omitempty"`

	// RecordType The type of report requested.
	RecordType *ReportResponseRecordType `json:"recordType,omitempty"`

	// ReportId The identifier of the report.
	ReportId *string `json:"reportId,omitempty"`

	// Status The build status of the report.
	Status *ReportResponseStatus `json:"status,omitempty"`

	// StatusDetails A human-readable description of the current status.
	StatusDetails *string `json:"statusDetails,omitempty"`
}

// ReportResponseRecordType The type of report requested.
type ReportResponseRecordType string

// ReportResponseStatus The build status of the report.
type ReportResponseStatus string

// ResolvedLocationExpression defines model for ResolvedLocationExpression.
type ResolvedLocationExpression struct {
	// Type The location category.
	Type *LocationPredicate `json:"type,omitempty"`

	// Value The human-readable location name.
	Value *string `json:"value,omitempty"`
}

// RuleBasedBudget defines model for RuleBasedBudget.
type RuleBasedBudget struct {
	ApplicableRuleId   *string  `json:"applicableRuleId,omitempty"`
	ApplicableRuleName *string  `json:"applicableRuleName,omitempty"`
	IsProcessing       *bool    `json:"isProcessing,omitempty"`
	Value              *float64 `json:"value,omitempty"`
}

// RuleCondition A rule condition that defines the advertiser's intent for the outcome of the rule.
// Certain actions are performed by the product to achieve and maintain the rule condition.
type RuleCondition struct {
	// ComparisonOperator The comparison operator.
	ComparisonOperator RuleConditionComparisonOperator `json:"comparisonOperator"`

	// MetricName The name of the metric.
	// Supported rule metrics and corresponding supported comparisonOperators:
	// |      MetricName      |ComparisonOperator  |Description|
	// |------------------|--------------------|-------------------|
	// |COST_PER_THOUSAND_VIEWABLE_IMPRESSIONS     |              LESS_THAN_OR_EQUAL_TO             |Maximize viewable impressions while cost per 1000 views less than or equal to `threshold`|
	// |COST_PER_ORDER    |              LESS_THAN_OR_EQUAL_TO            |Maximize viewable impressions/page visits/conversion while cost per order less than or equal to `threshold`|
	// |COST_PER_CLICK    |              LESS_THAN_OR_EQUAL_TO            |Maximize page visits while cost per click less than or equal to `threshold`|
	MetricName RuleConditionMetricName `json:"metricName"`

	// Threshold The value of the threshold associated with the metric. The threshold values has defined minimums depending on the metric names in the following table:
	// |                  MetricName            | Minimum of `threshold` Value  |
	// |----------------------------------------|-----------------------------------|
	// |COST_PER_THOUSAND_VIEWABLE_IMPRESSIONS  | 1                                 |
	// |COST_PER_ORDER                          | 3                                 |
	// |COST_PER_CLICK                          | 0.5                               |
	Threshold float64 `json:"threshold"`
}

// RuleConditionComparisonOperator The comparison operator.
type RuleConditionComparisonOperator string

// RuleConditionMetricName The name of the metric.
// Supported rule metrics and corresponding supported comparisonOperators:
// |      MetricName      |ComparisonOperator  |Description|
// |------------------|--------------------|-------------------|
// |COST_PER_THOUSAND_VIEWABLE_IMPRESSIONS     |              LESS_THAN_OR_EQUAL_TO             |Maximize viewable impressions while cost per 1000 views less than or equal to `threshold`|
// |COST_PER_ORDER    |              LESS_THAN_OR_EQUAL_TO            |Maximize viewable impressions/page visits/conversion while cost per order less than or equal to `threshold`|
// |COST_PER_CLICK    |              LESS_THAN_OR_EQUAL_TO            |Maximize page visits while cost per click less than or equal to `threshold`|
type RuleConditionMetricName string

// RuleDuration defines model for RuleDuration.
type RuleDuration struct {
	// DateRangeTypeRuleDuration Object representing date range type rule duration.
	DateRangeTypeRuleDuration *DateRangeTypeRuleDuration `json:"dateRangeTypeRuleDuration,omitempty"`

	// EventTypeRuleDuration Object representing event type rule duration.
	EventTypeRuleDuration *EventTypeRuleDuration `json:"eventTypeRuleDuration,omitempty"`
}

// RuleId The identifier of the optimization rule.
type RuleId = string

// SDASIN Amazon Standard Identification Number
type SDASIN = string

// SDAudience The audience identifier
type SDAudience = string

// SDAudienceCategory An audience category determines the goal of the audience such as In-market, Interest, Lifestyle and Life Event
type SDAudienceCategory string

// SDAudienceCategoryRecommendations List of recommended standard Amazon audience targets of a specific audience category
type SDAudienceCategoryRecommendations struct {
	// Audiences List of recommended standard Amazon audience targets
	Audiences *[]SDAudienceRecommendation `json:"audiences,omitempty"`

	// Category An audience category determines the goal of the audience such as In-market, Interest, Lifestyle and Life Event
	Category *SDAudienceCategory `json:"category,omitempty"`
}

// SDAudienceRecommendation A recommended standard Amazon audience to target ads on
type SDAudienceRecommendation struct {
	// Audience The audience identifier
	Audience *SDAudience `json:"audience,omitempty"`

	// Name The Amazon audience name
	Name *string `json:"name,omitempty"`

	// Rank A rank to signify which recommendations are weighed more heavily, with a lower rank signifying a stronger recommendation
	Rank *int `json:"rank,omitempty"`
}

// SDAudienceRecommendations defines model for SDAudienceRecommendations.
type SDAudienceRecommendations struct {
	// Audiences List of recommended audience targets, broken down by audience category
	Audiences *[]SDAudienceCategoryRecommendations `json:"audiences,omitempty"`
}

// SDBidOptimizationV32 Determines what the recommended bids will be optimized for.
//
// |Name|CostType|Description|
// |----|--------|-----------|
// |reach|vcpm|Optimize for viewable impressions. $1 is the minimum bid for vCPM.|
// |clicks|cpc|Optimize for page visits|
// |conversions|cpc|Optimize for conversion|
// |leads |cpc| [PREVIEW ONLY] Optimize for lead generation.|
type SDBidOptimizationV32 string

// SDBidRecommendationV31 A recommended bid range to use for a target.
type SDBidRecommendationV31 struct {
	// RangeLower The lowest recommended bid to use to win an ad placement for this target.
	RangeLower float32 `json:"rangeLower"`

	// RangeUpper The highest recommended bid to use to win an ad placement for this target.
	RangeUpper float32 `json:"rangeUpper"`

	// Recommended The recommended bid to use to win an ad placement for this target.
	Recommended float32 `json:"recommended"`
}

// SDBudgetHistory defines model for SDBudgetHistory.
type SDBudgetHistory struct {
	History *[]SDRuleBasedBudget `json:"history,omitempty"`
}

// SDBudgetRule defines model for SDBudgetRule.
type SDBudgetRule struct {
	// CreatedDate Epoch time of budget rule creation. Read-only.
	CreatedDate *int64 `json:"createdDate,omitempty"`

	// LastUpdatedDate Epoch time of budget rule update. Read-only.
	LastUpdatedDate *int64 `json:"lastUpdatedDate,omitempty"`

	// RuleDetails Object representing details of a budget rule for SD campaign
	RuleDetails *SDBudgetRuleDetails `json:"ruleDetails,omitempty"`

	// RuleId The budget rule identifier.
	RuleId string `json:"ruleId"`

	// RuleState The budget rule state.
	RuleState *State `json:"ruleState,omitempty"`

	// RuleStatus The budget rule status. Read-only.
	RuleStatus *string `json:"ruleStatus,omitempty"`
}

// SDBudgetRuleDetails Object representing details of a budget rule for SD campaign
type SDBudgetRuleDetails struct {
	BudgetIncreaseBy *BudgetIncreaseBy `json:"budgetIncreaseBy,omitempty"`
	Duration         *RuleDuration     `json:"duration,omitempty"`

	// Name The budget rule name. Required to be unique within a campaign.
	Name                        *string                      `json:"name,omitempty"`
	PerformanceMeasureCondition *PerformanceMeasureCondition `json:"performanceMeasureCondition,omitempty"`
	Recurrence                  *Recurrence                  `json:"recurrence,omitempty"`

	// RuleType The type of budget rule. SCHEDULE: A budget rule based on a start and end date. PERFORMANCE: A budget rule based on advertising performance criteria.
	RuleType *SDRuleType `json:"ruleType,omitempty"`
}

// SDCategory The category identifier
type SDCategory = int

// SDCategoryRecommendation A recommended category to target ads on
type SDCategoryRecommendation struct {
	// Category The category identifier
	Category *SDCategory `json:"category,omitempty"`

	// Name The category name
	Name *string `json:"name,omitempty"`

	// Path The path of the category within the category catalogue.
	Path *[]string `json:"path,omitempty"`

	// Rank A rank to signify which recommendations are weighed more heavily, with a lower rank signifying a stronger recommendation
	Rank *int `json:"rank,omitempty"`

	// TargetableAsinCountRange The range of ASINs available within the category catalogue. If no targetable ASIN counts are available then the targetableAsinCountRange value will be null without any properties.
	TargetableAsinCountRange *struct {
		RangeLower *int `json:"rangeLower,omitempty"`
		RangeUpper *int `json:"rangeUpper,omitempty"`
	} `json:"targetableAsinCountRange,omitempty"`
}

// SDCategoryRecommendationV33 A recommended category to target ads on
type SDCategoryRecommendationV33 struct {
	// Category The category identifier
	Category *SDCategory `json:"category,omitempty"`

	// Name The category name
	Name *string `json:"name,omitempty"`

	// Path The path of the category within the category catalogue.
	Path *[]string `json:"path,omitempty"`

	// Rank A rank to signify which recommendations are weighed more heavily, with a lower rank signifying a stronger recommendation.
	Rank *int `json:"rank,omitempty"`

	// TargetableAsinCountRange The range of ASINs available within the category catalogue.
	TargetableAsinCountRange *struct {
		RangeLower *int `json:"rangeLower,omitempty"`
		RangeUpper *int `json:"rangeUpper,omitempty"`
	} `json:"targetableAsinCountRange,omitempty"`

	// TranslatedName The translated category name by requested locale, field will not be provided if locale is not provided or campaign localization service is down.
	TranslatedName *string `json:"translatedName,omitempty"`

	// TranslatedPath The translated path of the category within the category catalogue by requested locale, field will not be provided if locale is not provided or campaign localization is down.
	TranslatedPath *[]string `json:"translatedPath,omitempty"`
}

// SDCategoryRecommendations defines model for SDCategoryRecommendations.
type SDCategoryRecommendations struct {
	// Categories List of recommended category targets
	Categories *[]SDCategoryRecommendation `json:"categories,omitempty"`
}

// SDCategoryRecommendationsV33 defines model for SDCategoryRecommendationsV33.
type SDCategoryRecommendationsV33 struct {
	// Categories List of recommended category targets.
	Categories *[]SDCategoryRecommendationV33 `json:"categories,omitempty"`
}

// SDCostTypeV31 Determines what performance metric the bid recommendations will be optimized for.
// |Name|Description|
// |----|----------|-----------|
// |cpc|The bid recommendations will be optimized for clicks triggered by the ad.|
// |vcpm|The bid recommendations will be optimized for viewed impressions triggered by the ad. $1 is the minimum bid for vCPM.|
type SDCostTypeV31 string

// SDErrorResponse defines model for SDErrorResponse.
type SDErrorResponse struct {
	// Code The HTTP status code of the response.
	Code *string `json:"code,omitempty"`

	// Details A human-readable description of the response.
	Details *string `json:"details,omitempty"`
}

// SDForecastErrorResponse defines model for SDForecastErrorResponse.
type SDForecastErrorResponse struct {
	// Code The HTTP status code of the response.
	Code *string `json:"code,omitempty"`

	// Details A human-readable description of the response.
	Details *string `json:"details,omitempty"`
}

// SDForecastRequest Request payload for SD forecasting. Below are required and optional fields. Fields not listed will not impact forecast results.
// |Field              |Object            |Required|
// |-------------------|------------------|--------|
// |startDate          |Campaign          |required|
// |endDate            |Campaign          |optional|
// |bidOptimization    |AdGroup           |required|
// |defaultBid         |AdGroup           |optional|
// |asin               |ProductAds        |required for vendors|
// |sku                |ProductAds        |required for sellers|
// |bid                |TargetingClauses  |required when defaultBid is not set|
// |expression         |TargetingClauses  |required|
type SDForecastRequest struct {
	AdGroup  AdGroup  `json:"adGroup"`
	Campaign Campaign `json:"campaign"`

	// NegativeTargetingClauses A list of SD negative targeting clauses.
	NegativeTargetingClauses *[]NegativeTargetingClause `json:"negativeTargetingClauses,omitempty"`
	ProductAds               []ProductAd                `json:"productAds"`

	// TargetingClauses A list of SD targeting clauses.
	TargetingClauses []TargetingClause `json:"targetingClauses"`
}

// SDForecastResponse Response to a request for SD forecasting.
type SDForecastResponse struct {
	BidOptimization *string `json:"bidOptimization,omitempty"`

	// DailyForecasts Daily average forecasts.
	DailyForecasts *[]Forecast `json:"dailyForecasts,omitempty"`

	// LifetimeForecasts Forecasts for campaign start date and end date. Default end date is start date plus 7 days.
	LifetimeForecasts *[]Forecast `json:"lifetimeForecasts,omitempty"`

	// WeeklyForecasts Weekly average forecasts.
	WeeklyForecasts *[]Forecast `json:"weeklyForecasts,omitempty"`
}

// SDGoalProduct A product an advertisers wants to advertise. Recommendations will be made for specified goal products.
type SDGoalProduct struct {
	// Asin Amazon Standard Identification Number
	Asin SDASIN `json:"asin"`
}

// SDProductRecommendation A recommended product to target ads on
type SDProductRecommendation struct {
	// Asin Amazon Standard Identification Number
	Asin *SDASIN `json:"asin,omitempty"`

	// Rank A rank to signify which recommendations are weighed more heavily, with a lower rank signifying a stronger recommendation
	Rank *int `json:"rank,omitempty"`
}

// SDProductRecommendationV32 A recommended product to target ads on
type SDProductRecommendationV32 struct {
	// AdvertisedAsins The top advertised products this recommendation is made for.
	AdvertisedAsins *[]SDASIN `json:"advertisedAsins,omitempty"`

	// Asin Amazon Standard Identification Number
	Asin *SDASIN `json:"asin,omitempty"`

	// Rank A rank to signify which recommendations are weighed more heavily, with a lower rank signifying a stronger recommendation
	Rank *int `json:"rank,omitempty"`
}

// SDProductRecommendationsV31 defines model for SDProductRecommendationsV31.
type SDProductRecommendationsV31 struct {
	// Products List of recommended product targets
	Products *[]SDProductRecommendation `json:"products,omitempty"`
}

// SDProductRecommendationsV32 defines model for SDProductRecommendationsV32.
type SDProductRecommendationsV32 struct {
	// Products List of recommended product targets
	Products *[]SDProductRecommendationV32 `json:"products,omitempty"`
}

// SDProductTargetingRecommendationsSuccess Recommendation results for contextual targeting.
type SDProductTargetingRecommendationsSuccess struct {
	// Code HTTP status code 200 indicating a successful response for product recomendations.
	Code *string `json:"code,omitempty"`

	// Name The theme name specified in the request.
	Name *string `json:"name,omitempty"`

	// Recommendations A list of recommended products.
	Recommendations *[]SDProductRecommendationV32 `json:"recommendations,omitempty"`
}

// SDProductTargetingTheme Contextual targeting theme definitions.
type SDProductTargetingTheme struct {
	// Expression A list of expressions defining the contextual targeting theme. The list will define an AND operator on different expressions.
	// For example, asinPriceGreaterThan and asinReviewRatingLessThan can be used to request product recommendations
	// which are both with greater price and less review rating compared to the goal products.
	// Note: Currently the service only supports one item in the array.
	Expression []SDProductTargetingThemeExpression `json:"expression"`

	// Name This is the meaningful theme name which will be used as a unique identifier across various themes in the same request.
	// This identifier will also be used to map the recommendations back to the theme in the response body.
	// Note: the value for this field cannot be "default" as that's a reserved keyword in the system.
	Name string `json:"name"`
}

// SDProductTargetingThemeExpression The expression used to define the contextual targeting theme.
type SDProductTargetingThemeExpression struct {
	// Type The contextual targeting grammar used to define the targeting theme. Note asinAsBestSeller is currently not supported.
	Type SDProductTargetingThemeExpressionType `json:"type"`
}

// SDProductTargetingThemeExpressionType The contextual targeting grammar used to define the targeting theme. Note asinAsBestSeller is currently not supported.
type SDProductTargetingThemeExpressionType string

// SDRecommendationType Signifies a type of recommendation
type SDRecommendationType string

// SDRecommendationTypeV31 Signifies a type of recommendation
type SDRecommendationTypeV31 string

// SDRecommendationTypeV32 Signifies a type of recommendation. PRODUCT and CATEGORY are supported by tactic T00020. CATEGORY and AUDIENCE are supported by tactic T00030.
type SDRecommendationTypeV32 string

// SDRuleBasedBudget defines model for SDRuleBasedBudget.
type SDRuleBasedBudget struct {
	AppliedRule *SDBudgetRule `json:"appliedRule,omitempty"`

	// DailyBudgetValue The daily budget value.
	DailyBudgetValue *float32 `json:"dailyBudgetValue,omitempty"`

	// ExecutionTime Epoch time of budget rule execution.
	ExecutionTime *int64 `json:"executionTime,omitempty"`

	// PerformanceMetric An object giving the name of the performance metric and its value when the rule was evaluated
	PerformanceMetric *PerformanceMetricValue `json:"performanceMetric,omitempty"`

	// RuleBasedBudgetValue The budget value.
	RuleBasedBudgetValue *float32 `json:"ruleBasedBudgetValue,omitempty"`
}

// SDRuleType The type of budget rule. SCHEDULE: A budget rule based on a start and end date. PERFORMANCE: A budget rule based on advertising performance criteria.
type SDRuleType string

// SDTactic The advertising tactic associated with the campaign. The following table lists available tactic names:
// |Tactic Name|Type|Description|
//
//	|-----------|-----|-----------|
//	|T00020 &nbsp;    |Products&nbsp;| Products: Choose individual products to show your ads in placements related to those products.<br>Categories: Choose individual categories to show your ads in placements related to those categories.
type SDTactic string

// SDTacticV31 The advertising tactic associated with the campaign. The following table lists available tactic names:
// |Tactic Name|Type|Description|
//
//	|-----------|-----|-----------|
//	|T00020 &nbsp;    |Products&nbsp;| Products: Choose individual products to show your ads in placements related to those products.<br>Categories: Choose individual categories to show your ads in placements related to those categories.|
//	|T00030&nbsp;|Audiences &nbsp;|Select individual audiences to show your ads.|
type SDTacticV31 string

// SDTargetExpressionV31 defines model for SDTargetExpressionV31.
type SDTargetExpressionV31 struct {
	union json.RawMessage
}

// SDTargetingBidRecommendationsRequestV31 Request for targeting bid recommendations.
type SDTargetingBidRecommendationsRequestV31 struct {
	// Products A list of products to tailor bid recommendations for category and audience based targeting clauses.
	Products *[]SDGoalProduct `json:"products,omitempty"`

	// TargetingClauses A list of targeting clauses to receive bid recommendations for.
	TargetingClauses []struct {
		// TargetingClause The targeting clause
		TargetingClause SDTargetingClauseV31 `json:"targetingClause"`
	} `json:"targetingClauses"`
}

// SDTargetingBidRecommendationsRequestV32 Request for targeting bid recommendations.
type SDTargetingBidRecommendationsRequestV32 struct {
	// BidOptimization Determines what the recommended bids will be optimized for.
	//
	// |Name|CostType|Description|
	// |----|--------|-----------|
	// |reach|vcpm|Optimize for viewable impressions. $1 is the minimum bid for vCPM.|
	// |clicks|cpc|Optimize for page visits|
	// |conversions|cpc|Optimize for conversion|
	// |leads |cpc| [PREVIEW ONLY] Optimize for lead generation.|
	BidOptimization SDBidOptimizationV32 `json:"bidOptimization"`

	// CostType Determines what performance metric the bid recommendations will be optimized for.
	// |Name|Description|
	// |----|----------|-----------|
	// |cpc|The bid recommendations will be optimized for clicks triggered by the ad.|
	// |vcpm|The bid recommendations will be optimized for viewed impressions triggered by the ad. $1 is the minimum bid for vCPM.|
	CostType SDCostTypeV31 `json:"costType"`

	// Products A list of products to tailor bid recommendations for category and audience based targeting clauses.
	Products *[]SDGoalProduct `json:"products,omitempty"`

	// TargetingClauses A list of targeting clauses to receive bid recommendations for.
	TargetingClauses []struct {
		// TargetingClause The targeting clause
		TargetingClause SDTargetingClauseV31 `json:"targetingClause"`
	} `json:"targetingClauses"`
}

// SDTargetingBidRecommendationsResponseItemFailureV31 Failed bid recommendation response.
type SDTargetingBidRecommendationsResponseItemFailureV31 struct {
	// Code The HTTP status code of this item.
	Code string `json:"code"`

	// Details A human-readable description of this item on error.
	Details string `json:"details"`
}

// SDTargetingBidRecommendationsResponseItemSuccessV31 defines model for SDTargetingBidRecommendationsResponseItemSuccessV31.
type SDTargetingBidRecommendationsResponseItemSuccessV31 struct {
	// Code The HTTP status code of this item.
	Code *string `json:"code,omitempty"`

	// RangeLower The lowest recommended bid to use to win an ad placement for this target.
	RangeLower float32 `json:"rangeLower"`

	// RangeUpper The highest recommended bid to use to win an ad placement for this target.
	RangeUpper float32 `json:"rangeUpper"`

	// Recommended The recommended bid to use to win an ad placement for this target.
	Recommended float32 `json:"recommended"`
}

// SDTargetingBidRecommendationsResponseV31 Response to a request for targeting bid recommendations.
type SDTargetingBidRecommendationsResponseV31 struct {
	BidRecommendations interface{} `json:"bidRecommendations"`

	// CostType Determines what performance metric the bid recommendations will be optimized for.
	// |Name|Description|
	// |----|----------|-----------|
	// |cpc|The bid recommendations will be optimized for clicks triggered by the ad.|
	// |vcpm|The bid recommendations will be optimized for viewed impressions triggered by the ad. $1 is the minimum bid for vCPM.|
	CostType SDCostTypeV31 `json:"costType"`
}

// SDTargetingBidRecommendationsResponseV32 Response to a request for targeting bid recommendations.
type SDTargetingBidRecommendationsResponseV32 struct {
	// BidOptimization Determines what the recommended bids will be optimized for.
	//
	// |Name|CostType|Description|
	// |----|--------|-----------|
	// |reach|vcpm|Optimize for viewable impressions. $1 is the minimum bid for vCPM.|
	// |clicks|cpc|Optimize for page visits|
	// |conversions|cpc|Optimize for conversion|
	// |leads |cpc| [PREVIEW ONLY] Optimize for lead generation.|
	BidOptimization    SDBidOptimizationV32 `json:"bidOptimization"`
	BidRecommendations interface{}          `json:"bidRecommendations"`

	// CostType Determines what performance metric the bid recommendations will be optimized for.
	// |Name|Description|
	// |----|----------|-----------|
	// |cpc|The bid recommendations will be optimized for clicks triggered by the ad.|
	// |vcpm|The bid recommendations will be optimized for viewed impressions triggered by the ad. $1 is the minimum bid for vCPM.|
	CostType SDCostTypeV31 `json:"costType"`
}

// SDTargetingClauseV31 The targeting clause
type SDTargetingClauseV31 struct {
	// Expression The targeting expression to match against.
	//
	// ------- Applicable to contextual targeting (T00020) -------
	// * A 'TargetingExpression' in a contextual targeting campaign can only contain 'TargetingPredicate' components.
	// * Expressions must specify either a category predicate or an ASIN predicate, but never both.
	// * Only one category may be specified per targeting expression.
	// * Only one brand may be specified per targeting expression.
	// * Only one asin may be specified per targeting expression.
	// * To exclude a brand from a targeting expression you must create a negative targeting expression in the same ad group as the positive targeting expression.
	//
	// ------- Applicable to audience targeting (T00030) -------
	// * A 'TargetingExpression' in an audience campaign can only contain 'TargetingPredicateNested' components.
	Expression SDTargetingExpressionV31 `json:"expression"`

	// ExpressionType Tactic T00020 ad groups only allow manual targeting.
	ExpressionType SDTargetingClauseV31ExpressionType `json:"expressionType"`
}

// SDTargetingClauseV31ExpressionType Tactic T00020 ad groups only allow manual targeting.
type SDTargetingClauseV31ExpressionType string

// SDTargetingExpressionV31 The targeting expression to match against.
//
// ------- Applicable to contextual targeting (T00020) -------
// * A 'TargetingExpression' in a contextual targeting campaign can only contain 'TargetingPredicate' components.
// * Expressions must specify either a category predicate or an ASIN predicate, but never both.
// * Only one category may be specified per targeting expression.
// * Only one brand may be specified per targeting expression.
// * Only one asin may be specified per targeting expression.
// * To exclude a brand from a targeting expression you must create a negative targeting expression in the same ad group as the positive targeting expression.
//
// ------- Applicable to audience targeting (T00030) -------
// * A 'TargetingExpression' in an audience campaign can only contain 'TargetingPredicateNested' components.
type SDTargetingExpressionV31 = []SDTargetExpressionV31

// SDTargetingPredicateBaseV31 A predicate to match against inside the TargetingPredicateNested component (only applicable to audience targeting - T00030).
//
// * All IDs passed for category and brand-targeting predicates must be valid IDs in the Amazon Ads browse system.
// * Brand, price, and review predicates are optional and may only be specified if category is also specified.
// * Review predicates accept numbers between 0 and 5 and are inclusive.
// * When using either of the 'between' strings to construct a targeting expression the format of the string is 'double-double' where the first double must be smaller than the second double. Prices are not inclusive.
// * The exactProduct, similarProduct, relatedProduct, and negative types do not utilize the value field.
// * The only type currently applicable to Amazon Audiences targeting is 'audienceSameAs'.
type SDTargetingPredicateBaseV31 struct {
	Type SDTargetingPredicateBaseV31Type `json:"type"`

	// Value The value to be targeted.
	Value *string `json:"value,omitempty"`
}

// SDTargetingPredicateBaseV31Type defines model for SDTargetingPredicateBaseV31.Type.
type SDTargetingPredicateBaseV31Type string

// SDTargetingPredicateNestedV31 A behavioral event and list of targeting predicates that represents an audience to target (only applicable to audience targeting - T00030).
//
// * For manual ASIN-grain targeting, the value array must contain only, 'exactProduct', 'similarProduct', 'relatedProduct' and 'lookback' TargetingPredicateBase components. The 'lookback' is mandatory and the value should be set to '7', '14', '30', '60', '90', '180' or '365'.
// * For manual Category-grain targeting, the value array must contain a 'lookback' and 'asinCategorySameAs' TargetingPredicateBase component, which can be further refined with optional brand, price, star-rating and shipping eligibility refinements. The 'lookback' is mandatory and the value should be set to '7', '14', '30', '60', '90', '180' or '365'.
// * For manual Category-grain targeting, the value array must contain a 'lookback' and 'asinCategorySameAs' TargetingPredicateBase component, which can be further refined with optional brand, price, star-rating and shipping eligibility refinements.
// * For Amazon Audiences targeting, the TargetingPredicateNested type should be set to 'audience' and the value array should include one TargetingPredicateBase component with type set to 'audienceSameAs'.
type SDTargetingPredicateNestedV31 struct {
	Type  SDTargetingPredicateNestedV31Type `json:"type"`
	Value []SDTargetingPredicateBaseV31     `json:"value"`
}

// SDTargetingPredicateNestedV31Type defines model for SDTargetingPredicateNestedV31.Type.
type SDTargetingPredicateNestedV31Type string

// SDTargetingPredicateV31 A predicate to match against in the Targeting Expression (only applicable to contextual targeting - T00020).
//
// * All IDs passed for category and brand-targeting predicates must be valid IDs in the Amazon Ads browse system.
// * Brand, price, and review predicates are optional and may only be specified if category is also specified.
// * Review predicates accept numbers between 0 and 5 and are inclusive.
// * When using either of the 'between' strings to construct a targeting expression the format of the string is 'double-double' where the first double must be smaller than the second double. Prices are not inclusive.
type SDTargetingPredicateV31 struct {
	Type SDTargetingPredicateV31Type `json:"type"`

	// Value The value to be targeted.
	Value *string `json:"value,omitempty"`
}

// SDTargetingPredicateV31Type defines model for SDTargetingPredicateV31.Type.
type SDTargetingPredicateV31Type string

// SDTargetingRecommendations A collection of targeting recommendations. Results will be sorted with strongest recommendations in the beginning.
type SDTargetingRecommendations struct {
	// Products List of recommended product targets
	Products *[]SDProductRecommendation `json:"products,omitempty"`
}

// SDTargetingRecommendationsFailure A targeting recommendation failure record.
type SDTargetingRecommendationsFailure struct {
	// Code HTTP status code indicating a failure response for targeting recomendations.
	Code *string `json:"code,omitempty"`

	// ErrorMessage A human friendly error message indicating the failure reasons.
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Name The theme name specified in the request. If the themes field is not provided in the request,
	// the value of this field will be set to default.
	Name *string `json:"name,omitempty"`
}

// SDTargetingRecommendationsLocale List of supported locales.
type SDTargetingRecommendationsLocale string

// SDTargetingRecommendationsProducts A list of products for which to get targeting recommendations
type SDTargetingRecommendationsProducts = []SDGoalProduct

// SDTargetingRecommendationsRequest Request for targeting recommendations
type SDTargetingRecommendationsRequest struct {
	// Products A list of products for which to get targeting recommendations
	Products []SDGoalProduct `json:"products"`

	// Tactic The advertising tactic associated with the campaign. The following table lists available tactic names:
	// |Tactic Name|Type|Description|
	//         |-----------|-----|-----------|
	//         |T00020 &nbsp;    |Products&nbsp;| Products: Choose individual products to show your ads in placements related to those products.<br>Categories: Choose individual categories to show your ads in placements related to those categories.
	Tactic SDTactic `json:"tactic"`

	// TypeFilter A filter to indicate which types of recommendations to request.
	TypeFilter []SDRecommendationType `json:"typeFilter"`
}

// SDTargetingRecommendationsRequestV31 Request for targeting recommendations
type SDTargetingRecommendationsRequestV31 struct {
	// Products A list of products for which to get targeting recommendations
	Products SDTargetingRecommendationsProducts `json:"products"`

	// Tactic The advertising tactic associated with the campaign. The following table lists available tactic names:
	// |Tactic Name|Type|Description|
	//         |-----------|-----|-----------|
	//         |T00020 &nbsp;    |Products&nbsp;| Products: Choose individual products to show your ads in placements related to those products.<br>Categories: Choose individual categories to show your ads in placements related to those categories.|
	//         |T00030&nbsp;|Audiences &nbsp;|Select individual audiences to show your ads.|
	Tactic SDTacticV31 `json:"tactic"`

	// TypeFilter A filter to indicate which types of recommendations to request.
	TypeFilter SDTargetingRecommendationsTypeFilterV31 `json:"typeFilter"`
}

// SDTargetingRecommendationsRequestV32 Request for targeting recommendations for API version 3.2.
type SDTargetingRecommendationsRequestV32 struct {
	// Products A list of products for which to get targeting recommendations
	Products SDTargetingRecommendationsProducts `json:"products"`

	// Tactic The advertising tactic associated with the campaign. The following table lists available tactic names:
	// |Tactic Name|Type|Description|
	//         |-----------|-----|-----------|
	//         |T00020 &nbsp;    |Products&nbsp;| Products: Choose individual products to show your ads in placements related to those products.<br>Categories: Choose individual categories to show your ads in placements related to those categories.|
	//         |T00030&nbsp;|Audiences &nbsp;|Select individual audiences to show your ads.|
	Tactic SDTacticV31 `json:"tactic"`

	// Themes The themes used to refine the recommendations. Currently only contextual targeting themes are supported.
	Themes *SDTargetingRecommendationsThemes `json:"themes,omitempty"`

	// TypeFilter A filter to indicate which types of recommendations to request.
	TypeFilter SDTargetingRecommendationsTypeFilterV31 `json:"typeFilter"`
}

// SDTargetingRecommendationsRequestV33 Request for targeting recommendations for API version 3.3.
type SDTargetingRecommendationsRequestV33 struct {
	// Products A list of products for which to get targeting recommendations
	Products SDTargetingRecommendationsProducts `json:"products"`

	// Tactic The advertising tactic associated with the campaign. The following table lists available tactic names:
	// |Tactic Name|Type|Description|
	//         |-----------|-----|-----------|
	//         |T00020 &nbsp;    |Products&nbsp;| Products: Choose individual products to show your ads in placements related to those products.<br>Categories: Choose individual categories to show your ads in placements related to those categories.|
	//         |T00030&nbsp;|Audiences &nbsp;|Select individual audiences to show your ads.|
	Tactic SDTacticV31 `json:"tactic"`

	// Themes The themes used to refine the recommendations. Currently only contextual targeting themes are supported.
	Themes *SDTargetingRecommendationsThemes `json:"themes,omitempty"`

	// TypeFilter A filter to indicate which types of recommendations to request.
	TypeFilter SDTargetingRecommendationsTypeFilterV32 `json:"typeFilter"`
}

// SDTargetingRecommendationsResponse Response to a request for targeting recommendations.
type SDTargetingRecommendationsResponse struct {
	// Recommendations A collection of targeting recommendations. Results will be sorted with strongest recommendations in the beginning.
	Recommendations *SDTargetingRecommendations `json:"recommendations,omitempty"`
}

// SDTargetingRecommendationsResponseV31 Response to a request for targeting recommendations.
type SDTargetingRecommendationsResponseV31 struct {
	Recommendations *SDTargetingRecommendationsV31 `json:"recommendations,omitempty"`
}

// SDTargetingRecommendationsResponseV32 Response to a request for targeting recommendations.
type SDTargetingRecommendationsResponseV32 struct {
	// Recommendations For v3.2 the service will continue to return the recommendations returned for v3.1 in products field, and return recommendations for contextual targeting themes in themes field.
	Recommendations *SDTargetingRecommendationsV32 `json:"recommendations,omitempty"`
}

// SDTargetingRecommendationsResponseV33 Response to a request for targeting recommendations.
type SDTargetingRecommendationsResponseV33 struct {
	// Recommendations For v3.3 the service will continue to return the recommendations returned for v3.2, and return audience recommendations if requested.
	Recommendations *SDTargetingRecommendationsV33 `json:"recommendations,omitempty"`
}

// SDTargetingRecommendationsThemes The themes used to refine the recommendations. Currently only contextual targeting themes are supported.
type SDTargetingRecommendationsThemes struct {
	// Product A list of themes for product targeting recommendations. If this list is empty, the service will return all the current available theme recommendations. Recommendations will be returned for each theme. If specified, each theme should only include unique expressions.
	Product *[]SDProductTargetingTheme `json:"product,omitempty"`
}

// SDTargetingRecommendationsTypeFilterV31 A filter to indicate which types of recommendations to request.
type SDTargetingRecommendationsTypeFilterV31 = []SDRecommendationTypeV31

// SDTargetingRecommendationsTypeFilterV32 A filter to indicate which types of recommendations to request.
type SDTargetingRecommendationsTypeFilterV32 = []SDRecommendationTypeV32

// SDTargetingRecommendationsV31 defines model for SDTargetingRecommendationsV31.
type SDTargetingRecommendationsV31 struct {
	// Categories List of recommended category targets
	Categories *[]SDCategoryRecommendation `json:"categories,omitempty"`

	// Products List of recommended product targets
	Products *[]SDProductRecommendation `json:"products,omitempty"`
}

// SDTargetingRecommendationsV32 defines model for SDTargetingRecommendationsV32.
type SDTargetingRecommendationsV32 struct {
	// Categories List of recommended category targets
	Categories *[]SDCategoryRecommendation `json:"categories,omitempty"`

	// Products List of recommended product targets
	Products *[]SDProductRecommendationV32 `json:"products,omitempty"`
	Themes   *struct {
		// Products A list of contextual targeting theme recommendations.
		Products *[]SDTargetingRecommendationsV32_Themes_Products_Item `json:"products,omitempty"`
	} `json:"themes,omitempty"`
}

// SDTargetingRecommendationsV32_Themes_Products_Item defines model for SDTargetingRecommendationsV32.Themes.Products.Item.
type SDTargetingRecommendationsV32_Themes_Products_Item struct {
	union json.RawMessage
}

// SDTargetingRecommendationsV33 defines model for SDTargetingRecommendationsV33.
type SDTargetingRecommendationsV33 struct {
	// Audiences List of recommended audience targets, broken down by audience category
	Audiences *[]SDAudienceCategoryRecommendations `json:"audiences,omitempty"`

	// Categories List of recommended category targets.
	Categories *[]SDCategoryRecommendationV33 `json:"categories,omitempty"`

	// Products List of recommended product targets
	Products *[]SDProductRecommendationV32 `json:"products,omitempty"`
	Themes   *struct {
		// Products A list of contextual targeting theme recommendations.
		Products *[]SDTargetingRecommendationsV33_Themes_Products_Item `json:"products,omitempty"`
	} `json:"themes,omitempty"`
}

// SDTargetingRecommendationsV33_Themes_Products_Item defines model for SDTargetingRecommendationsV33.Themes.Products.Item.
type SDTargetingRecommendationsV33_Themes_Products_Item struct {
	union json.RawMessage
}

// SDThemeRecommendations defines model for SDThemeRecommendations.
type SDThemeRecommendations struct {
	Themes *struct {
		// Products A list of contextual targeting theme recommendations.
		Products *[]SDThemeRecommendations_Themes_Products_Item `json:"products,omitempty"`
	} `json:"themes,omitempty"`
}

// SDThemeRecommendations_Themes_Products_Item defines model for SDThemeRecommendations.Themes.Products.Item.
type SDThemeRecommendations_Themes_Products_Item struct {
	union json.RawMessage
}

// Segment Optional. A dimension used to further segment certain types of reports.
//
// Note: matchedTarget reports only return targets that have generated at least one click.
// | Dimension | Report types | Tactics | Metrics | Description |
// |---------|------------------|-------------|-------------|------------|
// | matchedTarget | campaigns, adGroups, targets | T00020, T00030 | Existing metrics for each report type are accepted. |  Segments a report based on the ASIN of the product page where the ad appeared.|
type Segment string

// SnapshotRequest defines model for SnapshotRequest.
type SnapshotRequest struct {
	// StateFilter Optional. Restricts results to entities with state within the specified comma-separated list. Default behavior is to include 'enabled' and 'paused'. You can include 'enabled', 'paused', and 'archived' or any combination.
	StateFilter *SnapshotRequestStateFilter `json:"stateFilter,omitempty"`

	// TacticFilter Optional. Restricts results to entities with the advertising tactic associated with the campaign. Must be one of the following table lists available tactic names:
	// |Tactic Name|Type|Description|
	// |-----------|-----|-----------|
	// |T00020     |Contextual targeting | Choose individual products to show your ads in placements related to those products.<br> Choose individual categories to show your ads in placements related to those categories on and off Amazon.|
	// |T00030     |Audiences targeting | Select individual audiences to show your ads.|
	TacticFilter *TacticFilter `json:"tacticFilter,omitempty"`
}

// SnapshotRequestStateFilter Optional. Restricts results to entities with state within the specified comma-separated list. Default behavior is to include 'enabled' and 'paused'. You can include 'enabled', 'paused', and 'archived' or any combination.
type SnapshotRequestStateFilter string

// SnapshotResponse defines model for SnapshotResponse.
type SnapshotResponse struct {
	// Expiration The epoch time for expiration of the snapshot file and each snapshot file will be expired in 30 mins after generated. It's only available if status is SUCCESS.
	Expiration *float32 `json:"expiration,omitempty"`

	// FileSize The size of the snapshot file in bytes. It's only available if status is SUCCESS.
	FileSize *float32 `json:"fileSize,omitempty"`

	// Location The URI for the snapshot. It's only available if status is SUCCESS.
	Location *string `json:"location,omitempty"`

	// RecordType The record type of the snapshot file.
	RecordType *SnapshotResponseRecordType `json:"recordType,omitempty"`

	// SnapshotId The identifier of the snapshot that was requested.
	SnapshotId *string `json:"snapshotId,omitempty"`

	// Status The status of the generation of the snapshot.
	Status *SnapshotResponseStatus `json:"status,omitempty"`

	// StatusDetails Optional description of the status.
	StatusDetails *string `json:"statusDetails,omitempty"`
}

// SnapshotResponseRecordType The record type of the snapshot file.
type SnapshotResponseRecordType string

// SnapshotResponseStatus The status of the generation of the snapshot.
type SnapshotResponseStatus string

// Tactic The advertising tactic associated with the campaign. The following table lists available tactic names:
// |Tactic Name|Type|Description|
// |-----------|-----|-----------|
// |T00020     |Contextual targeting | Choose individual products to show your ads in placements related to those products.<br> Choose individual categories to show your ads in placements related to those categories on and off Amazon.|
// |T00030     |Audiences targeting | Select individual audiences to show your ads.|
type Tactic string

// TacticFilter Optional. Restricts results to entities with the advertising tactic associated with the campaign. Must be one of the following table lists available tactic names:
// |Tactic Name|Type|Description|
// |-----------|-----|-----------|
// |T00020     |Contextual targeting | Choose individual products to show your ads in placements related to those products.<br> Choose individual categories to show your ads in placements related to those categories on and off Amazon.|
// |T00030     |Audiences targeting | Select individual audiences to show your ads.|
type TacticFilter string

// TacticReport The advertising tactic associated with the campaign. The following table lists available tactic names:
// |Tactic Name|Type|Description|
// |-----------|-----|-----------|
// |T00020     |Contextual targeting | Choose individual products to show your ads in placements related to those products.<br> Choose individual categories to show your ads in placements related to those categories on and off Amazon.|
// |T00030     |Audiences targeting | Select individual audiences to show your ads.|
type TacticReport string

// TargetId defines model for TargetId.
type TargetId = int64

// TargetResponse defines model for TargetResponse.
type TargetResponse struct {
	// Code The HTTP status code of the response.
	Code *string `json:"code,omitempty"`

	// Description A human-readable description of the response.
	Description *string   `json:"description,omitempty"`
	TargetId    *TargetId `json:"targetId,omitempty"`
}

// TargetingClause defines model for TargetingClause.
type TargetingClause struct {
	// AdGroupId The identifier of the ad group.
	AdGroupId *AdGroupId `json:"adGroupId,omitempty"`

	// Bid The bid will override the adGroup bid if specified. This field is not used for negative targeting clauses. The bid must be less than the maximum allowable bid for the campaign's marketplace; for a list of maximum allowable bids, find the ["Bid constraints by marketplace" table in our documentation overview](https://advertising.amazon.com/API/docs/en-us/concepts/limits#bid-constraints-by-marketplace). You cannot manually set a bid when the targeting clause's adGroup has an enabled optimization rule.
	Bid *float32 `json:"bid"`

	// Expression The targeting expression to match against.
	//
	// ------- Applicable to contextual targeting (T00020) -------
	// * A 'TargetingExpression' in a contextual targeting campaign can only contain 'TargetingPredicate' components.
	// * Expressions must specify either a category predicate or an ASIN predicate, but never both.
	// * Only one category may be specified per targeting expression.
	// * Only one brand may be specified per targeting expression.
	// * Only one asin may be specified per targeting expression.
	// * To exclude a brand from a targeting expression you must create a negative targeting expression in the same ad group as the positive targeting expression.
	//
	// ------- Applicable to audience targeting (T00030) -------
	// * A 'TargetingExpression' in an audience campaign can only contain 'TargetingPredicateNested' components.
	// * Expressions must specify ASIN-grain ('exactProduct'), manual ASIN-grain ('relatedProducts' or 'relatedProducts'), or category-grain targeting.
	Expression *TargetingExpression `json:"expression,omitempty"`

	// ExpressionType Tactic T00020 & T00030 ad groups should use 'manual' targeting.
	ExpressionType *TargetingClauseExpressionType `json:"expressionType,omitempty"`

	// ResolvedExpression The targeting expression to match against.
	//
	// ------- Applicable to contextual targeting (T00020) -------
	// * A 'TargetingExpression' in a contextual targeting campaign can only contain 'TargetingPredicate' components.
	// * Expressions must specify either a category predicate or an ASIN predicate, but never both.
	// * Only one category may be specified per targeting expression.
	// * Only one brand may be specified per targeting expression.
	// * Only one asin may be specified per targeting expression.
	// * To exclude a brand from a targeting expression you must create a negative targeting expression in the same ad group as the positive targeting expression.
	//
	// ------- Applicable to audience targeting (T00030) -------
	// * A 'TargetingExpression' in an audience campaign can only contain 'TargetingPredicateNested' components.
	// * Expressions must specify ASIN-grain ('exactProduct'), manual ASIN-grain ('relatedProducts' or 'relatedProducts'), or category-grain targeting.
	ResolvedExpression *TargetingExpression  `json:"resolvedExpression,omitempty"`
	State              *TargetingClauseState `json:"state,omitempty"`
	TargetId           *TargetId             `json:"targetId,omitempty"`
}

// TargetingClauseExpressionType Tactic T00020 & T00030 ad groups should use 'manual' targeting.
type TargetingClauseExpressionType string

// TargetingClauseState defines model for TargetingClause.State.
type TargetingClauseState string

// TargetingClauseEx defines model for TargetingClauseEx.
type TargetingClauseEx struct {
	AdGroupId *float32 `json:"adGroupId,omitempty"`

	// Bid If a value for `bid` is specified, it overrides the current adGroup bid. When using vcpm costType. $1 is the minimum bid for vCPM. Note that this field is ignored for negative targeting clauses.
	Bid *float32 `json:"bid,omitempty"`

	// CreationDate Epoch date the target was created.
	CreationDate *int64 `json:"creationDate,omitempty"`

	// Expression The targeting expression to match against.
	//
	// ------- Applicable to contextual targeting (T00020) -------
	// * A 'TargetingExpression' in a contextual targeting campaign can only contain 'TargetingPredicate' components.
	// * Expressions must specify either a category predicate or an ASIN predicate, but never both.
	// * Only one category may be specified per targeting expression.
	// * Only one brand may be specified per targeting expression.
	// * Only one asin may be specified per targeting expression.
	// * To exclude a brand from a targeting expression you must create a negative targeting expression in the same ad group as the positive targeting expression.
	//
	// ------- Applicable to audience targeting (T00030) -------
	// * A 'TargetingExpression' in an audience campaign can only contain 'TargetingPredicateNested' components.
	// * Expressions must specify ASIN-grain ('exactProduct'), manual ASIN-grain ('relatedProducts' or 'relatedProducts'), or category-grain targeting.
	Expression     *TargetingExpression             `json:"expression,omitempty"`
	ExpressionType *TargetingClauseExExpressionType `json:"expressionType,omitempty"`

	// LastUpdatedDate Epoch date of the last update to any property associated with the target.
	LastUpdatedDate *int64 `json:"lastUpdatedDate,omitempty"`

	// ResolvedExpression The targeting expression to match against.
	//
	// ------- Applicable to contextual targeting (T00020) -------
	// * A 'TargetingExpression' in a contextual targeting campaign can only contain 'TargetingPredicate' components.
	// * Expressions must specify either a category predicate or an ASIN predicate, but never both.
	// * Only one category may be specified per targeting expression.
	// * Only one brand may be specified per targeting expression.
	// * Only one asin may be specified per targeting expression.
	// * To exclude a brand from a targeting expression you must create a negative targeting expression in the same ad group as the positive targeting expression.
	//
	// ------- Applicable to audience targeting (T00030) -------
	// * A 'TargetingExpression' in an audience campaign can only contain 'TargetingPredicateNested' components.
	// * Expressions must specify ASIN-grain ('exactProduct'), manual ASIN-grain ('relatedProducts' or 'relatedProducts'), or category-grain targeting.
	ResolvedExpression *TargetingExpression `json:"resolvedExpression,omitempty"`

	// ServingStatus The status of the target.
	ServingStatus *TargetingClauseExServingStatus `json:"servingStatus,omitempty"`
	State         *TargetingClauseExState         `json:"state,omitempty"`
	TargetId      *float32                        `json:"targetId,omitempty"`
}

// TargetingClauseExExpressionType defines model for TargetingClauseEx.ExpressionType.
type TargetingClauseExExpressionType string

// TargetingClauseExServingStatus The status of the target.
type TargetingClauseExServingStatus string

// TargetingClauseExState defines model for TargetingClauseEx.State.
type TargetingClauseExState string

// TargetingExpression The targeting expression to match against.
//
// ------- Applicable to contextual targeting (T00020) -------
// * A 'TargetingExpression' in a contextual targeting campaign can only contain 'TargetingPredicate' components.
// * Expressions must specify either a category predicate or an ASIN predicate, but never both.
// * Only one category may be specified per targeting expression.
// * Only one brand may be specified per targeting expression.
// * Only one asin may be specified per targeting expression.
// * To exclude a brand from a targeting expression you must create a negative targeting expression in the same ad group as the positive targeting expression.
//
// ------- Applicable to audience targeting (T00030) -------
// * A 'TargetingExpression' in an audience campaign can only contain 'TargetingPredicateNested' components.
// * Expressions must specify ASIN-grain ('exactProduct'), manual ASIN-grain ('relatedProducts' or 'relatedProducts'), or category-grain targeting.
type TargetingExpression = []TargetingExpression_Item

// TargetingExpression_Item defines model for TargetingExpression.Item.
type TargetingExpression_Item struct {
	union json.RawMessage
}

// TargetingPredicate A predicate to match against in the targeting expression (only applicable to contextual targeting - T00020).
//
// * All IDs passed for category and brand-targeting predicates must be valid IDs in the Amazon Ads browse system.
// * Brand, price, and review predicates are optional and may only be specified if category is also specified.
// * Review predicates accept numbers between 0 and 5 and are inclusive.
// * When using either of the 'between' strings to construct a targeting expression the format of the string is 'double-double' where the first double must be smaller than the second double. Prices are not inclusive.
type TargetingPredicate struct {
	Type *TargetingPredicateType `json:"type,omitempty"`

	// Value The value to be targeted.
	Value *string `json:"value,omitempty"`
}

// TargetingPredicateType defines model for TargetingPredicate.Type.
type TargetingPredicateType string

// TargetingPredicateBase A predicate to match against inside the TargetingPredicateNested component (only applicable to audience targeting - T00030).
//
// * All IDs passed for category and brand-targeting predicates must be valid IDs in the Amazon Ads browse system.
// * Brand, price, and review predicates are optional and may only be specified if category is also specified.
// * Review predicates accept numbers between 0 and 5 and are inclusive.
// * When using either of the 'between' strings to construct a targeting expression the format of the string is 'double-double' where the first double must be smaller than the second double. Prices are not inclusive.
// * The 'exactProduct', 'similarProduct', 'relatedProduct', and 'negative' types do not utilize the value field.
// * The only type currently applicable to Amazon Audiences targeting is 'audienceSameAs'.
// * A 'relatedProduct' TargetingPredicateBase will Target an audience that has purchased a related product in the past 7,14,30,60,90,180, or 365 days.
type TargetingPredicateBase struct {
	Type *TargetingPredicateBaseType `json:"type,omitempty"`

	// Value The value to be targeted.
	Value *string `json:"value,omitempty"`
}

// TargetingPredicateBaseType defines model for TargetingPredicateBase.Type.
type TargetingPredicateBaseType string

// TargetingPredicateLegacy defines model for TargetingPredicateLegacy.
type TargetingPredicateLegacy struct {
	// EventType The type of event that the value applies to. Only available for similarProduct and exactProduct currently.
	// * views event type corresponds to a customer who viewed the detail page of the product(s).
	EventType *TargetingPredicateLegacyEventType `json:"eventType,omitempty"`
	Type      *TargetingPredicateLegacyType      `json:"type,omitempty"`

	// Value The value to be targeted.
	Value *string `json:"value,omitempty"`
}

// TargetingPredicateLegacyEventType The type of event that the value applies to. Only available for similarProduct and exactProduct currently.
// * views event type corresponds to a customer who viewed the detail page of the product(s).
type TargetingPredicateLegacyEventType string

// TargetingPredicateLegacyType defines model for TargetingPredicateLegacy.Type.
type TargetingPredicateLegacyType string

// TargetingPredicateNested A behavioral event and list of targeting predicates that represents an audience to target (only applicable to audience targeting - T00030).
//
// * For manual ASIN-grain targeting, the value array must contain only, 'exactProduct', 'similarProduct', 'relatedProduct' and 'lookback' TargetingPredicateBase components. The 'lookback' is mandatory and the value should be set to '7', '14', '30', '60', '90', '180' or '365'.
// * For manual Category-grain targeting, the value array must contain a 'lookback' and 'asinCategorySameAs' TargetingPredicateBase component, which can be further refined with optional brand, price, star-rating and shipping eligibility refinements. The 'lookback' is mandatory and the value should be set to '7', '14', '30', '60', '90', '180' or '365'.
// * For Amazon Audiences targeting, the TargetingPredicateNested type should be set to 'audience' and the value array should include one TargetingPredicateBase component with type set to 'audienceSameAs'.
type TargetingPredicateNested struct {
	Type  *TargetingPredicateNestedType `json:"type,omitempty"`
	Value *[]TargetingPredicateBase     `json:"value,omitempty"`
}

// TargetingPredicateNestedType defines model for TargetingPredicateNested.Type.
type TargetingPredicateNestedType string

// UpdateAdGroup defines model for UpdateAdGroup.
type UpdateAdGroup struct {
	// AdGroupId The identifier of the ad group.
	AdGroupId *AdGroupId `json:"adGroupId,omitempty"`

	// BidOptimization Bid Optimization for the Adgroup. Default behavior is to optimize for clicks.
	// |Name|CostType|Description|
	// |----|--------|-----------|
	// |reach |vcpm|Optimize for viewable impressions. $1 is the minimum bid for vCPM.|
	// |clicks |cpc|[Default] Optimize for page visits.|
	// |conversions |cpc|Optimize for conversion.|
	BidOptimization *UpdateAdGroupBidOptimization `json:"bidOptimization,omitempty"`

	// CampaignId The identifier of the campaign.
	CampaignId *CampaignId `json:"campaignId,omitempty"`

	// DefaultBid The amount of the default bid associated with the ad group. Used if no bid is specified.
	DefaultBid *float64 `json:"defaultBid,omitempty"`

	// Name The name of the ad group.
	Name *string `json:"name,omitempty"`

	// State The state of the ad group.
	State *UpdateAdGroupState `json:"state,omitempty"`
}

// UpdateAdGroupBidOptimization Bid Optimization for the Adgroup. Default behavior is to optimize for clicks.
// |Name|CostType|Description|
// |----|--------|-----------|
// |reach |vcpm|Optimize for viewable impressions. $1 is the minimum bid for vCPM.|
// |clicks |cpc|[Default] Optimize for page visits.|
// |conversions |cpc|Optimize for conversion.|
type UpdateAdGroupBidOptimization string

// UpdateAdGroupState The state of the ad group.
type UpdateAdGroupState string

// UpdateBudgetRulesResponse defines model for UpdateBudgetRulesResponse.
type UpdateBudgetRulesResponse struct {
	Responses *[]BudgetRuleResponse `json:"responses,omitempty"`
}

// UpdateCampaign defines model for UpdateCampaign.
type UpdateCampaign struct {
	// Budget The amount of the budget.
	Budget *float64 `json:"budget,omitempty"`

	// BudgetType The time period over which the amount specified in the `budget` property is allocated.
	BudgetType *UpdateCampaignBudgetType `json:"budgetType,omitempty"`

	// CampaignId The identifier of the campaign.
	CampaignId *CampaignId `json:"campaignId,omitempty"`

	// CostType Determines how the campaign will bid and charge.
	// |Name|Description|
	// |----|----------|
	// |cpc |[Default] The performance of this campaign is measured by the clicks triggered by the ad.|
	// |vcpm |The performance of this campaign is measured by the viewed impressions triggered by the ad. |
	//
	// To view minimum and maximum bids based on the costType, see [Limits](https://advertising.amazon.com/API/docs/en-us/concepts/limits#bid-constraints-by-marketplace).
	CostType *UpdateCampaignCostType `json:"costType,omitempty"`

	// EndDate The YYYYMMDD end date of the campaign.
	EndDate *string `json:"endDate"`

	// Name The name of the campaign.
	Name *string `json:"name,omitempty"`

	// PortfolioId Identifier of the portfolio that will be associated with the campaign. If null then the campaign will be disassociated from existing portfolio. Campaigns with CPC and vCPM costType are supported.
	PortfolioId *int64 `json:"portfolioId"`

	// StartDate The YYYYMMDD start date of the campaign. The date must be today or in the future.
	StartDate *string `json:"startDate,omitempty"`

	// State The state of the campaign.
	State *UpdateCampaignState `json:"state,omitempty"`
}

// UpdateCampaignBudgetType The time period over which the amount specified in the `budget` property is allocated.
type UpdateCampaignBudgetType string

// UpdateCampaignCostType Determines how the campaign will bid and charge.
// |Name|Description|
// |----|----------|
// |cpc |[Default] The performance of this campaign is measured by the clicks triggered by the ad.|
// |vcpm |The performance of this campaign is measured by the viewed impressions triggered by the ad. |
//
// To view minimum and maximum bids based on the costType, see [Limits](https://advertising.amazon.com/API/docs/en-us/concepts/limits#bid-constraints-by-marketplace).
type UpdateCampaignCostType string

// UpdateCampaignState The state of the campaign.
type UpdateCampaignState string

// UpdateNegativeTargetingClause defines model for UpdateNegativeTargetingClause.
type UpdateNegativeTargetingClause struct {
	State    *UpdateNegativeTargetingClauseState `json:"state,omitempty"`
	TargetId *TargetId                           `json:"targetId,omitempty"`
}

// UpdateNegativeTargetingClauseState defines model for UpdateNegativeTargetingClause.State.
type UpdateNegativeTargetingClauseState string

// UpdateOptimizationRule defines model for UpdateOptimizationRule.
type UpdateOptimizationRule struct {
	// RuleConditions A list of rule conditions that define the advertiser's intent for the outcome of the rule. The rule uses 'AND' logic to combine every condition in this list, and will validate the combination when the rule is created or updated.
	RuleConditions *[]RuleCondition `json:"ruleConditions,omitempty"`

	// RuleId The identifier of the optimization rule.
	RuleId *RuleId `json:"ruleId,omitempty"`

	// RuleName The name of the optimization rule.
	RuleName *string `json:"ruleName,omitempty"`

	// State The state of the optimization rule.
	State *UpdateOptimizationRuleState `json:"state,omitempty"`
}

// UpdateOptimizationRuleState The state of the optimization rule.
type UpdateOptimizationRuleState string

// UpdateProductAd defines model for UpdateProductAd.
type UpdateProductAd struct {
	// AdId The identifier of the product ad.
	AdId *AdId `json:"adId,omitempty"`

	// State The state of the campaign associated with the product ad.
	State *UpdateProductAdState `json:"state,omitempty"`
}

// UpdateProductAdState The state of the campaign associated with the product ad.
type UpdateProductAdState string

// UpdateSDBudgetRulesRequest Request object for updating budget rule for SD campaign
type UpdateSDBudgetRulesRequest struct {
	// BudgetRulesDetails A list of budget rule details.
	BudgetRulesDetails *[]SDBudgetRule `json:"budgetRulesDetails,omitempty"`
}

// UpdateTargetingClause defines model for UpdateTargetingClause.
type UpdateTargetingClause struct {
	// Bid The bid will override the adGroup bid if specified. This field is not used for negative targeting clauses. The bid must be less than the maximum allowable bid for the campaign's marketplace; for a list of maximum allowable bids, find the ["Bid constraints by marketplace" table in our documentation overview](https://advertising.amazon.com/API/docs/en-us/concepts/limits#bid-constraints-by-marketplace). You cannot manually set a bid when the targeting clause's adGroup has an enabled optimization rule.
	Bid      *float32                    `json:"bid"`
	State    *UpdateTargetingClauseState `json:"state,omitempty"`
	TargetId *TargetId                   `json:"targetId,omitempty"`
}

// UpdateTargetingClauseState defines model for UpdateTargetingClause.State.
type UpdateTargetingClauseState string

// Video This field denotes video which is displayed on the ad. This field is optional and mutable. A video asset must be provided for a VIDEO creative. Specific restrictions based on the video are listed in the following table.
// ||Specifications|
// |------------------|------------------|
// |Maximum file size|500MB|
// |Aspect ratio|16:9|
// |Minimum duration|6s|
// |Maximum duration|45s|
// |Minimum frame size|1920x1080|
// |Minimum video bitrate|4mbps|
// |Video frame rate(fps)|23.976(recommended), 24, 25, or 29.97|
// |Video frame rate mode|Constant|
// |Minimum audio bitrate|192kbps|
// |Audio sample rate|44.1kHz or 48kHz|
// |Supported Formats|Video: H.264, MPEG-2, or MPEG-4; Audio: PCM or AAC|
// |Audio Channel|Audio format needs to be stereo or mono.|
// |Recommended video bitrate|8mbps|
// |Recommended duration|A duration of exactly 6s, 15s, 20s, or 30s is recommended. Use of videos outside of these durations may negatively impact your campaign performance. Shorter lengths will drive higher VCR (although scale on 6s may be limited).|
type Video struct {
	// AssetId The unique identifier of the video asset. This assetId comes from the Creative Asset Library.
	AssetId string `json:"assetId"`

	// AssetVersion The identifier of the particular video assetversion.
	AssetVersion string `json:"assetVersion"`
}

// VideoCreativeProperties User-customizable properties of a video creative.
type VideoCreativeProperties struct {
	// LandscapeVideos An optional collection of 16:9 landscape videos which are displayed on the ad. This operation is a PREVIEW ONLY. This note will be removed once this functionality becomes available.
	LandscapeVideos *[]Video `json:"landscapeVideos,omitempty"`

	// PortraitVideos An optional collection of 9:16 portrait videos which are displayed on the ad. This operation is a PREVIEW ONLY. This note will be removed once this functionality becomes available.
	PortraitVideos *[]Video `json:"portraitVideos,omitempty"`

	// SquareVideos An optional collection of 1:1 square videos which are displayed on the ad. This operation is a PREVIEW ONLY. This note will be removed once this functionality becomes available.
	SquareVideos *[]Video `json:"squareVideos,omitempty"`

	// Video This field denotes video which is displayed on the ad. This field is optional and mutable. A video asset must be provided for a VIDEO creative. Specific restrictions based on the video are listed in the following table.
	// ||Specifications|
	// |------------------|------------------|
	// |Maximum file size|500MB|
	// |Aspect ratio|16:9|
	// |Minimum duration|6s|
	// |Maximum duration|45s|
	// |Minimum frame size|1920x1080|
	// |Minimum video bitrate|4mbps|
	// |Video frame rate(fps)|23.976(recommended), 24, 25, or 29.97|
	// |Video frame rate mode|Constant|
	// |Minimum audio bitrate|192kbps|
	// |Audio sample rate|44.1kHz or 48kHz|
	// |Supported Formats|Video: H.264, MPEG-2, or MPEG-4; Audio: PCM or AAC|
	// |Audio Channel|Audio format needs to be stereo or mono.|
	// |Recommended video bitrate|8mbps|
	// |Recommended duration|A duration of exactly 6s, 15s, 20s, or 30s is recommended. Use of videos outside of these durations may negatively impact your campaign performance. Shorter lengths will drive higher VCR (although scale on 6s may be limited).|
	Video *Video `json:"video,omitempty"`
}

// BudgetIncreaseBy defines model for budgetIncreaseBy.
type BudgetIncreaseBy struct {
	// Type The value by which to update the budget of the budget rule.
	Type BudgetChangeType `json:"type"`

	// Value The budget value.
	Value float64 `json:"value"`
}

// State The budget rule state.
type State string

// ClientHeader defines model for clientHeader.
type ClientHeader = string

// ProfileHeader defines model for profileHeader.
type ProfileHeader = string

// ListAdGroupsParams defines parameters for ListAdGroups.
type ListAdGroupsParams struct {
	// StartIndex Optional. Sets a cursor into the requested set of campaigns. Use in conjunction with the `count` parameter to control pagination of the returned array. 0-indexed record offset for the result set, defaults to 0.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Count Optional. Sets the number of AdGroup objects in the returned array. Use in conjunction with the `startIndex` parameter to control pagination. For example, to return the first ten ad groups set `startIndex=0` and `count=10`. To return the next ten ad groups, set `startIndex=10` and `count=10`, and so on. Defaults to max page size.
	Count *int32 `form:"count,omitempty" json:"count,omitempty"`

	// StateFilter Optional. The returned array is filtered to include only ad groups with state set to one of the values in the specified comma-delimited list.
	StateFilter *ListAdGroupsParamsStateFilter `form:"stateFilter,omitempty" json:"stateFilter,omitempty"`

	// CampaignIdFilter Optional. The returned array is filtered to include only ad groups associated with the campaign identifiers in the specified comma-delimited list.
	CampaignIdFilter *string `form:"campaignIdFilter,omitempty" json:"campaignIdFilter,omitempty"`

	// AdGroupIdFilter Optional. The returned array is filtered to include only ad groups with an identifier specified in the comma-delimited list.
	AdGroupIdFilter *string `form:"adGroupIdFilter,omitempty" json:"adGroupIdFilter,omitempty"`

	// Name Optional. The returned array includes only ad groups with the specified name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ListAdGroupsParamsStateFilter defines parameters for ListAdGroups.
type ListAdGroupsParamsStateFilter string

// CreateAdGroupsJSONBody defines parameters for CreateAdGroups.
type CreateAdGroupsJSONBody = []CreateAdGroup

// CreateAdGroupsParams defines parameters for CreateAdGroups.
type CreateAdGroupsParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// UpdateAdGroupsJSONBody defines parameters for UpdateAdGroups.
type UpdateAdGroupsJSONBody = []UpdateAdGroup

// UpdateAdGroupsParams defines parameters for UpdateAdGroups.
type UpdateAdGroupsParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ListAdGroupsExParams defines parameters for ListAdGroupsEx.
type ListAdGroupsExParams struct {
	// StartIndex Optional. Sets a cursor into the requested set of ad groups. Use in conjunction with the `count` parameter to control pagination of the returned array. 0-indexed record offset for the result set, defaults to 0.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Count Optional. Sets the number of Campaign objects in the returned array. Use in conjunction with the `startIndex` parameter to control pagination. For example, to return the first ten campaigns set `startIndex=0` and `count=10`. To return the next ten campaigns, set `startIndex=10` and `count=10`, and so on. Defaults to max page size.
	Count *int32 `form:"count,omitempty" json:"count,omitempty"`

	// StateFilter Optional. The returned array is filtered to include only campaigns with state set to one of the values in the comma-delimited list.
	StateFilter *ListAdGroupsExParamsStateFilter `form:"stateFilter,omitempty" json:"stateFilter,omitempty"`

	// CampaignIdFilter Optional. The returned array is filtered to include only ad groups associated with the campaign identifiers in the comma-delimited list.
	CampaignIdFilter *string `form:"campaignIdFilter,omitempty" json:"campaignIdFilter,omitempty"`

	// AdGroupIdFilter Optional. The returned array is filtered to include only ad groups with an identifier specified in the comma-delimited list.
	AdGroupIdFilter *string `form:"adGroupIdFilter,omitempty" json:"adGroupIdFilter,omitempty"`

	// Name Optional. The returned array includes only ad groups with the specified name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ListAdGroupsExParamsStateFilter defines parameters for ListAdGroupsEx.
type ListAdGroupsExParamsStateFilter string

// GetAdGroupResponseExParams defines parameters for GetAdGroupResponseEx.
type GetAdGroupResponseExParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ArchiveAdGroupParams defines parameters for ArchiveAdGroup.
type ArchiveAdGroupParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// GetAdGroupParams defines parameters for GetAdGroup.
type GetAdGroupParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// GetSdAdGroupsAdGroupIdOptimizationRulesParams defines parameters for GetSdAdGroupsAdGroupIdOptimizationRules.
type GetSdAdGroupsAdGroupIdOptimizationRulesParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// AssociateOptimizationRulesWithAdGroupParams defines parameters for AssociateOptimizationRulesWithAdGroup.
type AssociateOptimizationRulesWithAdGroupParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// DeleteBrandSafetyDenyListParams defines parameters for DeleteBrandSafetyDenyList.
type DeleteBrandSafetyDenyListParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ListDomainsParams defines parameters for ListDomains.
type ListDomainsParams struct {
	// StartIndex Optional. Sets a cursor into the requested set of domains. Use in conjunction with the count parameter to control pagination of the returned array. 0-indexed record offset for the result set, defaults to 0.
	StartIndex *int `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Count Optional. Sets the number of domain objects in the returned array. Use in conjunction with the startIndex parameter to control pagination. For example, to return the first 1000 domains set startIndex=0 and count=1000. To return the next 1000 domains, set startIndex=1000 and count=1000, and so on. Defaults to max page size(1000).
	Count *int `form:"count,omitempty" json:"count,omitempty"`

	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// CreateBrandSafetyDenyListDomainsParams defines parameters for CreateBrandSafetyDenyListDomains.
type CreateBrandSafetyDenyListDomainsParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ListRequestStatusParams defines parameters for ListRequestStatus.
type ListRequestStatusParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// GetRequestResultsParams defines parameters for GetRequestResults.
type GetRequestResultsParams struct {
	// StartIndex Optional. Sets a cursor into the requested set of results. Use in conjunction with the count parameter to control pagination of the returned array. 0-indexed record offset for the result set, defaults to 0.
	StartIndex *int `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Count Optional. Sets the number of results in the returned array. Use in conjunction with the startIndex parameter to control pagination. For example, to return the first 1000 results set startIndex=0 and count=1000. To return the next 1000 results, set startIndex=1000 and count=1000, and so on. Defaults to max page size(1000).
	Count *int `form:"count,omitempty" json:"count,omitempty"`

	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// GetRequestStatusParams defines parameters for GetRequestStatus.
type GetRequestStatusParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// GetSDBudgetRulesForAdvertiserParams defines parameters for GetSDBudgetRulesForAdvertiser.
type GetSDBudgetRulesForAdvertiserParams struct {
	// NextToken To retrieve the next page of results, call the same operation and specify this token in the request. If the `nextToken` field is empty, there are no further results.
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// PageSize Sets a limit on the number of results returned. Maximum limit of `pageSize` is 30.
	PageSize float32 `form:"pageSize" json:"pageSize"`

	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account. This is a required header for advertisers and integrators using the Advertising API.
	AmazonAdvertisingAPIClientId string `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header. This is a required header for advertisers and integrators using the Advertising API.
	AmazonAdvertisingAPIScope string `json:"Amazon-Advertising-API-Scope"`
}

// CreateBudgetRulesForSDCampaignsParams defines parameters for CreateBudgetRulesForSDCampaigns.
type CreateBudgetRulesForSDCampaignsParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account. This is a required header for advertisers and integrators using the Advertising API.
	AmazonAdvertisingAPIClientId string `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header. This is a required header for advertisers and integrators using the Advertising API.
	AmazonAdvertisingAPIScope string `json:"Amazon-Advertising-API-Scope"`
}

// UpdateBudgetRulesForSDCampaignsParams defines parameters for UpdateBudgetRulesForSDCampaigns.
type UpdateBudgetRulesForSDCampaignsParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account. This is a required header for advertisers and integrators using the Advertising API.
	AmazonAdvertisingAPIClientId string `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header. This is a required header for advertisers and integrators using the Advertising API.
	AmazonAdvertisingAPIScope string `json:"Amazon-Advertising-API-Scope"`
}

// GetBudgetRuleByRuleIdForSDCampaignsParams defines parameters for GetBudgetRuleByRuleIdForSDCampaigns.
type GetBudgetRuleByRuleIdForSDCampaignsParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account. This is a required header for advertisers and integrators using the Advertising API.
	AmazonAdvertisingAPIClientId string `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header. This is a required header for advertisers and integrators using the Advertising API.
	AmazonAdvertisingAPIScope string `json:"Amazon-Advertising-API-Scope"`
}

// ListCampaignsParams defines parameters for ListCampaigns.
type ListCampaignsParams struct {
	// StartIndex Optional. Sets a cursor into the requested set of campaigns. Use in conjunction with the `count` parameter to control pagination of the returned array. 0-indexed record offset for the result set, defaults to 0.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Count Optional. Sets the number of Campaign objects in the returned array. Use in conjunction with the `startIndex` parameter to control pagination. For example, to return the first ten campaigns set `startIndex=0` and `count=10`. To return the next ten campaigns, set `startIndex=10` and `count=10`, and so on. Defaults to max page size.
	Count *int32 `form:"count,omitempty" json:"count,omitempty"`

	// StateFilter Optional. The returned array is filtered to include only campaigns with state set to one of the values in the specified comma-delimited list.
	StateFilter *ListCampaignsParamsStateFilter `form:"stateFilter,omitempty" json:"stateFilter,omitempty"`

	// Name Optional. The returned array includes only campaign with the specified name using an exact string match.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// CampaignIdFilter Optional. The returned array includes only campaigns with identifiers matching those specified in the comma-delimited string.
	CampaignIdFilter *string `form:"campaignIdFilter,omitempty" json:"campaignIdFilter,omitempty"`

	// PortfolioIdFilter Optional. The returned array includes only campaigns associated with Portfolio identifiers matching those specified in the comma-delimited string.
	PortfolioIdFilter *string `form:"portfolioIdFilter,omitempty" json:"portfolioIdFilter,omitempty"`

	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ListCampaignsParamsStateFilter defines parameters for ListCampaigns.
type ListCampaignsParamsStateFilter string

// CreateCampaignsJSONBody defines parameters for CreateCampaigns.
type CreateCampaignsJSONBody = []CreateCampaign

// CreateCampaignsParams defines parameters for CreateCampaigns.
type CreateCampaignsParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// UpdateCampaignsJSONBody defines parameters for UpdateCampaigns.
type UpdateCampaignsJSONBody = []UpdateCampaign

// UpdateCampaignsParams defines parameters for UpdateCampaigns.
type UpdateCampaignsParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// SdCampaignsBudgetUsageParams defines parameters for SdCampaignsBudgetUsage.
type SdCampaignsBudgetUsageParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account. This is a required header for advertisers and integrators using the Advertising API.
	AmazonAdvertisingAPIClientId interface{} `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header. This is a required header for advertisers and integrators using the Advertising API.
	AmazonAdvertisingAPIScope interface{} `json:"Amazon-Advertising-API-Scope"`
}

// ListCampaignsExParams defines parameters for ListCampaignsEx.
type ListCampaignsExParams struct {
	// StartIndex Optional. Sets a cursor into the requested set of campaigns. Use in conjunction with the `count` parameter to control pagination of the returned array. 0-indexed record offset for the result set, defaults to 0.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Count Optional. Sets the number of Campaign objects in the returned array. Use in conjunction with the `startIndex` parameter to control pagination. For example, to return the first ten campaigns set `startIndex=0` and `count=10`. To return the next ten campaigns, set `startIndex=10` and `count=10`, and so on. Defaults to max page size.
	Count *int32 `form:"count,omitempty" json:"count,omitempty"`

	// StateFilter Optional. The returned array is filtered to include only campaigns with state set to one of the values in the specified comma-delimited list.
	StateFilter *ListCampaignsExParamsStateFilter `form:"stateFilter,omitempty" json:"stateFilter,omitempty"`

	// Name Optional. The returned array includes only campaign with the specified name using an exact string match.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// CampaignIdFilter Optional. The returned array includes only campaigns with identifiers matching those specified in the comma-delimited string.
	CampaignIdFilter *string `form:"campaignIdFilter,omitempty" json:"campaignIdFilter,omitempty"`

	// PortfolioIdFilter Optional. The returned array includes only campaigns associated with Portfolio identifiers matching those specified in the comma-delimited string.
	PortfolioIdFilter *string `form:"portfolioIdFilter,omitempty" json:"portfolioIdFilter,omitempty"`

	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ListCampaignsExParamsStateFilter defines parameters for ListCampaignsEx.
type ListCampaignsExParamsStateFilter string

// GetCampaignResponseExParams defines parameters for GetCampaignResponseEx.
type GetCampaignResponseExParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ArchiveCampaignParams defines parameters for ArchiveCampaign.
type ArchiveCampaignParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// GetCampaignParams defines parameters for GetCampaign.
type GetCampaignParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// GetRuleBasedBudgetHistoryForSDCampaignsParams defines parameters for GetRuleBasedBudgetHistoryForSDCampaigns.
type GetRuleBasedBudgetHistoryForSDCampaignsParams struct {
	// NextToken To retrieve the next page of results, call the same operation and specify this token in the request. If the `nextToken` field is empty, there are no further results.
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// PageSize Sets a limit on the number of results returned. Maximum limit of `pageSize` is 30.
	PageSize float32 `form:"pageSize" json:"pageSize"`

	// StartDate The start date of the budget history in YYYYMMDD format.
	StartDate string `form:"startDate" json:"startDate"`

	// EndDate The end date of the budget history in YYYYMMDD format.
	EndDate string `form:"endDate" json:"endDate"`

	// AmazonAdvertisingAPIClientId The identifier of a client associated with a Login with Amazon account. This is a required header for advertisers and integrators using the Advertising API.
	AmazonAdvertisingAPIClientId string `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header. This is a required header for advertisers and integrators using the Advertising API.
	AmazonAdvertisingAPIScope string `json:"Amazon-Advertising-API-Scope"`
}

// ListCreativesParams defines parameters for ListCreatives.
type ListCreativesParams struct {
	// StartIndex Sets a cursor into the requested set of creatives. Use in conjunction with the `count` parameter to control pagination of the returned array. 0-indexed record offset for the result set, defaults to 0.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Count Sets the number of creative objects in the returned array. Use in conjunction with the `startIndex` parameter to control pagination. For example, to return the first ten creatives set `startIndex=0` and `count=10`. To return the next ten creatives, set `startIndex=10` and `count=10`, and so on. Defaults to max page size.
	Count *int32 `form:"count,omitempty" json:"count,omitempty"`

	// AdGroupIdFilter The returned array includes only creatives associated with ad group identifiers matching those specified in the comma-delimited string. Cannot be used in conjunction with the `creativeIdFilter` parameter.
	AdGroupIdFilter *string `form:"adGroupIdFilter,omitempty" json:"adGroupIdFilter,omitempty"`

	// CreativeIdFilter The returned array includes only creatives with identifiers matching those specified in the comma-delimited string. Cannot be used in conjunction with the `adGroupIdFilter` parameter.
	CreativeIdFilter *string `form:"creativeIdFilter,omitempty" json:"creativeIdFilter,omitempty"`

	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// CreateCreativesJSONBody defines parameters for CreateCreatives.
type CreateCreativesJSONBody = []CreateCreative

// CreateCreativesParams defines parameters for CreateCreatives.
type CreateCreativesParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// UpdateCreativesJSONBody defines parameters for UpdateCreatives.
type UpdateCreativesJSONBody = []CreativeUpdate

// UpdateCreativesParams defines parameters for UpdateCreatives.
type UpdateCreativesParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// PostCreativePreviewParams defines parameters for PostCreativePreview.
type PostCreativePreviewParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// CreateSDForecastParams defines parameters for CreateSDForecast.
type CreateSDForecastParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ListLocationsParams defines parameters for ListLocations.
type ListLocationsParams struct {
	// StartIndex Optional. 0-indexed record offset for the result set. Defaults to 0.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Count Optional. Number of records to include in the paged response. Defaults to max page size.
	Count *int32 `form:"count,omitempty" json:"count,omitempty"`

	// StateFilter Optional. Restricts results to those with state within the specified comma-separated list. Must be one of: `enabled`.
	StateFilter *ListLocationsParamsStateFilter `form:"stateFilter,omitempty" json:"stateFilter,omitempty"`

	// AdGroupIdFilter Optional list of comma separated adGroupIds. Restricts results to locations with the specified `adGroupId`.
	AdGroupIdFilter *string `form:"adGroupIdFilter,omitempty" json:"adGroupIdFilter,omitempty"`

	// CampaignIdFilter Optional list of comma separated campaignIds. Restricts results to locations with the specified `campaignId`.
	CampaignIdFilter *string `form:"campaignIdFilter,omitempty" json:"campaignIdFilter,omitempty"`

	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ListLocationsParamsStateFilter defines parameters for ListLocations.
type ListLocationsParamsStateFilter string

// CreateLocationsJSONBody defines parameters for CreateLocations.
type CreateLocationsJSONBody = []CreateLocation

// CreateLocationsParams defines parameters for CreateLocations.
type CreateLocationsParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ListCreativeModerationsParams defines parameters for ListCreativeModerations.
type ListCreativeModerationsParams struct {
	// Language The language of the returned creative moderation metadata.
	Language Locale `form:"language" json:"language"`

	// StartIndex Sets a cursor into the requested set of creative moderations. Use in conjunction with the `count` parameter to control pagination of the returned array. 0-indexed record offset for the result set, defaults to 0.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Count Sets the number of creative objects in the returned array. Use in conjunction with the `startIndex` parameter to control pagination. For example, to return the first ten creative moderations set `startIndex=0` and `count=10`. To return the next ten creative moderations, set `startIndex=10` and `count=10`, and so on. Defaults to max page size.
	Count *int32 `form:"count,omitempty" json:"count,omitempty"`

	// AdGroupIdFilter The returned array includes only creative moderations associated with ad group identifiers matching those specified in the comma-delimited string. Cannot be used in conjunction with the `creativeIdFilter` parameter.
	AdGroupIdFilter *string `form:"adGroupIdFilter,omitempty" json:"adGroupIdFilter,omitempty"`

	// CreativeIdFilter The returned array includes only creative moderations with creative identifiers matching those specified in the comma-delimited string. Cannot be used in conjunction with the `adGroupIdFilter` parameter.
	CreativeIdFilter *string `form:"creativeIdFilter,omitempty" json:"creativeIdFilter,omitempty"`

	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ListNegativeTargetingClausesParams defines parameters for ListNegativeTargetingClauses.
type ListNegativeTargetingClausesParams struct {
	// StartIndex Optional. 0-indexed record offset for the result set. Defaults to 0.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Count Optional. Number of records to include in the paged response. Defaults to max page size.
	Count *int32 `form:"count,omitempty" json:"count,omitempty"`

	// StateFilter Optional. Restricts results to those with state within the specified comma-separated list. Must be one of: `enabled`, `paused`, or `archived`. Default behavior is to include enabled, paused, and archived.
	StateFilter *ListNegativeTargetingClausesParamsStateFilter `form:"stateFilter,omitempty" json:"stateFilter,omitempty"`

	// AdGroupIdFilter Optional list of comma separated adGroupIds. Restricts results to negative targeting clauses with the specified `adGroupId`.
	AdGroupIdFilter *string `form:"adGroupIdFilter,omitempty" json:"adGroupIdFilter,omitempty"`

	// CampaignIdFilter Optional. Restricts results to targeting clauses within campaigns specified in comma-separated list.
	CampaignIdFilter *string `form:"campaignIdFilter,omitempty" json:"campaignIdFilter,omitempty"`

	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ListNegativeTargetingClausesParamsStateFilter defines parameters for ListNegativeTargetingClauses.
type ListNegativeTargetingClausesParamsStateFilter string

// CreateNegativeTargetingClausesJSONBody defines parameters for CreateNegativeTargetingClauses.
type CreateNegativeTargetingClausesJSONBody = []CreateNegativeTargetingClause

// CreateNegativeTargetingClausesParams defines parameters for CreateNegativeTargetingClauses.
type CreateNegativeTargetingClausesParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// UpdateNegativeTargetingClausesJSONBody defines parameters for UpdateNegativeTargetingClauses.
type UpdateNegativeTargetingClausesJSONBody = []UpdateNegativeTargetingClause

// UpdateNegativeTargetingClausesParams defines parameters for UpdateNegativeTargetingClauses.
type UpdateNegativeTargetingClausesParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ListNegativeTargetingClausesExParams defines parameters for ListNegativeTargetingClausesEx.
type ListNegativeTargetingClausesExParams struct {
	// StartIndex Optional. 0-indexed record offset for the result set. Defaults to 0.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Count Optional. Number of records to include in the paged response. Defaults to max page size.
	Count *int32 `form:"count,omitempty" json:"count,omitempty"`

	// StateFilter Optional. Restricts results to keywords with state within the specified comma-separated list. Must be one of: `enabled`, `paused`, or `archived`. Default behavior is to include `enabled`, `paused`, and `archived`.
	StateFilter *ListNegativeTargetingClausesExParamsStateFilter `form:"stateFilter,omitempty" json:"stateFilter,omitempty"`

	// TargetIdFilter Optional. Restricts results to ads with the specified `tagetId` specified in comma-separated list
	TargetIdFilter *string `form:"targetIdFilter,omitempty" json:"targetIdFilter,omitempty"`

	// AdGroupIdFilter Optional list of comma separated adGroupIds. Restricts results to negative targeting clauses with the specified `adGroupId`.
	AdGroupIdFilter *string `form:"adGroupIdFilter,omitempty" json:"adGroupIdFilter,omitempty"`

	// CampaignIdFilter Optional. Restricts results to ads within campaigns specified in the comma-separated list.
	CampaignIdFilter *string `form:"campaignIdFilter,omitempty" json:"campaignIdFilter,omitempty"`

	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ListNegativeTargetingClausesExParamsStateFilter defines parameters for ListNegativeTargetingClausesEx.
type ListNegativeTargetingClausesExParamsStateFilter string

// GetNegativeTargetsExParams defines parameters for GetNegativeTargetsEx.
type GetNegativeTargetsExParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ArchiveNegativeTargetingClauseParams defines parameters for ArchiveNegativeTargetingClause.
type ArchiveNegativeTargetingClauseParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// GetNegativeTargetsParams defines parameters for GetNegativeTargets.
type GetNegativeTargetsParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ListOptimizationRulesParams defines parameters for ListOptimizationRules.
type ListOptimizationRulesParams struct {
	// StartIndex Optional. Sets a cursor into the requested set of optimization rules. Use in conjunction with the `count` parameter to control pagination of the returned array. 0-indexed record offset for the result set, defaults to 0.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Count Optional. Sets the number of OptimizationRule objects in the returned array. Use in conjunction with the `startIndex` parameter to control pagination. For example, to return the first ten optimization rules set `startIndex=0` and `count=10`. To return the next ten optimization rules, set `startIndex=10` and `count=10`, and so on. Defaults to max page size.
	Count *int32 `form:"count,omitempty" json:"count,omitempty"`

	// StateFilter Optional. The returned array is filtered to include only optimization rules with state set to one of the values in the specified comma-delimited list.
	// Available values:
	//   - enabled
	//   - paused [COMING LATER]
	//   - enabled, paused [COMING LATER]
	StateFilter *string `form:"stateFilter,omitempty" json:"stateFilter,omitempty"`

	// Name Optional. The returned array includes only optimization rules with the specified name using an exact string match.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// OptimizationRuleIdFilter Optional. The returned array is filtered to include only optimization rules associated with the optimization rule identifiers in the specified comma-delimited list.
	//
	// Maximum size limit 50.
	OptimizationRuleIdFilter *string `form:"optimizationRuleIdFilter,omitempty" json:"optimizationRuleIdFilter,omitempty"`

	// AdGroupIdFilter Optional. The returned array is filtered to include only optimization rules associated with the ad group identifiers in the comma-delimited list.
	//
	// Maximum size limit 50.
	AdGroupIdFilter *string `form:"adGroupIdFilter,omitempty" json:"adGroupIdFilter,omitempty"`

	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// CreateOptimizationRulesJSONBody defines parameters for CreateOptimizationRules.
type CreateOptimizationRulesJSONBody = []CreateOptimizationRule

// CreateOptimizationRulesParams defines parameters for CreateOptimizationRules.
type CreateOptimizationRulesParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// UpdateOptimizationRulesJSONBody defines parameters for UpdateOptimizationRules.
type UpdateOptimizationRulesJSONBody = []UpdateOptimizationRule

// UpdateOptimizationRulesParams defines parameters for UpdateOptimizationRules.
type UpdateOptimizationRulesParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// GetSdOptimizationRulesOptimizationRuleIdParams defines parameters for GetSdOptimizationRulesOptimizationRuleId.
type GetSdOptimizationRulesOptimizationRuleIdParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ListProductAdsParams defines parameters for ListProductAds.
type ListProductAdsParams struct {
	// StartIndex Optional. Sets a cursor into the requested set of product ads. Use in conjunction with the `count` parameter to control pagination of the returned array. 0-indexed record offset for the result set, defaults to 0.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Count Optional. Sets the number of ProductAd objects in the returned array. Use in conjunction with the `startIndex` parameter to control pagination. For example, to return the first ten product ad set `startIndex=0` and `count=10`. To return the next ten product ads, set `startIndex=10` and `count=10`, and so on. Defaults to max page size.
	Count *int32 `form:"count,omitempty" json:"count,omitempty"`

	// StateFilter Optional. The returned array is filtered to include only products ads associated with campaigns that have state set to one of the values in the comma-delimited list.
	StateFilter *ListProductAdsParamsStateFilter `form:"stateFilter,omitempty" json:"stateFilter,omitempty"`

	// AdIdFilter Optional. The returned array includes only product ads with identifiers matching those in the comma-delimited string.
	AdIdFilter *string `form:"adIdFilter,omitempty" json:"adIdFilter,omitempty"`

	// AdGroupIdFilter Optional. The returned array is filtered to include only products ads associated with ad groups identifiers in the comma-delimited list.
	AdGroupIdFilter *string `form:"adGroupIdFilter,omitempty" json:"adGroupIdFilter,omitempty"`

	// CampaignIdFilter Optional. The returned array is filtered to include only product ads associated with the campaign identifiers in the comma-delimited list.
	CampaignIdFilter *string `form:"campaignIdFilter,omitempty" json:"campaignIdFilter,omitempty"`

	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ListProductAdsParamsStateFilter defines parameters for ListProductAds.
type ListProductAdsParamsStateFilter string

// CreateProductAdsJSONBody defines parameters for CreateProductAds.
type CreateProductAdsJSONBody = []CreateProductAd

// CreateProductAdsParams defines parameters for CreateProductAds.
type CreateProductAdsParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// UpdateProductAdsJSONBody defines parameters for UpdateProductAds.
type UpdateProductAdsJSONBody = []UpdateProductAd

// UpdateProductAdsParams defines parameters for UpdateProductAds.
type UpdateProductAdsParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ListProductAdsExParams defines parameters for ListProductAdsEx.
type ListProductAdsExParams struct {
	// StartIndex Optional. Sets a cursor into the requested set of product ads. Use in conjunction with the `count` parameter to control pagination of the returned array. 0-indexed record offset for the result set, defaults to 0.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Count Optional. Sets the number of ProduceAdEx objects in the returned array. Use in conjunction with the `startIndex` parameter to control pagination. For example, to return the first ten product ads set `startIndex=0` and `count=10`. To return the next ten campaigns, set `startIndex=10` and `count=10`, and so on. Defaults to max page size.
	Count *int32 `form:"count,omitempty" json:"count,omitempty"`

	// StateFilter Optional. The returned array is filtered to include only campaigns with state set to one of the values in the specified comma-delimited list.
	StateFilter *ListProductAdsExParamsStateFilter `form:"stateFilter,omitempty" json:"stateFilter,omitempty"`

	// AdIdFilter Optional. The returned array includes only product ads with identifiers matching those in the comma-delimited string.
	AdIdFilter *string `form:"adIdFilter,omitempty" json:"adIdFilter,omitempty"`

	// AdGroupIdFilter Optional. The returned array is filtered to include only products ads associated with ad groups identifiers in the comma-delimited list.
	AdGroupIdFilter *string `form:"adGroupIdFilter,omitempty" json:"adGroupIdFilter,omitempty"`

	// CampaignIdFilter Optional. The returned array is filtered to include only product ads associated with the campaign identifiers in the comma-delimited list.
	CampaignIdFilter *string `form:"campaignIdFilter,omitempty" json:"campaignIdFilter,omitempty"`

	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ListProductAdsExParamsStateFilter defines parameters for ListProductAdsEx.
type ListProductAdsExParamsStateFilter string

// GetProductAdResponseExParams defines parameters for GetProductAdResponseEx.
type GetProductAdResponseExParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ArchiveProductAdParams defines parameters for ArchiveProductAd.
type ArchiveProductAdParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// GetProductAdParams defines parameters for GetProductAd.
type GetProductAdParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// GetSnapshotParams defines parameters for GetSnapshot.
type GetSnapshotParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// DownloadSnapshotParams defines parameters for DownloadSnapshot.
type DownloadSnapshotParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ListTargetingClausesParams defines parameters for ListTargetingClauses.
type ListTargetingClausesParams struct {
	// StartIndex Optional. 0-indexed record offset for the result set. Defaults to 0.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Count Optional. Number of records to include in the paged response. Defaults to max page size.
	Count *int32 `form:"count,omitempty" json:"count,omitempty"`

	// StateFilter Optional. Restricts results to those with `state` set to values in the specified comma-separated list.
	StateFilter *ListTargetingClausesParamsStateFilter `form:"stateFilter,omitempty" json:"stateFilter,omitempty"`

	// AdGroupIdFilter Optional list of comma separated adGroupIds. Restricts results to targeting clauses with the specified `adGroupId`.
	AdGroupIdFilter *string `form:"adGroupIdFilter,omitempty" json:"adGroupIdFilter,omitempty"`

	// CampaignIdFilter Optional. Restricts results to targeting clauses within campaigns specified in comma-separated list.
	CampaignIdFilter *string `form:"campaignIdFilter,omitempty" json:"campaignIdFilter,omitempty"`

	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ListTargetingClausesParamsStateFilter defines parameters for ListTargetingClauses.
type ListTargetingClausesParamsStateFilter string

// CreateTargetingClausesJSONBody defines parameters for CreateTargetingClauses.
type CreateTargetingClausesJSONBody = []CreateTargetingClause

// CreateTargetingClausesParams defines parameters for CreateTargetingClauses.
type CreateTargetingClausesParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// UpdateTargetingClausesJSONBody defines parameters for UpdateTargetingClauses.
type UpdateTargetingClausesJSONBody = []UpdateTargetingClause

// UpdateTargetingClausesParams defines parameters for UpdateTargetingClauses.
type UpdateTargetingClausesParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// GetTargetBidRecommendationsParams defines parameters for GetTargetBidRecommendations.
type GetTargetBidRecommendationsParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ListTargetingClausesExParams defines parameters for ListTargetingClausesEx.
type ListTargetingClausesExParams struct {
	// StartIndex Optional. 0-indexed record offset for the result set. Defaults to 0.
	StartIndex *int32 `form:"startIndex,omitempty" json:"startIndex,omitempty"`

	// Count Optional. Number of records to include in the paged response. Defaults to max page size.
	Count *int32 `form:"count,omitempty" json:"count,omitempty"`

	// StateFilter Optional. Restricts results to keywords with state within the specified comma-separated list. Must be one of: `enabled`, `paused`, or `archived`. Default behavior is to include enabled, paused, and archived.
	StateFilter *ListTargetingClausesExParamsStateFilter `form:"stateFilter,omitempty" json:"stateFilter,omitempty"`

	// TargetIdFilter Optional. Restricts results to ads with the specified `tagetId` specified in comma-separated list
	TargetIdFilter *string `form:"targetIdFilter,omitempty" json:"targetIdFilter,omitempty"`

	// AdGroupIdFilter Optional list of comma separated adGroupIds. Restricts results to targeting clauses with the specified `adGroupId`.
	AdGroupIdFilter *string `form:"adGroupIdFilter,omitempty" json:"adGroupIdFilter,omitempty"`

	// CampaignIdFilter Optional. Restricts results to ads within campaigns specified in comma-separated list.
	CampaignIdFilter *string `form:"campaignIdFilter,omitempty" json:"campaignIdFilter,omitempty"`

	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ListTargetingClausesExParamsStateFilter defines parameters for ListTargetingClausesEx.
type ListTargetingClausesExParamsStateFilter string

// GetTargetsExParams defines parameters for GetTargetsEx.
type GetTargetsExParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// GetTargetRecommendationsParams defines parameters for GetTargetRecommendations.
type GetTargetRecommendationsParams struct {
	// Locale The requested locale from query parameter to return translated category recommendations.
	Locale *SDTargetingRecommendationsLocale `form:"locale,omitempty" json:"locale,omitempty"`

	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// ArchiveTargetingClauseParams defines parameters for ArchiveTargetingClause.
type ArchiveTargetingClauseParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// GetTargetsParams defines parameters for GetTargets.
type GetTargetsParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// RequestReportParams defines parameters for RequestReport.
type RequestReportParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// RequestReportParamsRecordType defines parameters for RequestReport.
type RequestReportParamsRecordType string

// CreateSnapshotParams defines parameters for CreateSnapshot.
type CreateSnapshotParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// GetReportStatusParams defines parameters for GetReportStatus.
type GetReportStatusParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// DownloadReportParams defines parameters for DownloadReport.
type DownloadReportParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId ClientHeader `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope ProfileHeader `json:"Amazon-Advertising-API-Scope"`
}

// CreateAdGroupsJSONRequestBody defines body for CreateAdGroups for application/json ContentType.
type CreateAdGroupsJSONRequestBody = CreateAdGroupsJSONBody

// UpdateAdGroupsJSONRequestBody defines body for UpdateAdGroups for application/json ContentType.
type UpdateAdGroupsJSONRequestBody = UpdateAdGroupsJSONBody

// AssociateOptimizationRulesWithAdGroupJSONRequestBody defines body for AssociateOptimizationRulesWithAdGroup for application/json ContentType.
type AssociateOptimizationRulesWithAdGroupJSONRequestBody = CreateAssociatedOptimizationRulesRequest

// CreateBrandSafetyDenyListDomainsJSONRequestBody defines body for CreateBrandSafetyDenyListDomains for application/json ContentType.
type CreateBrandSafetyDenyListDomainsJSONRequestBody = BrandSafetyPostRequest

// CreateBudgetRulesForSDCampaignsJSONRequestBody defines body for CreateBudgetRulesForSDCampaigns for application/json ContentType.
type CreateBudgetRulesForSDCampaignsJSONRequestBody = CreateSDBudgetRulesRequest

// UpdateBudgetRulesForSDCampaignsJSONRequestBody defines body for UpdateBudgetRulesForSDCampaigns for application/json ContentType.
type UpdateBudgetRulesForSDCampaignsJSONRequestBody = UpdateSDBudgetRulesRequest

// CreateCampaignsJSONRequestBody defines body for CreateCampaigns for application/json ContentType.
type CreateCampaignsJSONRequestBody = CreateCampaignsJSONBody

// UpdateCampaignsJSONRequestBody defines body for UpdateCampaigns for application/json ContentType.
type UpdateCampaignsJSONRequestBody = UpdateCampaignsJSONBody

// SdCampaignsBudgetUsageApplicationVndSdcampaignbudgetusageV1PlusJSONRequestBody defines body for SdCampaignsBudgetUsage for application/vnd.sdcampaignbudgetusage.v1+json ContentType.
type SdCampaignsBudgetUsageApplicationVndSdcampaignbudgetusageV1PlusJSONRequestBody = BudgetUsageCampaignRequest

// CreateCreativesJSONRequestBody defines body for CreateCreatives for application/json ContentType.
type CreateCreativesJSONRequestBody = CreateCreativesJSONBody

// UpdateCreativesJSONRequestBody defines body for UpdateCreatives for application/json ContentType.
type UpdateCreativesJSONRequestBody = UpdateCreativesJSONBody

// PostCreativePreviewJSONRequestBody defines body for PostCreativePreview for application/json ContentType.
type PostCreativePreviewJSONRequestBody = CreativePreviewRequest

// CreateSDForecastApplicationVndSdforecastsV30PlusJSONRequestBody defines body for CreateSDForecast for application/vnd.sdforecasts.v3.0+json ContentType.
type CreateSDForecastApplicationVndSdforecastsV30PlusJSONRequestBody = SDForecastRequest

// CreateLocationsJSONRequestBody defines body for CreateLocations for application/json ContentType.
type CreateLocationsJSONRequestBody = CreateLocationsJSONBody

// CreateNegativeTargetingClausesJSONRequestBody defines body for CreateNegativeTargetingClauses for application/json ContentType.
type CreateNegativeTargetingClausesJSONRequestBody = CreateNegativeTargetingClausesJSONBody

// UpdateNegativeTargetingClausesJSONRequestBody defines body for UpdateNegativeTargetingClauses for application/json ContentType.
type UpdateNegativeTargetingClausesJSONRequestBody = UpdateNegativeTargetingClausesJSONBody

// CreateOptimizationRulesJSONRequestBody defines body for CreateOptimizationRules for application/json ContentType.
type CreateOptimizationRulesJSONRequestBody = CreateOptimizationRulesJSONBody

// UpdateOptimizationRulesJSONRequestBody defines body for UpdateOptimizationRules for application/json ContentType.
type UpdateOptimizationRulesJSONRequestBody = UpdateOptimizationRulesJSONBody

// CreateProductAdsJSONRequestBody defines body for CreateProductAds for application/json ContentType.
type CreateProductAdsJSONRequestBody = CreateProductAdsJSONBody

// UpdateProductAdsJSONRequestBody defines body for UpdateProductAds for application/json ContentType.
type UpdateProductAdsJSONRequestBody = UpdateProductAdsJSONBody

// CreateTargetingClausesJSONRequestBody defines body for CreateTargetingClauses for application/json ContentType.
type CreateTargetingClausesJSONRequestBody = CreateTargetingClausesJSONBody

// UpdateTargetingClausesJSONRequestBody defines body for UpdateTargetingClauses for application/json ContentType.
type UpdateTargetingClausesJSONRequestBody = UpdateTargetingClausesJSONBody

// GetTargetBidRecommendationsApplicationVndSdtargetingrecommendationsV31PlusJSONRequestBody defines body for GetTargetBidRecommendations for application/vnd.sdtargetingrecommendations.v3.1+json ContentType.
type GetTargetBidRecommendationsApplicationVndSdtargetingrecommendationsV31PlusJSONRequestBody = SDTargetingBidRecommendationsRequestV31

// GetTargetBidRecommendationsApplicationVndSdtargetingrecommendationsV32PlusJSONRequestBody defines body for GetTargetBidRecommendations for application/vnd.sdtargetingrecommendations.v3.2+json ContentType.
type GetTargetBidRecommendationsApplicationVndSdtargetingrecommendationsV32PlusJSONRequestBody = SDTargetingBidRecommendationsRequestV32

// GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV30PlusJSONRequestBody defines body for GetTargetRecommendations for application/vnd.sdtargetingrecommendations.v3.0+json ContentType.
type GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV30PlusJSONRequestBody = SDTargetingRecommendationsRequest

// GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV31PlusJSONRequestBody defines body for GetTargetRecommendations for application/vnd.sdtargetingrecommendations.v3.1+json ContentType.
type GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV31PlusJSONRequestBody = SDTargetingRecommendationsRequestV31

// GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV32PlusJSONRequestBody defines body for GetTargetRecommendations for application/vnd.sdtargetingrecommendations.v3.2+json ContentType.
type GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV32PlusJSONRequestBody = SDTargetingRecommendationsRequestV32

// GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV33PlusJSONRequestBody defines body for GetTargetRecommendations for application/vnd.sdtargetingrecommendations.v3.3+json ContentType.
type GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV33PlusJSONRequestBody = SDTargetingRecommendationsRequestV33

// RequestReportJSONRequestBody defines body for RequestReport for application/json ContentType.
type RequestReportJSONRequestBody = ReportRequest

// CreateSnapshotJSONRequestBody defines body for CreateSnapshot for application/json ContentType.
type CreateSnapshotJSONRequestBody = SnapshotRequest

// AsTargetingPredicate returns the union data inside the CreateTargetingExpression_Item as a TargetingPredicate
func (t CreateTargetingExpression_Item) AsTargetingPredicate() (TargetingPredicate, error) {
	var body TargetingPredicate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTargetingPredicate overwrites any union data inside the CreateTargetingExpression_Item as the provided TargetingPredicate
func (t *CreateTargetingExpression_Item) FromTargetingPredicate(v TargetingPredicate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTargetingPredicate performs a merge with any union data inside the CreateTargetingExpression_Item, using the provided TargetingPredicate
func (t *CreateTargetingExpression_Item) MergeTargetingPredicate(v TargetingPredicate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTargetingPredicateNested returns the union data inside the CreateTargetingExpression_Item as a TargetingPredicateNested
func (t CreateTargetingExpression_Item) AsTargetingPredicateNested() (TargetingPredicateNested, error) {
	var body TargetingPredicateNested
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTargetingPredicateNested overwrites any union data inside the CreateTargetingExpression_Item as the provided TargetingPredicateNested
func (t *CreateTargetingExpression_Item) FromTargetingPredicateNested(v TargetingPredicateNested) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTargetingPredicateNested performs a merge with any union data inside the CreateTargetingExpression_Item, using the provided TargetingPredicateNested
func (t *CreateTargetingExpression_Item) MergeTargetingPredicateNested(v TargetingPredicateNested) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateTargetingExpression_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateTargetingExpression_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsHeadlineCreativeProperties returns the union data inside the CreativeProperties as a HeadlineCreativeProperties
func (t CreativeProperties) AsHeadlineCreativeProperties() (HeadlineCreativeProperties, error) {
	var body HeadlineCreativeProperties
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHeadlineCreativeProperties overwrites any union data inside the CreativeProperties as the provided HeadlineCreativeProperties
func (t *CreativeProperties) FromHeadlineCreativeProperties(v HeadlineCreativeProperties) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHeadlineCreativeProperties performs a merge with any union data inside the CreativeProperties, using the provided HeadlineCreativeProperties
func (t *CreativeProperties) MergeHeadlineCreativeProperties(v HeadlineCreativeProperties) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsLogoCreativeProperties returns the union data inside the CreativeProperties as a LogoCreativeProperties
func (t CreativeProperties) AsLogoCreativeProperties() (LogoCreativeProperties, error) {
	var body LogoCreativeProperties
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLogoCreativeProperties overwrites any union data inside the CreativeProperties as the provided LogoCreativeProperties
func (t *CreativeProperties) FromLogoCreativeProperties(v LogoCreativeProperties) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLogoCreativeProperties performs a merge with any union data inside the CreativeProperties, using the provided LogoCreativeProperties
func (t *CreativeProperties) MergeLogoCreativeProperties(v LogoCreativeProperties) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomImageCreativeProperties returns the union data inside the CreativeProperties as a CustomImageCreativeProperties
func (t CreativeProperties) AsCustomImageCreativeProperties() (CustomImageCreativeProperties, error) {
	var body CustomImageCreativeProperties
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomImageCreativeProperties overwrites any union data inside the CreativeProperties as the provided CustomImageCreativeProperties
func (t *CreativeProperties) FromCustomImageCreativeProperties(v CustomImageCreativeProperties) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomImageCreativeProperties performs a merge with any union data inside the CreativeProperties, using the provided CustomImageCreativeProperties
func (t *CreativeProperties) MergeCustomImageCreativeProperties(v CustomImageCreativeProperties) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsVideoCreativeProperties returns the union data inside the CreativeProperties as a VideoCreativeProperties
func (t CreativeProperties) AsVideoCreativeProperties() (VideoCreativeProperties, error) {
	var body VideoCreativeProperties
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVideoCreativeProperties overwrites any union data inside the CreativeProperties as the provided VideoCreativeProperties
func (t *CreativeProperties) FromVideoCreativeProperties(v VideoCreativeProperties) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVideoCreativeProperties performs a merge with any union data inside the CreativeProperties, using the provided VideoCreativeProperties
func (t *CreativeProperties) MergeVideoCreativeProperties(v VideoCreativeProperties) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreativeProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreativeProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSDTargetingPredicateV31 returns the union data inside the SDTargetExpressionV31 as a SDTargetingPredicateV31
func (t SDTargetExpressionV31) AsSDTargetingPredicateV31() (SDTargetingPredicateV31, error) {
	var body SDTargetingPredicateV31
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSDTargetingPredicateV31 overwrites any union data inside the SDTargetExpressionV31 as the provided SDTargetingPredicateV31
func (t *SDTargetExpressionV31) FromSDTargetingPredicateV31(v SDTargetingPredicateV31) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSDTargetingPredicateV31 performs a merge with any union data inside the SDTargetExpressionV31, using the provided SDTargetingPredicateV31
func (t *SDTargetExpressionV31) MergeSDTargetingPredicateV31(v SDTargetingPredicateV31) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSDTargetingPredicateNestedV31 returns the union data inside the SDTargetExpressionV31 as a SDTargetingPredicateNestedV31
func (t SDTargetExpressionV31) AsSDTargetingPredicateNestedV31() (SDTargetingPredicateNestedV31, error) {
	var body SDTargetingPredicateNestedV31
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSDTargetingPredicateNestedV31 overwrites any union data inside the SDTargetExpressionV31 as the provided SDTargetingPredicateNestedV31
func (t *SDTargetExpressionV31) FromSDTargetingPredicateNestedV31(v SDTargetingPredicateNestedV31) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSDTargetingPredicateNestedV31 performs a merge with any union data inside the SDTargetExpressionV31, using the provided SDTargetingPredicateNestedV31
func (t *SDTargetExpressionV31) MergeSDTargetingPredicateNestedV31(v SDTargetingPredicateNestedV31) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SDTargetExpressionV31) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SDTargetExpressionV31) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSDProductTargetingRecommendationsSuccess returns the union data inside the SDTargetingRecommendationsV32_Themes_Products_Item as a SDProductTargetingRecommendationsSuccess
func (t SDTargetingRecommendationsV32_Themes_Products_Item) AsSDProductTargetingRecommendationsSuccess() (SDProductTargetingRecommendationsSuccess, error) {
	var body SDProductTargetingRecommendationsSuccess
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSDProductTargetingRecommendationsSuccess overwrites any union data inside the SDTargetingRecommendationsV32_Themes_Products_Item as the provided SDProductTargetingRecommendationsSuccess
func (t *SDTargetingRecommendationsV32_Themes_Products_Item) FromSDProductTargetingRecommendationsSuccess(v SDProductTargetingRecommendationsSuccess) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSDProductTargetingRecommendationsSuccess performs a merge with any union data inside the SDTargetingRecommendationsV32_Themes_Products_Item, using the provided SDProductTargetingRecommendationsSuccess
func (t *SDTargetingRecommendationsV32_Themes_Products_Item) MergeSDProductTargetingRecommendationsSuccess(v SDProductTargetingRecommendationsSuccess) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSDTargetingRecommendationsFailure returns the union data inside the SDTargetingRecommendationsV32_Themes_Products_Item as a SDTargetingRecommendationsFailure
func (t SDTargetingRecommendationsV32_Themes_Products_Item) AsSDTargetingRecommendationsFailure() (SDTargetingRecommendationsFailure, error) {
	var body SDTargetingRecommendationsFailure
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSDTargetingRecommendationsFailure overwrites any union data inside the SDTargetingRecommendationsV32_Themes_Products_Item as the provided SDTargetingRecommendationsFailure
func (t *SDTargetingRecommendationsV32_Themes_Products_Item) FromSDTargetingRecommendationsFailure(v SDTargetingRecommendationsFailure) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSDTargetingRecommendationsFailure performs a merge with any union data inside the SDTargetingRecommendationsV32_Themes_Products_Item, using the provided SDTargetingRecommendationsFailure
func (t *SDTargetingRecommendationsV32_Themes_Products_Item) MergeSDTargetingRecommendationsFailure(v SDTargetingRecommendationsFailure) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SDTargetingRecommendationsV32_Themes_Products_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SDTargetingRecommendationsV32_Themes_Products_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSDProductTargetingRecommendationsSuccess returns the union data inside the SDTargetingRecommendationsV33_Themes_Products_Item as a SDProductTargetingRecommendationsSuccess
func (t SDTargetingRecommendationsV33_Themes_Products_Item) AsSDProductTargetingRecommendationsSuccess() (SDProductTargetingRecommendationsSuccess, error) {
	var body SDProductTargetingRecommendationsSuccess
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSDProductTargetingRecommendationsSuccess overwrites any union data inside the SDTargetingRecommendationsV33_Themes_Products_Item as the provided SDProductTargetingRecommendationsSuccess
func (t *SDTargetingRecommendationsV33_Themes_Products_Item) FromSDProductTargetingRecommendationsSuccess(v SDProductTargetingRecommendationsSuccess) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSDProductTargetingRecommendationsSuccess performs a merge with any union data inside the SDTargetingRecommendationsV33_Themes_Products_Item, using the provided SDProductTargetingRecommendationsSuccess
func (t *SDTargetingRecommendationsV33_Themes_Products_Item) MergeSDProductTargetingRecommendationsSuccess(v SDProductTargetingRecommendationsSuccess) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSDTargetingRecommendationsFailure returns the union data inside the SDTargetingRecommendationsV33_Themes_Products_Item as a SDTargetingRecommendationsFailure
func (t SDTargetingRecommendationsV33_Themes_Products_Item) AsSDTargetingRecommendationsFailure() (SDTargetingRecommendationsFailure, error) {
	var body SDTargetingRecommendationsFailure
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSDTargetingRecommendationsFailure overwrites any union data inside the SDTargetingRecommendationsV33_Themes_Products_Item as the provided SDTargetingRecommendationsFailure
func (t *SDTargetingRecommendationsV33_Themes_Products_Item) FromSDTargetingRecommendationsFailure(v SDTargetingRecommendationsFailure) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSDTargetingRecommendationsFailure performs a merge with any union data inside the SDTargetingRecommendationsV33_Themes_Products_Item, using the provided SDTargetingRecommendationsFailure
func (t *SDTargetingRecommendationsV33_Themes_Products_Item) MergeSDTargetingRecommendationsFailure(v SDTargetingRecommendationsFailure) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SDTargetingRecommendationsV33_Themes_Products_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SDTargetingRecommendationsV33_Themes_Products_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSDProductTargetingRecommendationsSuccess returns the union data inside the SDThemeRecommendations_Themes_Products_Item as a SDProductTargetingRecommendationsSuccess
func (t SDThemeRecommendations_Themes_Products_Item) AsSDProductTargetingRecommendationsSuccess() (SDProductTargetingRecommendationsSuccess, error) {
	var body SDProductTargetingRecommendationsSuccess
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSDProductTargetingRecommendationsSuccess overwrites any union data inside the SDThemeRecommendations_Themes_Products_Item as the provided SDProductTargetingRecommendationsSuccess
func (t *SDThemeRecommendations_Themes_Products_Item) FromSDProductTargetingRecommendationsSuccess(v SDProductTargetingRecommendationsSuccess) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSDProductTargetingRecommendationsSuccess performs a merge with any union data inside the SDThemeRecommendations_Themes_Products_Item, using the provided SDProductTargetingRecommendationsSuccess
func (t *SDThemeRecommendations_Themes_Products_Item) MergeSDProductTargetingRecommendationsSuccess(v SDProductTargetingRecommendationsSuccess) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSDTargetingRecommendationsFailure returns the union data inside the SDThemeRecommendations_Themes_Products_Item as a SDTargetingRecommendationsFailure
func (t SDThemeRecommendations_Themes_Products_Item) AsSDTargetingRecommendationsFailure() (SDTargetingRecommendationsFailure, error) {
	var body SDTargetingRecommendationsFailure
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSDTargetingRecommendationsFailure overwrites any union data inside the SDThemeRecommendations_Themes_Products_Item as the provided SDTargetingRecommendationsFailure
func (t *SDThemeRecommendations_Themes_Products_Item) FromSDTargetingRecommendationsFailure(v SDTargetingRecommendationsFailure) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSDTargetingRecommendationsFailure performs a merge with any union data inside the SDThemeRecommendations_Themes_Products_Item, using the provided SDTargetingRecommendationsFailure
func (t *SDThemeRecommendations_Themes_Products_Item) MergeSDTargetingRecommendationsFailure(v SDTargetingRecommendationsFailure) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SDThemeRecommendations_Themes_Products_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SDThemeRecommendations_Themes_Products_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTargetingPredicate returns the union data inside the TargetingExpression_Item as a TargetingPredicate
func (t TargetingExpression_Item) AsTargetingPredicate() (TargetingPredicate, error) {
	var body TargetingPredicate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTargetingPredicate overwrites any union data inside the TargetingExpression_Item as the provided TargetingPredicate
func (t *TargetingExpression_Item) FromTargetingPredicate(v TargetingPredicate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTargetingPredicate performs a merge with any union data inside the TargetingExpression_Item, using the provided TargetingPredicate
func (t *TargetingExpression_Item) MergeTargetingPredicate(v TargetingPredicate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTargetingPredicateLegacy returns the union data inside the TargetingExpression_Item as a TargetingPredicateLegacy
func (t TargetingExpression_Item) AsTargetingPredicateLegacy() (TargetingPredicateLegacy, error) {
	var body TargetingPredicateLegacy
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTargetingPredicateLegacy overwrites any union data inside the TargetingExpression_Item as the provided TargetingPredicateLegacy
func (t *TargetingExpression_Item) FromTargetingPredicateLegacy(v TargetingPredicateLegacy) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTargetingPredicateLegacy performs a merge with any union data inside the TargetingExpression_Item, using the provided TargetingPredicateLegacy
func (t *TargetingExpression_Item) MergeTargetingPredicateLegacy(v TargetingPredicateLegacy) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTargetingPredicateNested returns the union data inside the TargetingExpression_Item as a TargetingPredicateNested
func (t TargetingExpression_Item) AsTargetingPredicateNested() (TargetingPredicateNested, error) {
	var body TargetingPredicateNested
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTargetingPredicateNested overwrites any union data inside the TargetingExpression_Item as the provided TargetingPredicateNested
func (t *TargetingExpression_Item) FromTargetingPredicateNested(v TargetingPredicateNested) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTargetingPredicateNested performs a merge with any union data inside the TargetingExpression_Item, using the provided TargetingPredicateNested
func (t *TargetingExpression_Item) MergeTargetingPredicateNested(v TargetingPredicateNested) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t TargetingExpression_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TargetingExpression_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListAdGroups request
	ListAdGroups(ctx context.Context, params *ListAdGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAdGroupsWithBody request with any body
	CreateAdGroupsWithBody(ctx context.Context, params *CreateAdGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAdGroups(ctx context.Context, params *CreateAdGroupsParams, body CreateAdGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAdGroupsWithBody request with any body
	UpdateAdGroupsWithBody(ctx context.Context, params *UpdateAdGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAdGroups(ctx context.Context, params *UpdateAdGroupsParams, body UpdateAdGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAdGroupsEx request
	ListAdGroupsEx(ctx context.Context, params *ListAdGroupsExParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAdGroupResponseEx request
	GetAdGroupResponseEx(ctx context.Context, adGroupId int64, params *GetAdGroupResponseExParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveAdGroup request
	ArchiveAdGroup(ctx context.Context, adGroupId int64, params *ArchiveAdGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAdGroup request
	GetAdGroup(ctx context.Context, adGroupId int64, params *GetAdGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSdAdGroupsAdGroupIdOptimizationRules request
	GetSdAdGroupsAdGroupIdOptimizationRules(ctx context.Context, adGroupId int64, params *GetSdAdGroupsAdGroupIdOptimizationRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssociateOptimizationRulesWithAdGroupWithBody request with any body
	AssociateOptimizationRulesWithAdGroupWithBody(ctx context.Context, adGroupId int64, params *AssociateOptimizationRulesWithAdGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssociateOptimizationRulesWithAdGroup(ctx context.Context, adGroupId int64, params *AssociateOptimizationRulesWithAdGroupParams, body AssociateOptimizationRulesWithAdGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBrandSafetyDenyList request
	DeleteBrandSafetyDenyList(ctx context.Context, params *DeleteBrandSafetyDenyListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDomains request
	ListDomains(ctx context.Context, params *ListDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBrandSafetyDenyListDomainsWithBody request with any body
	CreateBrandSafetyDenyListDomainsWithBody(ctx context.Context, params *CreateBrandSafetyDenyListDomainsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBrandSafetyDenyListDomains(ctx context.Context, params *CreateBrandSafetyDenyListDomainsParams, body CreateBrandSafetyDenyListDomainsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRequestStatus request
	ListRequestStatus(ctx context.Context, params *ListRequestStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRequestResults request
	GetRequestResults(ctx context.Context, requestId string, params *GetRequestResultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRequestStatus request
	GetRequestStatus(ctx context.Context, requestId string, params *GetRequestStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSDBudgetRulesForAdvertiser request
	GetSDBudgetRulesForAdvertiser(ctx context.Context, params *GetSDBudgetRulesForAdvertiserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBudgetRulesForSDCampaignsWithBody request with any body
	CreateBudgetRulesForSDCampaignsWithBody(ctx context.Context, params *CreateBudgetRulesForSDCampaignsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBudgetRulesForSDCampaigns(ctx context.Context, params *CreateBudgetRulesForSDCampaignsParams, body CreateBudgetRulesForSDCampaignsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBudgetRulesForSDCampaignsWithBody request with any body
	UpdateBudgetRulesForSDCampaignsWithBody(ctx context.Context, params *UpdateBudgetRulesForSDCampaignsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBudgetRulesForSDCampaigns(ctx context.Context, params *UpdateBudgetRulesForSDCampaignsParams, body UpdateBudgetRulesForSDCampaignsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBudgetRuleByRuleIdForSDCampaigns request
	GetBudgetRuleByRuleIdForSDCampaigns(ctx context.Context, budgetRuleId string, params *GetBudgetRuleByRuleIdForSDCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCampaigns request
	ListCampaigns(ctx context.Context, params *ListCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCampaignsWithBody request with any body
	CreateCampaignsWithBody(ctx context.Context, params *CreateCampaignsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCampaigns(ctx context.Context, params *CreateCampaignsParams, body CreateCampaignsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCampaignsWithBody request with any body
	UpdateCampaignsWithBody(ctx context.Context, params *UpdateCampaignsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCampaigns(ctx context.Context, params *UpdateCampaignsParams, body UpdateCampaignsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SdCampaignsBudgetUsageWithBody request with any body
	SdCampaignsBudgetUsageWithBody(ctx context.Context, params *SdCampaignsBudgetUsageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SdCampaignsBudgetUsageWithApplicationVndSdcampaignbudgetusageV1PlusJSONBody(ctx context.Context, params *SdCampaignsBudgetUsageParams, body SdCampaignsBudgetUsageApplicationVndSdcampaignbudgetusageV1PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCampaignsEx request
	ListCampaignsEx(ctx context.Context, params *ListCampaignsExParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCampaignResponseEx request
	GetCampaignResponseEx(ctx context.Context, campaignId int64, params *GetCampaignResponseExParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveCampaign request
	ArchiveCampaign(ctx context.Context, campaignId int64, params *ArchiveCampaignParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCampaign request
	GetCampaign(ctx context.Context, campaignId int64, params *GetCampaignParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleBasedBudgetHistoryForSDCampaigns request
	GetRuleBasedBudgetHistoryForSDCampaigns(ctx context.Context, campaignId int64, params *GetRuleBasedBudgetHistoryForSDCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCreatives request
	ListCreatives(ctx context.Context, params *ListCreativesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCreativesWithBody request with any body
	CreateCreativesWithBody(ctx context.Context, params *CreateCreativesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCreatives(ctx context.Context, params *CreateCreativesParams, body CreateCreativesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCreativesWithBody request with any body
	UpdateCreativesWithBody(ctx context.Context, params *UpdateCreativesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCreatives(ctx context.Context, params *UpdateCreativesParams, body UpdateCreativesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCreativePreviewWithBody request with any body
	PostCreativePreviewWithBody(ctx context.Context, params *PostCreativePreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCreativePreview(ctx context.Context, params *PostCreativePreviewParams, body PostCreativePreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSDForecastWithBody request with any body
	CreateSDForecastWithBody(ctx context.Context, params *CreateSDForecastParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSDForecastWithApplicationVndSdforecastsV30PlusJSONBody(ctx context.Context, params *CreateSDForecastParams, body CreateSDForecastApplicationVndSdforecastsV30PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLocations request
	ListLocations(ctx context.Context, params *ListLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLocationsWithBody request with any body
	CreateLocationsWithBody(ctx context.Context, params *CreateLocationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLocations(ctx context.Context, params *CreateLocationsParams, body CreateLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCreativeModerations request
	ListCreativeModerations(ctx context.Context, params *ListCreativeModerationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNegativeTargetingClauses request
	ListNegativeTargetingClauses(ctx context.Context, params *ListNegativeTargetingClausesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNegativeTargetingClausesWithBody request with any body
	CreateNegativeTargetingClausesWithBody(ctx context.Context, params *CreateNegativeTargetingClausesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNegativeTargetingClauses(ctx context.Context, params *CreateNegativeTargetingClausesParams, body CreateNegativeTargetingClausesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNegativeTargetingClausesWithBody request with any body
	UpdateNegativeTargetingClausesWithBody(ctx context.Context, params *UpdateNegativeTargetingClausesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNegativeTargetingClauses(ctx context.Context, params *UpdateNegativeTargetingClausesParams, body UpdateNegativeTargetingClausesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNegativeTargetingClausesEx request
	ListNegativeTargetingClausesEx(ctx context.Context, params *ListNegativeTargetingClausesExParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNegativeTargetsEx request
	GetNegativeTargetsEx(ctx context.Context, negativeTargetId int64, params *GetNegativeTargetsExParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveNegativeTargetingClause request
	ArchiveNegativeTargetingClause(ctx context.Context, negativeTargetId int64, params *ArchiveNegativeTargetingClauseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNegativeTargets request
	GetNegativeTargets(ctx context.Context, negativeTargetId int64, params *GetNegativeTargetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOptimizationRules request
	ListOptimizationRules(ctx context.Context, params *ListOptimizationRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOptimizationRulesWithBody request with any body
	CreateOptimizationRulesWithBody(ctx context.Context, params *CreateOptimizationRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOptimizationRules(ctx context.Context, params *CreateOptimizationRulesParams, body CreateOptimizationRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOptimizationRulesWithBody request with any body
	UpdateOptimizationRulesWithBody(ctx context.Context, params *UpdateOptimizationRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOptimizationRules(ctx context.Context, params *UpdateOptimizationRulesParams, body UpdateOptimizationRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSdOptimizationRulesOptimizationRuleId request
	GetSdOptimizationRulesOptimizationRuleId(ctx context.Context, optimizationRuleId string, params *GetSdOptimizationRulesOptimizationRuleIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProductAds request
	ListProductAds(ctx context.Context, params *ListProductAdsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProductAdsWithBody request with any body
	CreateProductAdsWithBody(ctx context.Context, params *CreateProductAdsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProductAds(ctx context.Context, params *CreateProductAdsParams, body CreateProductAdsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProductAdsWithBody request with any body
	UpdateProductAdsWithBody(ctx context.Context, params *UpdateProductAdsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProductAds(ctx context.Context, params *UpdateProductAdsParams, body UpdateProductAdsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProductAdsEx request
	ListProductAdsEx(ctx context.Context, params *ListProductAdsExParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductAdResponseEx request
	GetProductAdResponseEx(ctx context.Context, adId int64, params *GetProductAdResponseExParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveProductAd request
	ArchiveProductAd(ctx context.Context, adId int64, params *ArchiveProductAdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductAd request
	GetProductAd(ctx context.Context, adId int64, params *GetProductAdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSnapshot request
	GetSnapshot(ctx context.Context, snapshotId string, params *GetSnapshotParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadSnapshot request
	DownloadSnapshot(ctx context.Context, snapshotId string, params *DownloadSnapshotParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTargetingClauses request
	ListTargetingClauses(ctx context.Context, params *ListTargetingClausesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTargetingClausesWithBody request with any body
	CreateTargetingClausesWithBody(ctx context.Context, params *CreateTargetingClausesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTargetingClauses(ctx context.Context, params *CreateTargetingClausesParams, body CreateTargetingClausesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTargetingClausesWithBody request with any body
	UpdateTargetingClausesWithBody(ctx context.Context, params *UpdateTargetingClausesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTargetingClauses(ctx context.Context, params *UpdateTargetingClausesParams, body UpdateTargetingClausesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTargetBidRecommendationsWithBody request with any body
	GetTargetBidRecommendationsWithBody(ctx context.Context, params *GetTargetBidRecommendationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetTargetBidRecommendationsWithApplicationVndSdtargetingrecommendationsV31PlusJSONBody(ctx context.Context, params *GetTargetBidRecommendationsParams, body GetTargetBidRecommendationsApplicationVndSdtargetingrecommendationsV31PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetTargetBidRecommendationsWithApplicationVndSdtargetingrecommendationsV32PlusJSONBody(ctx context.Context, params *GetTargetBidRecommendationsParams, body GetTargetBidRecommendationsApplicationVndSdtargetingrecommendationsV32PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTargetingClausesEx request
	ListTargetingClausesEx(ctx context.Context, params *ListTargetingClausesExParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTargetsEx request
	GetTargetsEx(ctx context.Context, targetId int64, params *GetTargetsExParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTargetRecommendationsWithBody request with any body
	GetTargetRecommendationsWithBody(ctx context.Context, params *GetTargetRecommendationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetTargetRecommendationsWithApplicationVndSdtargetingrecommendationsV30PlusJSONBody(ctx context.Context, params *GetTargetRecommendationsParams, body GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV30PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetTargetRecommendationsWithApplicationVndSdtargetingrecommendationsV31PlusJSONBody(ctx context.Context, params *GetTargetRecommendationsParams, body GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV31PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetTargetRecommendationsWithApplicationVndSdtargetingrecommendationsV32PlusJSONBody(ctx context.Context, params *GetTargetRecommendationsParams, body GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV32PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetTargetRecommendationsWithApplicationVndSdtargetingrecommendationsV33PlusJSONBody(ctx context.Context, params *GetTargetRecommendationsParams, body GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV33PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveTargetingClause request
	ArchiveTargetingClause(ctx context.Context, targetId int64, params *ArchiveTargetingClauseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTargets request
	GetTargets(ctx context.Context, targetId int64, params *GetTargetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequestReportWithBody request with any body
	RequestReportWithBody(ctx context.Context, recordType RequestReportParamsRecordType, params *RequestReportParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RequestReport(ctx context.Context, recordType RequestReportParamsRecordType, params *RequestReportParams, body RequestReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSnapshotWithBody request with any body
	CreateSnapshotWithBody(ctx context.Context, recordType string, params *CreateSnapshotParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSnapshot(ctx context.Context, recordType string, params *CreateSnapshotParams, body CreateSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReportStatus request
	GetReportStatus(ctx context.Context, reportId string, params *GetReportStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadReport request
	DownloadReport(ctx context.Context, reportId string, params *DownloadReportParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListAdGroups(ctx context.Context, params *ListAdGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAdGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAdGroupsWithBody(ctx context.Context, params *CreateAdGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAdGroupsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAdGroups(ctx context.Context, params *CreateAdGroupsParams, body CreateAdGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAdGroupsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAdGroupsWithBody(ctx context.Context, params *UpdateAdGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAdGroupsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAdGroups(ctx context.Context, params *UpdateAdGroupsParams, body UpdateAdGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAdGroupsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAdGroupsEx(ctx context.Context, params *ListAdGroupsExParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAdGroupsExRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAdGroupResponseEx(ctx context.Context, adGroupId int64, params *GetAdGroupResponseExParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAdGroupResponseExRequest(c.Server, adGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveAdGroup(ctx context.Context, adGroupId int64, params *ArchiveAdGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveAdGroupRequest(c.Server, adGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAdGroup(ctx context.Context, adGroupId int64, params *GetAdGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAdGroupRequest(c.Server, adGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSdAdGroupsAdGroupIdOptimizationRules(ctx context.Context, adGroupId int64, params *GetSdAdGroupsAdGroupIdOptimizationRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSdAdGroupsAdGroupIdOptimizationRulesRequest(c.Server, adGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssociateOptimizationRulesWithAdGroupWithBody(ctx context.Context, adGroupId int64, params *AssociateOptimizationRulesWithAdGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssociateOptimizationRulesWithAdGroupRequestWithBody(c.Server, adGroupId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssociateOptimizationRulesWithAdGroup(ctx context.Context, adGroupId int64, params *AssociateOptimizationRulesWithAdGroupParams, body AssociateOptimizationRulesWithAdGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssociateOptimizationRulesWithAdGroupRequest(c.Server, adGroupId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBrandSafetyDenyList(ctx context.Context, params *DeleteBrandSafetyDenyListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBrandSafetyDenyListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDomains(ctx context.Context, params *ListDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDomainsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBrandSafetyDenyListDomainsWithBody(ctx context.Context, params *CreateBrandSafetyDenyListDomainsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBrandSafetyDenyListDomainsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBrandSafetyDenyListDomains(ctx context.Context, params *CreateBrandSafetyDenyListDomainsParams, body CreateBrandSafetyDenyListDomainsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBrandSafetyDenyListDomainsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRequestStatus(ctx context.Context, params *ListRequestStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRequestStatusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRequestResults(ctx context.Context, requestId string, params *GetRequestResultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRequestResultsRequest(c.Server, requestId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRequestStatus(ctx context.Context, requestId string, params *GetRequestStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRequestStatusRequest(c.Server, requestId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSDBudgetRulesForAdvertiser(ctx context.Context, params *GetSDBudgetRulesForAdvertiserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSDBudgetRulesForAdvertiserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBudgetRulesForSDCampaignsWithBody(ctx context.Context, params *CreateBudgetRulesForSDCampaignsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBudgetRulesForSDCampaignsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBudgetRulesForSDCampaigns(ctx context.Context, params *CreateBudgetRulesForSDCampaignsParams, body CreateBudgetRulesForSDCampaignsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBudgetRulesForSDCampaignsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBudgetRulesForSDCampaignsWithBody(ctx context.Context, params *UpdateBudgetRulesForSDCampaignsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBudgetRulesForSDCampaignsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBudgetRulesForSDCampaigns(ctx context.Context, params *UpdateBudgetRulesForSDCampaignsParams, body UpdateBudgetRulesForSDCampaignsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBudgetRulesForSDCampaignsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBudgetRuleByRuleIdForSDCampaigns(ctx context.Context, budgetRuleId string, params *GetBudgetRuleByRuleIdForSDCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBudgetRuleByRuleIdForSDCampaignsRequest(c.Server, budgetRuleId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCampaigns(ctx context.Context, params *ListCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCampaignsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCampaignsWithBody(ctx context.Context, params *CreateCampaignsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCampaignsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCampaigns(ctx context.Context, params *CreateCampaignsParams, body CreateCampaignsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCampaignsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCampaignsWithBody(ctx context.Context, params *UpdateCampaignsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCampaignsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCampaigns(ctx context.Context, params *UpdateCampaignsParams, body UpdateCampaignsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCampaignsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SdCampaignsBudgetUsageWithBody(ctx context.Context, params *SdCampaignsBudgetUsageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSdCampaignsBudgetUsageRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SdCampaignsBudgetUsageWithApplicationVndSdcampaignbudgetusageV1PlusJSONBody(ctx context.Context, params *SdCampaignsBudgetUsageParams, body SdCampaignsBudgetUsageApplicationVndSdcampaignbudgetusageV1PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSdCampaignsBudgetUsageRequestWithApplicationVndSdcampaignbudgetusageV1PlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCampaignsEx(ctx context.Context, params *ListCampaignsExParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCampaignsExRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCampaignResponseEx(ctx context.Context, campaignId int64, params *GetCampaignResponseExParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCampaignResponseExRequest(c.Server, campaignId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveCampaign(ctx context.Context, campaignId int64, params *ArchiveCampaignParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveCampaignRequest(c.Server, campaignId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCampaign(ctx context.Context, campaignId int64, params *GetCampaignParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCampaignRequest(c.Server, campaignId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleBasedBudgetHistoryForSDCampaigns(ctx context.Context, campaignId int64, params *GetRuleBasedBudgetHistoryForSDCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleBasedBudgetHistoryForSDCampaignsRequest(c.Server, campaignId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCreatives(ctx context.Context, params *ListCreativesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCreativesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCreativesWithBody(ctx context.Context, params *CreateCreativesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCreativesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCreatives(ctx context.Context, params *CreateCreativesParams, body CreateCreativesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCreativesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCreativesWithBody(ctx context.Context, params *UpdateCreativesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCreativesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCreatives(ctx context.Context, params *UpdateCreativesParams, body UpdateCreativesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCreativesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCreativePreviewWithBody(ctx context.Context, params *PostCreativePreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCreativePreviewRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCreativePreview(ctx context.Context, params *PostCreativePreviewParams, body PostCreativePreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCreativePreviewRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSDForecastWithBody(ctx context.Context, params *CreateSDForecastParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSDForecastRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSDForecastWithApplicationVndSdforecastsV30PlusJSONBody(ctx context.Context, params *CreateSDForecastParams, body CreateSDForecastApplicationVndSdforecastsV30PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSDForecastRequestWithApplicationVndSdforecastsV30PlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLocations(ctx context.Context, params *ListLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLocationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLocationsWithBody(ctx context.Context, params *CreateLocationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLocationsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLocations(ctx context.Context, params *CreateLocationsParams, body CreateLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLocationsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCreativeModerations(ctx context.Context, params *ListCreativeModerationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCreativeModerationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNegativeTargetingClauses(ctx context.Context, params *ListNegativeTargetingClausesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNegativeTargetingClausesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNegativeTargetingClausesWithBody(ctx context.Context, params *CreateNegativeTargetingClausesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNegativeTargetingClausesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNegativeTargetingClauses(ctx context.Context, params *CreateNegativeTargetingClausesParams, body CreateNegativeTargetingClausesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNegativeTargetingClausesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNegativeTargetingClausesWithBody(ctx context.Context, params *UpdateNegativeTargetingClausesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNegativeTargetingClausesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNegativeTargetingClauses(ctx context.Context, params *UpdateNegativeTargetingClausesParams, body UpdateNegativeTargetingClausesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNegativeTargetingClausesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNegativeTargetingClausesEx(ctx context.Context, params *ListNegativeTargetingClausesExParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNegativeTargetingClausesExRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNegativeTargetsEx(ctx context.Context, negativeTargetId int64, params *GetNegativeTargetsExParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNegativeTargetsExRequest(c.Server, negativeTargetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveNegativeTargetingClause(ctx context.Context, negativeTargetId int64, params *ArchiveNegativeTargetingClauseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveNegativeTargetingClauseRequest(c.Server, negativeTargetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNegativeTargets(ctx context.Context, negativeTargetId int64, params *GetNegativeTargetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNegativeTargetsRequest(c.Server, negativeTargetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOptimizationRules(ctx context.Context, params *ListOptimizationRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOptimizationRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOptimizationRulesWithBody(ctx context.Context, params *CreateOptimizationRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOptimizationRulesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOptimizationRules(ctx context.Context, params *CreateOptimizationRulesParams, body CreateOptimizationRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOptimizationRulesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOptimizationRulesWithBody(ctx context.Context, params *UpdateOptimizationRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOptimizationRulesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOptimizationRules(ctx context.Context, params *UpdateOptimizationRulesParams, body UpdateOptimizationRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOptimizationRulesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSdOptimizationRulesOptimizationRuleId(ctx context.Context, optimizationRuleId string, params *GetSdOptimizationRulesOptimizationRuleIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSdOptimizationRulesOptimizationRuleIdRequest(c.Server, optimizationRuleId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProductAds(ctx context.Context, params *ListProductAdsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProductAdsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProductAdsWithBody(ctx context.Context, params *CreateProductAdsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProductAdsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProductAds(ctx context.Context, params *CreateProductAdsParams, body CreateProductAdsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProductAdsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProductAdsWithBody(ctx context.Context, params *UpdateProductAdsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProductAdsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProductAds(ctx context.Context, params *UpdateProductAdsParams, body UpdateProductAdsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProductAdsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProductAdsEx(ctx context.Context, params *ListProductAdsExParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProductAdsExRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductAdResponseEx(ctx context.Context, adId int64, params *GetProductAdResponseExParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductAdResponseExRequest(c.Server, adId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveProductAd(ctx context.Context, adId int64, params *ArchiveProductAdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveProductAdRequest(c.Server, adId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductAd(ctx context.Context, adId int64, params *GetProductAdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductAdRequest(c.Server, adId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSnapshot(ctx context.Context, snapshotId string, params *GetSnapshotParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSnapshotRequest(c.Server, snapshotId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadSnapshot(ctx context.Context, snapshotId string, params *DownloadSnapshotParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadSnapshotRequest(c.Server, snapshotId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTargetingClauses(ctx context.Context, params *ListTargetingClausesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTargetingClausesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTargetingClausesWithBody(ctx context.Context, params *CreateTargetingClausesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTargetingClausesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTargetingClauses(ctx context.Context, params *CreateTargetingClausesParams, body CreateTargetingClausesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTargetingClausesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTargetingClausesWithBody(ctx context.Context, params *UpdateTargetingClausesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTargetingClausesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTargetingClauses(ctx context.Context, params *UpdateTargetingClausesParams, body UpdateTargetingClausesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTargetingClausesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTargetBidRecommendationsWithBody(ctx context.Context, params *GetTargetBidRecommendationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTargetBidRecommendationsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTargetBidRecommendationsWithApplicationVndSdtargetingrecommendationsV31PlusJSONBody(ctx context.Context, params *GetTargetBidRecommendationsParams, body GetTargetBidRecommendationsApplicationVndSdtargetingrecommendationsV31PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTargetBidRecommendationsRequestWithApplicationVndSdtargetingrecommendationsV31PlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTargetBidRecommendationsWithApplicationVndSdtargetingrecommendationsV32PlusJSONBody(ctx context.Context, params *GetTargetBidRecommendationsParams, body GetTargetBidRecommendationsApplicationVndSdtargetingrecommendationsV32PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTargetBidRecommendationsRequestWithApplicationVndSdtargetingrecommendationsV32PlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTargetingClausesEx(ctx context.Context, params *ListTargetingClausesExParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTargetingClausesExRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTargetsEx(ctx context.Context, targetId int64, params *GetTargetsExParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTargetsExRequest(c.Server, targetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTargetRecommendationsWithBody(ctx context.Context, params *GetTargetRecommendationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTargetRecommendationsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTargetRecommendationsWithApplicationVndSdtargetingrecommendationsV30PlusJSONBody(ctx context.Context, params *GetTargetRecommendationsParams, body GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV30PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTargetRecommendationsRequestWithApplicationVndSdtargetingrecommendationsV30PlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTargetRecommendationsWithApplicationVndSdtargetingrecommendationsV31PlusJSONBody(ctx context.Context, params *GetTargetRecommendationsParams, body GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV31PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTargetRecommendationsRequestWithApplicationVndSdtargetingrecommendationsV31PlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTargetRecommendationsWithApplicationVndSdtargetingrecommendationsV32PlusJSONBody(ctx context.Context, params *GetTargetRecommendationsParams, body GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV32PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTargetRecommendationsRequestWithApplicationVndSdtargetingrecommendationsV32PlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTargetRecommendationsWithApplicationVndSdtargetingrecommendationsV33PlusJSONBody(ctx context.Context, params *GetTargetRecommendationsParams, body GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV33PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTargetRecommendationsRequestWithApplicationVndSdtargetingrecommendationsV33PlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveTargetingClause(ctx context.Context, targetId int64, params *ArchiveTargetingClauseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveTargetingClauseRequest(c.Server, targetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTargets(ctx context.Context, targetId int64, params *GetTargetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTargetsRequest(c.Server, targetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestReportWithBody(ctx context.Context, recordType RequestReportParamsRecordType, params *RequestReportParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestReportRequestWithBody(c.Server, recordType, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestReport(ctx context.Context, recordType RequestReportParamsRecordType, params *RequestReportParams, body RequestReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestReportRequest(c.Server, recordType, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSnapshotWithBody(ctx context.Context, recordType string, params *CreateSnapshotParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSnapshotRequestWithBody(c.Server, recordType, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSnapshot(ctx context.Context, recordType string, params *CreateSnapshotParams, body CreateSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSnapshotRequest(c.Server, recordType, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReportStatus(ctx context.Context, reportId string, params *GetReportStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReportStatusRequest(c.Server, reportId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadReport(ctx context.Context, reportId string, params *DownloadReportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadReportRequest(c.Server, reportId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAdGroupsRequest generates requests for ListAdGroups
func NewListAdGroupsRequest(server string, params *ListAdGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/adGroups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateFilter", runtime.ParamLocationQuery, *params.StateFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CampaignIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "campaignIdFilter", runtime.ParamLocationQuery, *params.CampaignIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdGroupIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adGroupIdFilter", runtime.ParamLocationQuery, *params.AdGroupIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewCreateAdGroupsRequest calls the generic CreateAdGroups builder with application/json body
func NewCreateAdGroupsRequest(server string, params *CreateAdGroupsParams, body CreateAdGroupsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAdGroupsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateAdGroupsRequestWithBody generates requests for CreateAdGroups with any type of body
func NewCreateAdGroupsRequestWithBody(server string, params *CreateAdGroupsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/adGroups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewUpdateAdGroupsRequest calls the generic UpdateAdGroups builder with application/json body
func NewUpdateAdGroupsRequest(server string, params *UpdateAdGroupsParams, body UpdateAdGroupsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAdGroupsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateAdGroupsRequestWithBody generates requests for UpdateAdGroups with any type of body
func NewUpdateAdGroupsRequestWithBody(server string, params *UpdateAdGroupsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/adGroups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewListAdGroupsExRequest generates requests for ListAdGroupsEx
func NewListAdGroupsExRequest(server string, params *ListAdGroupsExParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/adGroups/extended")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateFilter", runtime.ParamLocationQuery, *params.StateFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CampaignIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "campaignIdFilter", runtime.ParamLocationQuery, *params.CampaignIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdGroupIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adGroupIdFilter", runtime.ParamLocationQuery, *params.AdGroupIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewGetAdGroupResponseExRequest generates requests for GetAdGroupResponseEx
func NewGetAdGroupResponseExRequest(server string, adGroupId int64, params *GetAdGroupResponseExParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "adGroupId", runtime.ParamLocationPath, adGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/adGroups/extended/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewArchiveAdGroupRequest generates requests for ArchiveAdGroup
func NewArchiveAdGroupRequest(server string, adGroupId int64, params *ArchiveAdGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "adGroupId", runtime.ParamLocationPath, adGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/adGroups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewGetAdGroupRequest generates requests for GetAdGroup
func NewGetAdGroupRequest(server string, adGroupId int64, params *GetAdGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "adGroupId", runtime.ParamLocationPath, adGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/adGroups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewGetSdAdGroupsAdGroupIdOptimizationRulesRequest generates requests for GetSdAdGroupsAdGroupIdOptimizationRules
func NewGetSdAdGroupsAdGroupIdOptimizationRulesRequest(server string, adGroupId int64, params *GetSdAdGroupsAdGroupIdOptimizationRulesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "adGroupId", runtime.ParamLocationPath, adGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/adGroups/%s/optimizationRules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewAssociateOptimizationRulesWithAdGroupRequest calls the generic AssociateOptimizationRulesWithAdGroup builder with application/json body
func NewAssociateOptimizationRulesWithAdGroupRequest(server string, adGroupId int64, params *AssociateOptimizationRulesWithAdGroupParams, body AssociateOptimizationRulesWithAdGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssociateOptimizationRulesWithAdGroupRequestWithBody(server, adGroupId, params, "application/json", bodyReader)
}

// NewAssociateOptimizationRulesWithAdGroupRequestWithBody generates requests for AssociateOptimizationRulesWithAdGroup with any type of body
func NewAssociateOptimizationRulesWithAdGroupRequestWithBody(server string, adGroupId int64, params *AssociateOptimizationRulesWithAdGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "adGroupId", runtime.ParamLocationPath, adGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/adGroups/%s/optimizationRules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewDeleteBrandSafetyDenyListRequest generates requests for DeleteBrandSafetyDenyList
func NewDeleteBrandSafetyDenyListRequest(server string, params *DeleteBrandSafetyDenyListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/brandSafety/deny")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewListDomainsRequest generates requests for ListDomains
func NewListDomainsRequest(server string, params *ListDomainsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/brandSafety/deny")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewCreateBrandSafetyDenyListDomainsRequest calls the generic CreateBrandSafetyDenyListDomains builder with application/json body
func NewCreateBrandSafetyDenyListDomainsRequest(server string, params *CreateBrandSafetyDenyListDomainsParams, body CreateBrandSafetyDenyListDomainsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBrandSafetyDenyListDomainsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateBrandSafetyDenyListDomainsRequestWithBody generates requests for CreateBrandSafetyDenyListDomains with any type of body
func NewCreateBrandSafetyDenyListDomainsRequestWithBody(server string, params *CreateBrandSafetyDenyListDomainsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/brandSafety/deny")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewListRequestStatusRequest generates requests for ListRequestStatus
func NewListRequestStatusRequest(server string, params *ListRequestStatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/brandSafety/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewGetRequestResultsRequest generates requests for GetRequestResults
func NewGetRequestResultsRequest(server string, requestId string, params *GetRequestResultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "requestId", runtime.ParamLocationPath, requestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/brandSafety/%s/results", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewGetRequestStatusRequest generates requests for GetRequestStatus
func NewGetRequestStatusRequest(server string, requestId string, params *GetRequestStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "requestId", runtime.ParamLocationPath, requestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/brandSafety/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewGetSDBudgetRulesForAdvertiserRequest generates requests for GetSDBudgetRulesForAdvertiser
func NewGetSDBudgetRulesForAdvertiserRequest(server string, params *GetSDBudgetRulesForAdvertiserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/budgetRules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewCreateBudgetRulesForSDCampaignsRequest calls the generic CreateBudgetRulesForSDCampaigns builder with application/json body
func NewCreateBudgetRulesForSDCampaignsRequest(server string, params *CreateBudgetRulesForSDCampaignsParams, body CreateBudgetRulesForSDCampaignsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBudgetRulesForSDCampaignsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateBudgetRulesForSDCampaignsRequestWithBody generates requests for CreateBudgetRulesForSDCampaigns with any type of body
func NewCreateBudgetRulesForSDCampaignsRequestWithBody(server string, params *CreateBudgetRulesForSDCampaignsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/budgetRules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewUpdateBudgetRulesForSDCampaignsRequest calls the generic UpdateBudgetRulesForSDCampaigns builder with application/json body
func NewUpdateBudgetRulesForSDCampaignsRequest(server string, params *UpdateBudgetRulesForSDCampaignsParams, body UpdateBudgetRulesForSDCampaignsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBudgetRulesForSDCampaignsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateBudgetRulesForSDCampaignsRequestWithBody generates requests for UpdateBudgetRulesForSDCampaigns with any type of body
func NewUpdateBudgetRulesForSDCampaignsRequestWithBody(server string, params *UpdateBudgetRulesForSDCampaignsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/budgetRules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewGetBudgetRuleByRuleIdForSDCampaignsRequest generates requests for GetBudgetRuleByRuleIdForSDCampaigns
func NewGetBudgetRuleByRuleIdForSDCampaignsRequest(server string, budgetRuleId string, params *GetBudgetRuleByRuleIdForSDCampaignsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budgetRuleId", runtime.ParamLocationPath, budgetRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/budgetRules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewListCampaignsRequest generates requests for ListCampaigns
func NewListCampaignsRequest(server string, params *ListCampaignsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/campaigns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateFilter", runtime.ParamLocationQuery, *params.StateFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CampaignIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "campaignIdFilter", runtime.ParamLocationQuery, *params.CampaignIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PortfolioIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "portfolioIdFilter", runtime.ParamLocationQuery, *params.PortfolioIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewCreateCampaignsRequest calls the generic CreateCampaigns builder with application/json body
func NewCreateCampaignsRequest(server string, params *CreateCampaignsParams, body CreateCampaignsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCampaignsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateCampaignsRequestWithBody generates requests for CreateCampaigns with any type of body
func NewCreateCampaignsRequestWithBody(server string, params *CreateCampaignsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/campaigns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewUpdateCampaignsRequest calls the generic UpdateCampaigns builder with application/json body
func NewUpdateCampaignsRequest(server string, params *UpdateCampaignsParams, body UpdateCampaignsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCampaignsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateCampaignsRequestWithBody generates requests for UpdateCampaigns with any type of body
func NewUpdateCampaignsRequestWithBody(server string, params *UpdateCampaignsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/campaigns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewSdCampaignsBudgetUsageRequestWithApplicationVndSdcampaignbudgetusageV1PlusJSONBody calls the generic SdCampaignsBudgetUsage builder with application/vnd.sdcampaignbudgetusage.v1+json body
func NewSdCampaignsBudgetUsageRequestWithApplicationVndSdcampaignbudgetusageV1PlusJSONBody(server string, params *SdCampaignsBudgetUsageParams, body SdCampaignsBudgetUsageApplicationVndSdcampaignbudgetusageV1PlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSdCampaignsBudgetUsageRequestWithBody(server, params, "application/vnd.sdcampaignbudgetusage.v1+json", bodyReader)
}

// NewSdCampaignsBudgetUsageRequestWithBody generates requests for SdCampaignsBudgetUsage with any type of body
func NewSdCampaignsBudgetUsageRequestWithBody(server string, params *SdCampaignsBudgetUsageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/campaigns/budget/usage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewListCampaignsExRequest generates requests for ListCampaignsEx
func NewListCampaignsExRequest(server string, params *ListCampaignsExParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/campaigns/extended")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateFilter", runtime.ParamLocationQuery, *params.StateFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CampaignIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "campaignIdFilter", runtime.ParamLocationQuery, *params.CampaignIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PortfolioIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "portfolioIdFilter", runtime.ParamLocationQuery, *params.PortfolioIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewGetCampaignResponseExRequest generates requests for GetCampaignResponseEx
func NewGetCampaignResponseExRequest(server string, campaignId int64, params *GetCampaignResponseExParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "campaignId", runtime.ParamLocationPath, campaignId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/campaigns/extended/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewArchiveCampaignRequest generates requests for ArchiveCampaign
func NewArchiveCampaignRequest(server string, campaignId int64, params *ArchiveCampaignParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "campaignId", runtime.ParamLocationPath, campaignId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/campaigns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewGetCampaignRequest generates requests for GetCampaign
func NewGetCampaignRequest(server string, campaignId int64, params *GetCampaignParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "campaignId", runtime.ParamLocationPath, campaignId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/campaigns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewGetRuleBasedBudgetHistoryForSDCampaignsRequest generates requests for GetRuleBasedBudgetHistoryForSDCampaigns
func NewGetRuleBasedBudgetHistoryForSDCampaignsRequest(server string, campaignId int64, params *GetRuleBasedBudgetHistoryForSDCampaignsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "campaignId", runtime.ParamLocationPath, campaignId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/campaigns/%s/budgetRules/budgetHistory", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, params.StartDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, params.EndDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewListCreativesRequest generates requests for ListCreatives
func NewListCreativesRequest(server string, params *ListCreativesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/creatives")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdGroupIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adGroupIdFilter", runtime.ParamLocationQuery, *params.AdGroupIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreativeIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creativeIdFilter", runtime.ParamLocationQuery, *params.CreativeIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewCreateCreativesRequest calls the generic CreateCreatives builder with application/json body
func NewCreateCreativesRequest(server string, params *CreateCreativesParams, body CreateCreativesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCreativesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateCreativesRequestWithBody generates requests for CreateCreatives with any type of body
func NewCreateCreativesRequestWithBody(server string, params *CreateCreativesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/creatives")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewUpdateCreativesRequest calls the generic UpdateCreatives builder with application/json body
func NewUpdateCreativesRequest(server string, params *UpdateCreativesParams, body UpdateCreativesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCreativesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateCreativesRequestWithBody generates requests for UpdateCreatives with any type of body
func NewUpdateCreativesRequestWithBody(server string, params *UpdateCreativesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/creatives")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewPostCreativePreviewRequest calls the generic PostCreativePreview builder with application/json body
func NewPostCreativePreviewRequest(server string, params *PostCreativePreviewParams, body PostCreativePreviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCreativePreviewRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostCreativePreviewRequestWithBody generates requests for PostCreativePreview with any type of body
func NewPostCreativePreviewRequestWithBody(server string, params *PostCreativePreviewParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/creatives/preview")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewCreateSDForecastRequestWithApplicationVndSdforecastsV30PlusJSONBody calls the generic CreateSDForecast builder with application/vnd.sdforecasts.v3.0+json body
func NewCreateSDForecastRequestWithApplicationVndSdforecastsV30PlusJSONBody(server string, params *CreateSDForecastParams, body CreateSDForecastApplicationVndSdforecastsV30PlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSDForecastRequestWithBody(server, params, "application/vnd.sdforecasts.v3.0+json", bodyReader)
}

// NewCreateSDForecastRequestWithBody generates requests for CreateSDForecast with any type of body
func NewCreateSDForecastRequestWithBody(server string, params *CreateSDForecastParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/forecasts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewListLocationsRequest generates requests for ListLocations
func NewListLocationsRequest(server string, params *ListLocationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/locations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateFilter", runtime.ParamLocationQuery, *params.StateFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdGroupIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adGroupIdFilter", runtime.ParamLocationQuery, *params.AdGroupIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CampaignIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "campaignIdFilter", runtime.ParamLocationQuery, *params.CampaignIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewCreateLocationsRequest calls the generic CreateLocations builder with application/json body
func NewCreateLocationsRequest(server string, params *CreateLocationsParams, body CreateLocationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLocationsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateLocationsRequestWithBody generates requests for CreateLocations with any type of body
func NewCreateLocationsRequestWithBody(server string, params *CreateLocationsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/locations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewListCreativeModerationsRequest generates requests for ListCreativeModerations
func NewListCreativeModerationsRequest(server string, params *ListCreativeModerationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/moderation/creatives")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdGroupIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adGroupIdFilter", runtime.ParamLocationQuery, *params.AdGroupIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreativeIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creativeIdFilter", runtime.ParamLocationQuery, *params.CreativeIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewListNegativeTargetingClausesRequest generates requests for ListNegativeTargetingClauses
func NewListNegativeTargetingClausesRequest(server string, params *ListNegativeTargetingClausesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/negativeTargets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateFilter", runtime.ParamLocationQuery, *params.StateFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdGroupIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adGroupIdFilter", runtime.ParamLocationQuery, *params.AdGroupIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CampaignIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "campaignIdFilter", runtime.ParamLocationQuery, *params.CampaignIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewCreateNegativeTargetingClausesRequest calls the generic CreateNegativeTargetingClauses builder with application/json body
func NewCreateNegativeTargetingClausesRequest(server string, params *CreateNegativeTargetingClausesParams, body CreateNegativeTargetingClausesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNegativeTargetingClausesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateNegativeTargetingClausesRequestWithBody generates requests for CreateNegativeTargetingClauses with any type of body
func NewCreateNegativeTargetingClausesRequestWithBody(server string, params *CreateNegativeTargetingClausesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/negativeTargets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewUpdateNegativeTargetingClausesRequest calls the generic UpdateNegativeTargetingClauses builder with application/json body
func NewUpdateNegativeTargetingClausesRequest(server string, params *UpdateNegativeTargetingClausesParams, body UpdateNegativeTargetingClausesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNegativeTargetingClausesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateNegativeTargetingClausesRequestWithBody generates requests for UpdateNegativeTargetingClauses with any type of body
func NewUpdateNegativeTargetingClausesRequestWithBody(server string, params *UpdateNegativeTargetingClausesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/negativeTargets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewListNegativeTargetingClausesExRequest generates requests for ListNegativeTargetingClausesEx
func NewListNegativeTargetingClausesExRequest(server string, params *ListNegativeTargetingClausesExParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/negativeTargets/extended")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateFilter", runtime.ParamLocationQuery, *params.StateFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "targetIdFilter", runtime.ParamLocationQuery, *params.TargetIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdGroupIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adGroupIdFilter", runtime.ParamLocationQuery, *params.AdGroupIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CampaignIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "campaignIdFilter", runtime.ParamLocationQuery, *params.CampaignIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewGetNegativeTargetsExRequest generates requests for GetNegativeTargetsEx
func NewGetNegativeTargetsExRequest(server string, negativeTargetId int64, params *GetNegativeTargetsExParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "negativeTargetId", runtime.ParamLocationPath, negativeTargetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/negativeTargets/extended/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewArchiveNegativeTargetingClauseRequest generates requests for ArchiveNegativeTargetingClause
func NewArchiveNegativeTargetingClauseRequest(server string, negativeTargetId int64, params *ArchiveNegativeTargetingClauseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "negativeTargetId", runtime.ParamLocationPath, negativeTargetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/negativeTargets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewGetNegativeTargetsRequest generates requests for GetNegativeTargets
func NewGetNegativeTargetsRequest(server string, negativeTargetId int64, params *GetNegativeTargetsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "negativeTargetId", runtime.ParamLocationPath, negativeTargetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/negativeTargets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewListOptimizationRulesRequest generates requests for ListOptimizationRules
func NewListOptimizationRulesRequest(server string, params *ListOptimizationRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/optimizationRules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateFilter", runtime.ParamLocationQuery, *params.StateFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OptimizationRuleIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "optimizationRuleIdFilter", runtime.ParamLocationQuery, *params.OptimizationRuleIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdGroupIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adGroupIdFilter", runtime.ParamLocationQuery, *params.AdGroupIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewCreateOptimizationRulesRequest calls the generic CreateOptimizationRules builder with application/json body
func NewCreateOptimizationRulesRequest(server string, params *CreateOptimizationRulesParams, body CreateOptimizationRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOptimizationRulesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOptimizationRulesRequestWithBody generates requests for CreateOptimizationRules with any type of body
func NewCreateOptimizationRulesRequestWithBody(server string, params *CreateOptimizationRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/optimizationRules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewUpdateOptimizationRulesRequest calls the generic UpdateOptimizationRules builder with application/json body
func NewUpdateOptimizationRulesRequest(server string, params *UpdateOptimizationRulesParams, body UpdateOptimizationRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOptimizationRulesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateOptimizationRulesRequestWithBody generates requests for UpdateOptimizationRules with any type of body
func NewUpdateOptimizationRulesRequestWithBody(server string, params *UpdateOptimizationRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/optimizationRules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewGetSdOptimizationRulesOptimizationRuleIdRequest generates requests for GetSdOptimizationRulesOptimizationRuleId
func NewGetSdOptimizationRulesOptimizationRuleIdRequest(server string, optimizationRuleId string, params *GetSdOptimizationRulesOptimizationRuleIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "optimizationRuleId", runtime.ParamLocationPath, optimizationRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/optimizationRules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewListProductAdsRequest generates requests for ListProductAds
func NewListProductAdsRequest(server string, params *ListProductAdsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/productAds")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateFilter", runtime.ParamLocationQuery, *params.StateFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adIdFilter", runtime.ParamLocationQuery, *params.AdIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdGroupIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adGroupIdFilter", runtime.ParamLocationQuery, *params.AdGroupIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CampaignIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "campaignIdFilter", runtime.ParamLocationQuery, *params.CampaignIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewCreateProductAdsRequest calls the generic CreateProductAds builder with application/json body
func NewCreateProductAdsRequest(server string, params *CreateProductAdsParams, body CreateProductAdsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProductAdsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateProductAdsRequestWithBody generates requests for CreateProductAds with any type of body
func NewCreateProductAdsRequestWithBody(server string, params *CreateProductAdsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/productAds")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewUpdateProductAdsRequest calls the generic UpdateProductAds builder with application/json body
func NewUpdateProductAdsRequest(server string, params *UpdateProductAdsParams, body UpdateProductAdsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProductAdsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateProductAdsRequestWithBody generates requests for UpdateProductAds with any type of body
func NewUpdateProductAdsRequestWithBody(server string, params *UpdateProductAdsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/productAds")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewListProductAdsExRequest generates requests for ListProductAdsEx
func NewListProductAdsExRequest(server string, params *ListProductAdsExParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/productAds/extended")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateFilter", runtime.ParamLocationQuery, *params.StateFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adIdFilter", runtime.ParamLocationQuery, *params.AdIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdGroupIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adGroupIdFilter", runtime.ParamLocationQuery, *params.AdGroupIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CampaignIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "campaignIdFilter", runtime.ParamLocationQuery, *params.CampaignIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewGetProductAdResponseExRequest generates requests for GetProductAdResponseEx
func NewGetProductAdResponseExRequest(server string, adId int64, params *GetProductAdResponseExParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "adId", runtime.ParamLocationPath, adId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/productAds/extended/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewArchiveProductAdRequest generates requests for ArchiveProductAd
func NewArchiveProductAdRequest(server string, adId int64, params *ArchiveProductAdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "adId", runtime.ParamLocationPath, adId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/productAds/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewGetProductAdRequest generates requests for GetProductAd
func NewGetProductAdRequest(server string, adId int64, params *GetProductAdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "adId", runtime.ParamLocationPath, adId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/productAds/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewGetSnapshotRequest generates requests for GetSnapshot
func NewGetSnapshotRequest(server string, snapshotId string, params *GetSnapshotParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "snapshotId", runtime.ParamLocationPath, snapshotId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/snapshots/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewDownloadSnapshotRequest generates requests for DownloadSnapshot
func NewDownloadSnapshotRequest(server string, snapshotId string, params *DownloadSnapshotParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "snapshotId", runtime.ParamLocationPath, snapshotId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/snapshots/%s/download", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewListTargetingClausesRequest generates requests for ListTargetingClauses
func NewListTargetingClausesRequest(server string, params *ListTargetingClausesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/targets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateFilter", runtime.ParamLocationQuery, *params.StateFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdGroupIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adGroupIdFilter", runtime.ParamLocationQuery, *params.AdGroupIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CampaignIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "campaignIdFilter", runtime.ParamLocationQuery, *params.CampaignIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewCreateTargetingClausesRequest calls the generic CreateTargetingClauses builder with application/json body
func NewCreateTargetingClausesRequest(server string, params *CreateTargetingClausesParams, body CreateTargetingClausesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTargetingClausesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateTargetingClausesRequestWithBody generates requests for CreateTargetingClauses with any type of body
func NewCreateTargetingClausesRequestWithBody(server string, params *CreateTargetingClausesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/targets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewUpdateTargetingClausesRequest calls the generic UpdateTargetingClauses builder with application/json body
func NewUpdateTargetingClausesRequest(server string, params *UpdateTargetingClausesParams, body UpdateTargetingClausesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTargetingClausesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateTargetingClausesRequestWithBody generates requests for UpdateTargetingClauses with any type of body
func NewUpdateTargetingClausesRequestWithBody(server string, params *UpdateTargetingClausesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/targets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewGetTargetBidRecommendationsRequestWithApplicationVndSdtargetingrecommendationsV31PlusJSONBody calls the generic GetTargetBidRecommendations builder with application/vnd.sdtargetingrecommendations.v3.1+json body
func NewGetTargetBidRecommendationsRequestWithApplicationVndSdtargetingrecommendationsV31PlusJSONBody(server string, params *GetTargetBidRecommendationsParams, body GetTargetBidRecommendationsApplicationVndSdtargetingrecommendationsV31PlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetTargetBidRecommendationsRequestWithBody(server, params, "application/vnd.sdtargetingrecommendations.v3.1+json", bodyReader)
}

// NewGetTargetBidRecommendationsRequestWithApplicationVndSdtargetingrecommendationsV32PlusJSONBody calls the generic GetTargetBidRecommendations builder with application/vnd.sdtargetingrecommendations.v3.2+json body
func NewGetTargetBidRecommendationsRequestWithApplicationVndSdtargetingrecommendationsV32PlusJSONBody(server string, params *GetTargetBidRecommendationsParams, body GetTargetBidRecommendationsApplicationVndSdtargetingrecommendationsV32PlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetTargetBidRecommendationsRequestWithBody(server, params, "application/vnd.sdtargetingrecommendations.v3.2+json", bodyReader)
}

// NewGetTargetBidRecommendationsRequestWithBody generates requests for GetTargetBidRecommendations with any type of body
func NewGetTargetBidRecommendationsRequestWithBody(server string, params *GetTargetBidRecommendationsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/targets/bid/recommendations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewListTargetingClausesExRequest generates requests for ListTargetingClausesEx
func NewListTargetingClausesExRequest(server string, params *ListTargetingClausesExParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/targets/extended")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateFilter", runtime.ParamLocationQuery, *params.StateFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "targetIdFilter", runtime.ParamLocationQuery, *params.TargetIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdGroupIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adGroupIdFilter", runtime.ParamLocationQuery, *params.AdGroupIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CampaignIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "campaignIdFilter", runtime.ParamLocationQuery, *params.CampaignIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewGetTargetsExRequest generates requests for GetTargetsEx
func NewGetTargetsExRequest(server string, targetId int64, params *GetTargetsExParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "targetId", runtime.ParamLocationPath, targetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/targets/extended/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewGetTargetRecommendationsRequestWithApplicationVndSdtargetingrecommendationsV30PlusJSONBody calls the generic GetTargetRecommendations builder with application/vnd.sdtargetingrecommendations.v3.0+json body
func NewGetTargetRecommendationsRequestWithApplicationVndSdtargetingrecommendationsV30PlusJSONBody(server string, params *GetTargetRecommendationsParams, body GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV30PlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetTargetRecommendationsRequestWithBody(server, params, "application/vnd.sdtargetingrecommendations.v3.0+json", bodyReader)
}

// NewGetTargetRecommendationsRequestWithApplicationVndSdtargetingrecommendationsV31PlusJSONBody calls the generic GetTargetRecommendations builder with application/vnd.sdtargetingrecommendations.v3.1+json body
func NewGetTargetRecommendationsRequestWithApplicationVndSdtargetingrecommendationsV31PlusJSONBody(server string, params *GetTargetRecommendationsParams, body GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV31PlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetTargetRecommendationsRequestWithBody(server, params, "application/vnd.sdtargetingrecommendations.v3.1+json", bodyReader)
}

// NewGetTargetRecommendationsRequestWithApplicationVndSdtargetingrecommendationsV32PlusJSONBody calls the generic GetTargetRecommendations builder with application/vnd.sdtargetingrecommendations.v3.2+json body
func NewGetTargetRecommendationsRequestWithApplicationVndSdtargetingrecommendationsV32PlusJSONBody(server string, params *GetTargetRecommendationsParams, body GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV32PlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetTargetRecommendationsRequestWithBody(server, params, "application/vnd.sdtargetingrecommendations.v3.2+json", bodyReader)
}

// NewGetTargetRecommendationsRequestWithApplicationVndSdtargetingrecommendationsV33PlusJSONBody calls the generic GetTargetRecommendations builder with application/vnd.sdtargetingrecommendations.v3.3+json body
func NewGetTargetRecommendationsRequestWithApplicationVndSdtargetingrecommendationsV33PlusJSONBody(server string, params *GetTargetRecommendationsParams, body GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV33PlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetTargetRecommendationsRequestWithBody(server, params, "application/vnd.sdtargetingrecommendations.v3.3+json", bodyReader)
}

// NewGetTargetRecommendationsRequestWithBody generates requests for GetTargetRecommendations with any type of body
func NewGetTargetRecommendationsRequestWithBody(server string, params *GetTargetRecommendationsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/targets/recommendations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Locale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locale", runtime.ParamLocationQuery, *params.Locale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewArchiveTargetingClauseRequest generates requests for ArchiveTargetingClause
func NewArchiveTargetingClauseRequest(server string, targetId int64, params *ArchiveTargetingClauseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "targetId", runtime.ParamLocationPath, targetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/targets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewGetTargetsRequest generates requests for GetTargets
func NewGetTargetsRequest(server string, targetId int64, params *GetTargetsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "targetId", runtime.ParamLocationPath, targetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/targets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewRequestReportRequest calls the generic RequestReport builder with application/json body
func NewRequestReportRequest(server string, recordType RequestReportParamsRecordType, params *RequestReportParams, body RequestReportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRequestReportRequestWithBody(server, recordType, params, "application/json", bodyReader)
}

// NewRequestReportRequestWithBody generates requests for RequestReport with any type of body
func NewRequestReportRequestWithBody(server string, recordType RequestReportParamsRecordType, params *RequestReportParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recordType", runtime.ParamLocationPath, recordType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/%s/report", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewCreateSnapshotRequest calls the generic CreateSnapshot builder with application/json body
func NewCreateSnapshotRequest(server string, recordType string, params *CreateSnapshotParams, body CreateSnapshotJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSnapshotRequestWithBody(server, recordType, params, "application/json", bodyReader)
}

// NewCreateSnapshotRequestWithBody generates requests for CreateSnapshot with any type of body
func NewCreateSnapshotRequestWithBody(server string, recordType string, params *CreateSnapshotParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recordType", runtime.ParamLocationPath, recordType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sd/%s/snapshot", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewGetReportStatusRequest generates requests for GetReportStatus
func NewGetReportStatusRequest(server string, reportId string, params *GetReportStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reportId", runtime.ParamLocationPath, reportId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/reports/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewDownloadReportRequest generates requests for DownloadReport
func NewDownloadReportRequest(server string, reportId string, params *DownloadReportParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reportId", runtime.ParamLocationPath, reportId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/reports/%s/download", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAdGroupsWithResponse request
	ListAdGroupsWithResponse(ctx context.Context, params *ListAdGroupsParams, reqEditors ...RequestEditorFn) (*ListAdGroupsResp, error)

	// CreateAdGroupsWithBodyWithResponse request with any body
	CreateAdGroupsWithBodyWithResponse(ctx context.Context, params *CreateAdGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAdGroupsResp, error)

	CreateAdGroupsWithResponse(ctx context.Context, params *CreateAdGroupsParams, body CreateAdGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAdGroupsResp, error)

	// UpdateAdGroupsWithBodyWithResponse request with any body
	UpdateAdGroupsWithBodyWithResponse(ctx context.Context, params *UpdateAdGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAdGroupsResp, error)

	UpdateAdGroupsWithResponse(ctx context.Context, params *UpdateAdGroupsParams, body UpdateAdGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAdGroupsResp, error)

	// ListAdGroupsExWithResponse request
	ListAdGroupsExWithResponse(ctx context.Context, params *ListAdGroupsExParams, reqEditors ...RequestEditorFn) (*ListAdGroupsExResp, error)

	// GetAdGroupResponseExWithResponse request
	GetAdGroupResponseExWithResponse(ctx context.Context, adGroupId int64, params *GetAdGroupResponseExParams, reqEditors ...RequestEditorFn) (*GetAdGroupResponseExResp, error)

	// ArchiveAdGroupWithResponse request
	ArchiveAdGroupWithResponse(ctx context.Context, adGroupId int64, params *ArchiveAdGroupParams, reqEditors ...RequestEditorFn) (*ArchiveAdGroupResp, error)

	// GetAdGroupWithResponse request
	GetAdGroupWithResponse(ctx context.Context, adGroupId int64, params *GetAdGroupParams, reqEditors ...RequestEditorFn) (*GetAdGroupResp, error)

	// GetSdAdGroupsAdGroupIdOptimizationRulesWithResponse request
	GetSdAdGroupsAdGroupIdOptimizationRulesWithResponse(ctx context.Context, adGroupId int64, params *GetSdAdGroupsAdGroupIdOptimizationRulesParams, reqEditors ...RequestEditorFn) (*GetSdAdGroupsAdGroupIdOptimizationRulesResp, error)

	// AssociateOptimizationRulesWithAdGroupWithBodyWithResponse request with any body
	AssociateOptimizationRulesWithAdGroupWithBodyWithResponse(ctx context.Context, adGroupId int64, params *AssociateOptimizationRulesWithAdGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssociateOptimizationRulesWithAdGroupResp, error)

	AssociateOptimizationRulesWithAdGroupWithResponse(ctx context.Context, adGroupId int64, params *AssociateOptimizationRulesWithAdGroupParams, body AssociateOptimizationRulesWithAdGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AssociateOptimizationRulesWithAdGroupResp, error)

	// DeleteBrandSafetyDenyListWithResponse request
	DeleteBrandSafetyDenyListWithResponse(ctx context.Context, params *DeleteBrandSafetyDenyListParams, reqEditors ...RequestEditorFn) (*DeleteBrandSafetyDenyListResp, error)

	// ListDomainsWithResponse request
	ListDomainsWithResponse(ctx context.Context, params *ListDomainsParams, reqEditors ...RequestEditorFn) (*ListDomainsResp, error)

	// CreateBrandSafetyDenyListDomainsWithBodyWithResponse request with any body
	CreateBrandSafetyDenyListDomainsWithBodyWithResponse(ctx context.Context, params *CreateBrandSafetyDenyListDomainsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBrandSafetyDenyListDomainsResp, error)

	CreateBrandSafetyDenyListDomainsWithResponse(ctx context.Context, params *CreateBrandSafetyDenyListDomainsParams, body CreateBrandSafetyDenyListDomainsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBrandSafetyDenyListDomainsResp, error)

	// ListRequestStatusWithResponse request
	ListRequestStatusWithResponse(ctx context.Context, params *ListRequestStatusParams, reqEditors ...RequestEditorFn) (*ListRequestStatusResp, error)

	// GetRequestResultsWithResponse request
	GetRequestResultsWithResponse(ctx context.Context, requestId string, params *GetRequestResultsParams, reqEditors ...RequestEditorFn) (*GetRequestResultsResp, error)

	// GetRequestStatusWithResponse request
	GetRequestStatusWithResponse(ctx context.Context, requestId string, params *GetRequestStatusParams, reqEditors ...RequestEditorFn) (*GetRequestStatusResp, error)

	// GetSDBudgetRulesForAdvertiserWithResponse request
	GetSDBudgetRulesForAdvertiserWithResponse(ctx context.Context, params *GetSDBudgetRulesForAdvertiserParams, reqEditors ...RequestEditorFn) (*GetSDBudgetRulesForAdvertiserResp, error)

	// CreateBudgetRulesForSDCampaignsWithBodyWithResponse request with any body
	CreateBudgetRulesForSDCampaignsWithBodyWithResponse(ctx context.Context, params *CreateBudgetRulesForSDCampaignsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBudgetRulesForSDCampaignsResp, error)

	CreateBudgetRulesForSDCampaignsWithResponse(ctx context.Context, params *CreateBudgetRulesForSDCampaignsParams, body CreateBudgetRulesForSDCampaignsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBudgetRulesForSDCampaignsResp, error)

	// UpdateBudgetRulesForSDCampaignsWithBodyWithResponse request with any body
	UpdateBudgetRulesForSDCampaignsWithBodyWithResponse(ctx context.Context, params *UpdateBudgetRulesForSDCampaignsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBudgetRulesForSDCampaignsResp, error)

	UpdateBudgetRulesForSDCampaignsWithResponse(ctx context.Context, params *UpdateBudgetRulesForSDCampaignsParams, body UpdateBudgetRulesForSDCampaignsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBudgetRulesForSDCampaignsResp, error)

	// GetBudgetRuleByRuleIdForSDCampaignsWithResponse request
	GetBudgetRuleByRuleIdForSDCampaignsWithResponse(ctx context.Context, budgetRuleId string, params *GetBudgetRuleByRuleIdForSDCampaignsParams, reqEditors ...RequestEditorFn) (*GetBudgetRuleByRuleIdForSDCampaignsResp, error)

	// ListCampaignsWithResponse request
	ListCampaignsWithResponse(ctx context.Context, params *ListCampaignsParams, reqEditors ...RequestEditorFn) (*ListCampaignsResp, error)

	// CreateCampaignsWithBodyWithResponse request with any body
	CreateCampaignsWithBodyWithResponse(ctx context.Context, params *CreateCampaignsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCampaignsResp, error)

	CreateCampaignsWithResponse(ctx context.Context, params *CreateCampaignsParams, body CreateCampaignsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCampaignsResp, error)

	// UpdateCampaignsWithBodyWithResponse request with any body
	UpdateCampaignsWithBodyWithResponse(ctx context.Context, params *UpdateCampaignsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCampaignsResp, error)

	UpdateCampaignsWithResponse(ctx context.Context, params *UpdateCampaignsParams, body UpdateCampaignsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCampaignsResp, error)

	// SdCampaignsBudgetUsageWithBodyWithResponse request with any body
	SdCampaignsBudgetUsageWithBodyWithResponse(ctx context.Context, params *SdCampaignsBudgetUsageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SdCampaignsBudgetUsageResp, error)

	SdCampaignsBudgetUsageWithApplicationVndSdcampaignbudgetusageV1PlusJSONBodyWithResponse(ctx context.Context, params *SdCampaignsBudgetUsageParams, body SdCampaignsBudgetUsageApplicationVndSdcampaignbudgetusageV1PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SdCampaignsBudgetUsageResp, error)

	// ListCampaignsExWithResponse request
	ListCampaignsExWithResponse(ctx context.Context, params *ListCampaignsExParams, reqEditors ...RequestEditorFn) (*ListCampaignsExResp, error)

	// GetCampaignResponseExWithResponse request
	GetCampaignResponseExWithResponse(ctx context.Context, campaignId int64, params *GetCampaignResponseExParams, reqEditors ...RequestEditorFn) (*GetCampaignResponseExResp, error)

	// ArchiveCampaignWithResponse request
	ArchiveCampaignWithResponse(ctx context.Context, campaignId int64, params *ArchiveCampaignParams, reqEditors ...RequestEditorFn) (*ArchiveCampaignResp, error)

	// GetCampaignWithResponse request
	GetCampaignWithResponse(ctx context.Context, campaignId int64, params *GetCampaignParams, reqEditors ...RequestEditorFn) (*GetCampaignResp, error)

	// GetRuleBasedBudgetHistoryForSDCampaignsWithResponse request
	GetRuleBasedBudgetHistoryForSDCampaignsWithResponse(ctx context.Context, campaignId int64, params *GetRuleBasedBudgetHistoryForSDCampaignsParams, reqEditors ...RequestEditorFn) (*GetRuleBasedBudgetHistoryForSDCampaignsResp, error)

	// ListCreativesWithResponse request
	ListCreativesWithResponse(ctx context.Context, params *ListCreativesParams, reqEditors ...RequestEditorFn) (*ListCreativesResp, error)

	// CreateCreativesWithBodyWithResponse request with any body
	CreateCreativesWithBodyWithResponse(ctx context.Context, params *CreateCreativesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCreativesResp, error)

	CreateCreativesWithResponse(ctx context.Context, params *CreateCreativesParams, body CreateCreativesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCreativesResp, error)

	// UpdateCreativesWithBodyWithResponse request with any body
	UpdateCreativesWithBodyWithResponse(ctx context.Context, params *UpdateCreativesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCreativesResp, error)

	UpdateCreativesWithResponse(ctx context.Context, params *UpdateCreativesParams, body UpdateCreativesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCreativesResp, error)

	// PostCreativePreviewWithBodyWithResponse request with any body
	PostCreativePreviewWithBodyWithResponse(ctx context.Context, params *PostCreativePreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCreativePreviewResp, error)

	PostCreativePreviewWithResponse(ctx context.Context, params *PostCreativePreviewParams, body PostCreativePreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCreativePreviewResp, error)

	// CreateSDForecastWithBodyWithResponse request with any body
	CreateSDForecastWithBodyWithResponse(ctx context.Context, params *CreateSDForecastParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSDForecastResp, error)

	CreateSDForecastWithApplicationVndSdforecastsV30PlusJSONBodyWithResponse(ctx context.Context, params *CreateSDForecastParams, body CreateSDForecastApplicationVndSdforecastsV30PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSDForecastResp, error)

	// ListLocationsWithResponse request
	ListLocationsWithResponse(ctx context.Context, params *ListLocationsParams, reqEditors ...RequestEditorFn) (*ListLocationsResp, error)

	// CreateLocationsWithBodyWithResponse request with any body
	CreateLocationsWithBodyWithResponse(ctx context.Context, params *CreateLocationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLocationsResp, error)

	CreateLocationsWithResponse(ctx context.Context, params *CreateLocationsParams, body CreateLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLocationsResp, error)

	// ListCreativeModerationsWithResponse request
	ListCreativeModerationsWithResponse(ctx context.Context, params *ListCreativeModerationsParams, reqEditors ...RequestEditorFn) (*ListCreativeModerationsResp, error)

	// ListNegativeTargetingClausesWithResponse request
	ListNegativeTargetingClausesWithResponse(ctx context.Context, params *ListNegativeTargetingClausesParams, reqEditors ...RequestEditorFn) (*ListNegativeTargetingClausesResp, error)

	// CreateNegativeTargetingClausesWithBodyWithResponse request with any body
	CreateNegativeTargetingClausesWithBodyWithResponse(ctx context.Context, params *CreateNegativeTargetingClausesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNegativeTargetingClausesResp, error)

	CreateNegativeTargetingClausesWithResponse(ctx context.Context, params *CreateNegativeTargetingClausesParams, body CreateNegativeTargetingClausesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNegativeTargetingClausesResp, error)

	// UpdateNegativeTargetingClausesWithBodyWithResponse request with any body
	UpdateNegativeTargetingClausesWithBodyWithResponse(ctx context.Context, params *UpdateNegativeTargetingClausesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNegativeTargetingClausesResp, error)

	UpdateNegativeTargetingClausesWithResponse(ctx context.Context, params *UpdateNegativeTargetingClausesParams, body UpdateNegativeTargetingClausesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNegativeTargetingClausesResp, error)

	// ListNegativeTargetingClausesExWithResponse request
	ListNegativeTargetingClausesExWithResponse(ctx context.Context, params *ListNegativeTargetingClausesExParams, reqEditors ...RequestEditorFn) (*ListNegativeTargetingClausesExResp, error)

	// GetNegativeTargetsExWithResponse request
	GetNegativeTargetsExWithResponse(ctx context.Context, negativeTargetId int64, params *GetNegativeTargetsExParams, reqEditors ...RequestEditorFn) (*GetNegativeTargetsExResp, error)

	// ArchiveNegativeTargetingClauseWithResponse request
	ArchiveNegativeTargetingClauseWithResponse(ctx context.Context, negativeTargetId int64, params *ArchiveNegativeTargetingClauseParams, reqEditors ...RequestEditorFn) (*ArchiveNegativeTargetingClauseResp, error)

	// GetNegativeTargetsWithResponse request
	GetNegativeTargetsWithResponse(ctx context.Context, negativeTargetId int64, params *GetNegativeTargetsParams, reqEditors ...RequestEditorFn) (*GetNegativeTargetsResp, error)

	// ListOptimizationRulesWithResponse request
	ListOptimizationRulesWithResponse(ctx context.Context, params *ListOptimizationRulesParams, reqEditors ...RequestEditorFn) (*ListOptimizationRulesResp, error)

	// CreateOptimizationRulesWithBodyWithResponse request with any body
	CreateOptimizationRulesWithBodyWithResponse(ctx context.Context, params *CreateOptimizationRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOptimizationRulesResp, error)

	CreateOptimizationRulesWithResponse(ctx context.Context, params *CreateOptimizationRulesParams, body CreateOptimizationRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOptimizationRulesResp, error)

	// UpdateOptimizationRulesWithBodyWithResponse request with any body
	UpdateOptimizationRulesWithBodyWithResponse(ctx context.Context, params *UpdateOptimizationRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOptimizationRulesResp, error)

	UpdateOptimizationRulesWithResponse(ctx context.Context, params *UpdateOptimizationRulesParams, body UpdateOptimizationRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOptimizationRulesResp, error)

	// GetSdOptimizationRulesOptimizationRuleIdWithResponse request
	GetSdOptimizationRulesOptimizationRuleIdWithResponse(ctx context.Context, optimizationRuleId string, params *GetSdOptimizationRulesOptimizationRuleIdParams, reqEditors ...RequestEditorFn) (*GetSdOptimizationRulesOptimizationRuleIdResp, error)

	// ListProductAdsWithResponse request
	ListProductAdsWithResponse(ctx context.Context, params *ListProductAdsParams, reqEditors ...RequestEditorFn) (*ListProductAdsResp, error)

	// CreateProductAdsWithBodyWithResponse request with any body
	CreateProductAdsWithBodyWithResponse(ctx context.Context, params *CreateProductAdsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProductAdsResp, error)

	CreateProductAdsWithResponse(ctx context.Context, params *CreateProductAdsParams, body CreateProductAdsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProductAdsResp, error)

	// UpdateProductAdsWithBodyWithResponse request with any body
	UpdateProductAdsWithBodyWithResponse(ctx context.Context, params *UpdateProductAdsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProductAdsResp, error)

	UpdateProductAdsWithResponse(ctx context.Context, params *UpdateProductAdsParams, body UpdateProductAdsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProductAdsResp, error)

	// ListProductAdsExWithResponse request
	ListProductAdsExWithResponse(ctx context.Context, params *ListProductAdsExParams, reqEditors ...RequestEditorFn) (*ListProductAdsExResp, error)

	// GetProductAdResponseExWithResponse request
	GetProductAdResponseExWithResponse(ctx context.Context, adId int64, params *GetProductAdResponseExParams, reqEditors ...RequestEditorFn) (*GetProductAdResponseExResp, error)

	// ArchiveProductAdWithResponse request
	ArchiveProductAdWithResponse(ctx context.Context, adId int64, params *ArchiveProductAdParams, reqEditors ...RequestEditorFn) (*ArchiveProductAdResp, error)

	// GetProductAdWithResponse request
	GetProductAdWithResponse(ctx context.Context, adId int64, params *GetProductAdParams, reqEditors ...RequestEditorFn) (*GetProductAdResp, error)

	// GetSnapshotWithResponse request
	GetSnapshotWithResponse(ctx context.Context, snapshotId string, params *GetSnapshotParams, reqEditors ...RequestEditorFn) (*GetSnapshotResp, error)

	// DownloadSnapshotWithResponse request
	DownloadSnapshotWithResponse(ctx context.Context, snapshotId string, params *DownloadSnapshotParams, reqEditors ...RequestEditorFn) (*DownloadSnapshotResp, error)

	// ListTargetingClausesWithResponse request
	ListTargetingClausesWithResponse(ctx context.Context, params *ListTargetingClausesParams, reqEditors ...RequestEditorFn) (*ListTargetingClausesResp, error)

	// CreateTargetingClausesWithBodyWithResponse request with any body
	CreateTargetingClausesWithBodyWithResponse(ctx context.Context, params *CreateTargetingClausesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTargetingClausesResp, error)

	CreateTargetingClausesWithResponse(ctx context.Context, params *CreateTargetingClausesParams, body CreateTargetingClausesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTargetingClausesResp, error)

	// UpdateTargetingClausesWithBodyWithResponse request with any body
	UpdateTargetingClausesWithBodyWithResponse(ctx context.Context, params *UpdateTargetingClausesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTargetingClausesResp, error)

	UpdateTargetingClausesWithResponse(ctx context.Context, params *UpdateTargetingClausesParams, body UpdateTargetingClausesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTargetingClausesResp, error)

	// GetTargetBidRecommendationsWithBodyWithResponse request with any body
	GetTargetBidRecommendationsWithBodyWithResponse(ctx context.Context, params *GetTargetBidRecommendationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetTargetBidRecommendationsResp, error)

	GetTargetBidRecommendationsWithApplicationVndSdtargetingrecommendationsV31PlusJSONBodyWithResponse(ctx context.Context, params *GetTargetBidRecommendationsParams, body GetTargetBidRecommendationsApplicationVndSdtargetingrecommendationsV31PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetTargetBidRecommendationsResp, error)

	GetTargetBidRecommendationsWithApplicationVndSdtargetingrecommendationsV32PlusJSONBodyWithResponse(ctx context.Context, params *GetTargetBidRecommendationsParams, body GetTargetBidRecommendationsApplicationVndSdtargetingrecommendationsV32PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetTargetBidRecommendationsResp, error)

	// ListTargetingClausesExWithResponse request
	ListTargetingClausesExWithResponse(ctx context.Context, params *ListTargetingClausesExParams, reqEditors ...RequestEditorFn) (*ListTargetingClausesExResp, error)

	// GetTargetsExWithResponse request
	GetTargetsExWithResponse(ctx context.Context, targetId int64, params *GetTargetsExParams, reqEditors ...RequestEditorFn) (*GetTargetsExResp, error)

	// GetTargetRecommendationsWithBodyWithResponse request with any body
	GetTargetRecommendationsWithBodyWithResponse(ctx context.Context, params *GetTargetRecommendationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetTargetRecommendationsResp, error)

	GetTargetRecommendationsWithApplicationVndSdtargetingrecommendationsV30PlusJSONBodyWithResponse(ctx context.Context, params *GetTargetRecommendationsParams, body GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV30PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetTargetRecommendationsResp, error)

	GetTargetRecommendationsWithApplicationVndSdtargetingrecommendationsV31PlusJSONBodyWithResponse(ctx context.Context, params *GetTargetRecommendationsParams, body GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV31PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetTargetRecommendationsResp, error)

	GetTargetRecommendationsWithApplicationVndSdtargetingrecommendationsV32PlusJSONBodyWithResponse(ctx context.Context, params *GetTargetRecommendationsParams, body GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV32PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetTargetRecommendationsResp, error)

	GetTargetRecommendationsWithApplicationVndSdtargetingrecommendationsV33PlusJSONBodyWithResponse(ctx context.Context, params *GetTargetRecommendationsParams, body GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV33PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetTargetRecommendationsResp, error)

	// ArchiveTargetingClauseWithResponse request
	ArchiveTargetingClauseWithResponse(ctx context.Context, targetId int64, params *ArchiveTargetingClauseParams, reqEditors ...RequestEditorFn) (*ArchiveTargetingClauseResp, error)

	// GetTargetsWithResponse request
	GetTargetsWithResponse(ctx context.Context, targetId int64, params *GetTargetsParams, reqEditors ...RequestEditorFn) (*GetTargetsResp, error)

	// RequestReportWithBodyWithResponse request with any body
	RequestReportWithBodyWithResponse(ctx context.Context, recordType RequestReportParamsRecordType, params *RequestReportParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestReportResp, error)

	RequestReportWithResponse(ctx context.Context, recordType RequestReportParamsRecordType, params *RequestReportParams, body RequestReportJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestReportResp, error)

	// CreateSnapshotWithBodyWithResponse request with any body
	CreateSnapshotWithBodyWithResponse(ctx context.Context, recordType string, params *CreateSnapshotParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSnapshotResp, error)

	CreateSnapshotWithResponse(ctx context.Context, recordType string, params *CreateSnapshotParams, body CreateSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSnapshotResp, error)

	// GetReportStatusWithResponse request
	GetReportStatusWithResponse(ctx context.Context, reportId string, params *GetReportStatusParams, reqEditors ...RequestEditorFn) (*GetReportStatusResp, error)

	// DownloadReportWithResponse request
	DownloadReportWithResponse(ctx context.Context, reportId string, params *DownloadReportParams, reqEditors ...RequestEditorFn) (*DownloadReportResp, error)
}

type ListAdGroupsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AdGroup
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListAdGroupsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAdGroupsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAdGroupsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON207      *[]AdGroupResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateAdGroupsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAdGroupsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAdGroupsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON207      *[]AdGroupResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateAdGroupsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAdGroupsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAdGroupsExResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AdGroupResponseEx
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListAdGroupsExResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAdGroupsExResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAdGroupResponseExResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdGroupResponseEx
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetAdGroupResponseExResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAdGroupResponseExResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveAdGroupResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdGroupResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ArchiveAdGroupResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveAdGroupResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAdGroupResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdGroup
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetAdGroupResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAdGroupResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSdAdGroupsAdGroupIdOptimizationRulesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OptimizationRule
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSdAdGroupsAdGroupIdOptimizationRulesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSdAdGroupsAdGroupIdOptimizationRulesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssociateOptimizationRulesWithAdGroupResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON207      *[]OptimizationRuleResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r AssociateOptimizationRulesWithAdGroupResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssociateOptimizationRulesWithAdGroupResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBrandSafetyDenyListResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *BrandSafetyUpdateResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteBrandSafetyDenyListResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBrandSafetyDenyListResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDomainsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BrandSafetyGetResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListDomainsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDomainsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBrandSafetyDenyListDomainsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *BrandSafetyUpdateResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateBrandSafetyDenyListDomainsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBrandSafetyDenyListDomainsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRequestStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BrandSafetyListRequestStatusResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListRequestStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRequestStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRequestResultsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BrandSafetyRequestResultsResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetRequestResultsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRequestResultsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRequestStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BrandSafetyRequestStatusResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetRequestStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRequestStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSDBudgetRulesForAdvertiserResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSDBudgetRulesForAdvertiserResponse
	JSON400      *BudgetRuleError
	JSON401      *BudgetRuleError
	JSON403      *BudgetRuleError
	JSON422      *BudgetRuleError
	JSON429      *BudgetRuleError
	JSON500      *BudgetRuleError
}

// Status returns HTTPResponse.Status
func (r GetSDBudgetRulesForAdvertiserResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSDBudgetRulesForAdvertiserResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBudgetRulesForSDCampaignsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON207      *CreateBudgetRulesResponse
	JSON400      *BudgetRuleError
	JSON401      *BudgetRuleError
	JSON403      *BudgetRuleError
	JSON422      *BudgetRuleError
	JSON429      *BudgetRuleError
	JSON500      *BudgetRuleError
}

// Status returns HTTPResponse.Status
func (r CreateBudgetRulesForSDCampaignsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBudgetRulesForSDCampaignsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBudgetRulesForSDCampaignsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON207      *UpdateBudgetRulesResponse
	JSON400      *BudgetRuleError
	JSON401      *BudgetRuleError
	JSON403      *BudgetRuleError
	JSON422      *BudgetRuleError
	JSON429      *BudgetRuleError
	JSON500      *BudgetRuleError
}

// Status returns HTTPResponse.Status
func (r UpdateBudgetRulesForSDCampaignsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBudgetRulesForSDCampaignsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBudgetRuleByRuleIdForSDCampaignsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSDBudgetRuleResponse
	JSON400      *BudgetRuleError
	JSON401      *BudgetRuleError
	JSON403      *BudgetRuleError
	JSON422      *BudgetRuleError
	JSON429      *BudgetRuleError
	JSON500      *BudgetRuleError
}

// Status returns HTTPResponse.Status
func (r GetBudgetRuleByRuleIdForSDCampaignsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBudgetRuleByRuleIdForSDCampaignsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCampaignsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Campaign
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListCampaignsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCampaignsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCampaignsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON207      *[]CampaignResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateCampaignsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCampaignsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCampaignsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON207      *[]CampaignResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateCampaignsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCampaignsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SdCampaignsBudgetUsageResp struct {
	Body                                         []byte
	HTTPResponse                                 *http.Response
	ApplicationvndSdcampaignbudgetusageV1JSON207 *BudgetUsageCampaignResponse
	JSON400                                      *BudgetUsageError
	JSON401                                      *BudgetUsageError
	JSON403                                      *BudgetUsageError
	JSON422                                      *BudgetUsageError
	JSON429                                      *BudgetUsageError
	JSON500                                      *BudgetUsageError
}

// Status returns HTTPResponse.Status
func (r SdCampaignsBudgetUsageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SdCampaignsBudgetUsageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCampaignsExResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CampaignResponseEx
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListCampaignsExResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCampaignsExResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCampaignResponseExResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CampaignResponseEx
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCampaignResponseExResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCampaignResponseExResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveCampaignResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CampaignResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ArchiveCampaignResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveCampaignResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCampaignResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Campaign
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetCampaignResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCampaignResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleBasedBudgetHistoryForSDCampaignsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SDBudgetHistory
	JSON400      *BudgetRuleError
	JSON401      *BudgetRuleError
	JSON403      *BudgetRuleError
	JSON422      *BudgetRuleError
	JSON429      *BudgetRuleError
	JSON500      *BudgetRuleError
}

// Status returns HTTPResponse.Status
func (r GetRuleBasedBudgetHistoryForSDCampaignsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleBasedBudgetHistoryForSDCampaignsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCreativesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Creative
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListCreativesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCreativesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCreativesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON207      *[]CreativeResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateCreativesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCreativesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCreativesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON207      *[]CreativeResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateCreativesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCreativesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCreativePreviewResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreativePreviewResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PostCreativePreviewResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCreativePreviewResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSDForecastResp struct {
	Body                                []byte
	HTTPResponse                        *http.Response
	ApplicationvndSdforecastsV30JSON200 *SDForecastResponse
	ApplicationvndSdforecastsV30JSON400 *SDForecastErrorResponse
	ApplicationvndSdforecastsV30JSON401 *SDForecastErrorResponse
	ApplicationvndSdforecastsV30JSON403 *SDForecastErrorResponse
	ApplicationvndSdforecastsV30JSON429 *SDForecastErrorResponse
	ApplicationvndSdforecastsV30JSON500 *SDForecastErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateSDForecastResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSDForecastResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLocationsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Location
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListLocationsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLocationsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLocationsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Location
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateLocationsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLocationsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCreativeModerationsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CreativeModeration
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListCreativeModerationsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCreativeModerationsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNegativeTargetingClausesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]NegativeTargetingClause
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListNegativeTargetingClausesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNegativeTargetingClausesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNegativeTargetingClausesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON207      *[]TargetResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateNegativeTargetingClausesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNegativeTargetingClausesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNegativeTargetingClausesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON207      *[]TargetResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateNegativeTargetingClausesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNegativeTargetingClausesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNegativeTargetingClausesExResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]NegativeTargetingClauseEx
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListNegativeTargetingClausesExResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNegativeTargetingClausesExResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNegativeTargetsExResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NegativeTargetingClauseEx
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetNegativeTargetsExResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNegativeTargetsExResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveNegativeTargetingClauseResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TargetResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ArchiveNegativeTargetingClauseResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveNegativeTargetingClauseResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNegativeTargetsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NegativeTargetingClause
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetNegativeTargetsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNegativeTargetsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOptimizationRulesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OptimizationRule
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListOptimizationRulesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOptimizationRulesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOptimizationRulesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON207      *[]OptimizationRuleResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateOptimizationRulesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOptimizationRulesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOptimizationRulesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON207      *[]OptimizationRuleResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateOptimizationRulesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOptimizationRulesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSdOptimizationRulesOptimizationRuleIdResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OptimizationRule
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSdOptimizationRulesOptimizationRuleIdResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSdOptimizationRulesOptimizationRuleIdResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProductAdsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ProductAd
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListProductAdsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProductAdsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProductAdsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON207      *[]ProductAdResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateProductAdsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProductAdsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProductAdsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON207      *[]ProductAdResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateProductAdsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProductAdsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProductAdsExResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ProductAdResponseEx
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListProductAdsExResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProductAdsExResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductAdResponseExResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductAdResponseEx
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetProductAdResponseExResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductAdResponseExResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveProductAdResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductAdResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ArchiveProductAdResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveProductAdResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductAdResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductAd
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetProductAdResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductAdResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSnapshotResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *SnapshotResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSnapshotResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSnapshotResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadSnapshotResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DownloadSnapshotResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadSnapshotResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTargetingClausesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TargetingClause
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListTargetingClausesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTargetingClausesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTargetingClausesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON207      *[]TargetResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateTargetingClausesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTargetingClausesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTargetingClausesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON207      *[]TargetResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateTargetingClausesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTargetingClausesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTargetBidRecommendationsResp struct {
	Body                                               []byte
	HTTPResponse                                       *http.Response
	ApplicationvndSdtargetingrecommendationsV31JSON207 *SDTargetingBidRecommendationsResponseV31
	ApplicationvndSdtargetingrecommendationsV32JSON207 *SDTargetingBidRecommendationsResponseV32
	JSON400                                            *SDErrorResponse
	JSON401                                            *SDErrorResponse
	JSON403                                            *SDErrorResponse
	JSON415                                            *SDErrorResponse
	JSON429                                            *SDErrorResponse
	JSON500                                            *SDErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTargetBidRecommendationsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTargetBidRecommendationsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTargetingClausesExResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TargetingClauseEx
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListTargetingClausesExResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTargetingClausesExResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTargetsExResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TargetingClauseEx
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetTargetsExResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTargetsExResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTargetRecommendationsResp struct {
	Body                                               []byte
	HTTPResponse                                       *http.Response
	ApplicationvndSdtargetingrecommendationsV30JSON200 *SDTargetingRecommendationsResponse
	ApplicationvndSdtargetingrecommendationsV31JSON200 *SDTargetingRecommendationsResponseV31
	ApplicationvndSdtargetingrecommendationsV32JSON200 *SDTargetingRecommendationsResponseV32
	ApplicationvndSdtargetingrecommendationsV33JSON200 *SDTargetingRecommendationsResponseV33
	JSON400                                            *SDErrorResponse
	JSON401                                            *SDErrorResponse
	JSON403                                            *SDErrorResponse
	JSON415                                            *SDErrorResponse
	JSON429                                            *SDErrorResponse
	JSON500                                            *SDErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTargetRecommendationsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTargetRecommendationsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveTargetingClauseResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TargetResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ArchiveTargetingClauseResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveTargetingClauseResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTargetsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TargetingClause
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetTargetsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTargetsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequestReportResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ReportResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON406      *Error
	JSON422      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RequestReportResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestReportResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSnapshotResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *SnapshotResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateSnapshotResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSnapshotResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReportStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReportResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetReportStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReportStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadReportResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON429      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DownloadReportResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadReportResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAdGroupsWithResponse request returning *ListAdGroupsResp
func (c *ClientWithResponses) ListAdGroupsWithResponse(ctx context.Context, params *ListAdGroupsParams, reqEditors ...RequestEditorFn) (*ListAdGroupsResp, error) {
	rsp, err := c.ListAdGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAdGroupsResp(rsp)
}

// CreateAdGroupsWithBodyWithResponse request with arbitrary body returning *CreateAdGroupsResp
func (c *ClientWithResponses) CreateAdGroupsWithBodyWithResponse(ctx context.Context, params *CreateAdGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAdGroupsResp, error) {
	rsp, err := c.CreateAdGroupsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAdGroupsResp(rsp)
}

func (c *ClientWithResponses) CreateAdGroupsWithResponse(ctx context.Context, params *CreateAdGroupsParams, body CreateAdGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAdGroupsResp, error) {
	rsp, err := c.CreateAdGroups(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAdGroupsResp(rsp)
}

// UpdateAdGroupsWithBodyWithResponse request with arbitrary body returning *UpdateAdGroupsResp
func (c *ClientWithResponses) UpdateAdGroupsWithBodyWithResponse(ctx context.Context, params *UpdateAdGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAdGroupsResp, error) {
	rsp, err := c.UpdateAdGroupsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAdGroupsResp(rsp)
}

func (c *ClientWithResponses) UpdateAdGroupsWithResponse(ctx context.Context, params *UpdateAdGroupsParams, body UpdateAdGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAdGroupsResp, error) {
	rsp, err := c.UpdateAdGroups(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAdGroupsResp(rsp)
}

// ListAdGroupsExWithResponse request returning *ListAdGroupsExResp
func (c *ClientWithResponses) ListAdGroupsExWithResponse(ctx context.Context, params *ListAdGroupsExParams, reqEditors ...RequestEditorFn) (*ListAdGroupsExResp, error) {
	rsp, err := c.ListAdGroupsEx(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAdGroupsExResp(rsp)
}

// GetAdGroupResponseExWithResponse request returning *GetAdGroupResponseExResp
func (c *ClientWithResponses) GetAdGroupResponseExWithResponse(ctx context.Context, adGroupId int64, params *GetAdGroupResponseExParams, reqEditors ...RequestEditorFn) (*GetAdGroupResponseExResp, error) {
	rsp, err := c.GetAdGroupResponseEx(ctx, adGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAdGroupResponseExResp(rsp)
}

// ArchiveAdGroupWithResponse request returning *ArchiveAdGroupResp
func (c *ClientWithResponses) ArchiveAdGroupWithResponse(ctx context.Context, adGroupId int64, params *ArchiveAdGroupParams, reqEditors ...RequestEditorFn) (*ArchiveAdGroupResp, error) {
	rsp, err := c.ArchiveAdGroup(ctx, adGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveAdGroupResp(rsp)
}

// GetAdGroupWithResponse request returning *GetAdGroupResp
func (c *ClientWithResponses) GetAdGroupWithResponse(ctx context.Context, adGroupId int64, params *GetAdGroupParams, reqEditors ...RequestEditorFn) (*GetAdGroupResp, error) {
	rsp, err := c.GetAdGroup(ctx, adGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAdGroupResp(rsp)
}

// GetSdAdGroupsAdGroupIdOptimizationRulesWithResponse request returning *GetSdAdGroupsAdGroupIdOptimizationRulesResp
func (c *ClientWithResponses) GetSdAdGroupsAdGroupIdOptimizationRulesWithResponse(ctx context.Context, adGroupId int64, params *GetSdAdGroupsAdGroupIdOptimizationRulesParams, reqEditors ...RequestEditorFn) (*GetSdAdGroupsAdGroupIdOptimizationRulesResp, error) {
	rsp, err := c.GetSdAdGroupsAdGroupIdOptimizationRules(ctx, adGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSdAdGroupsAdGroupIdOptimizationRulesResp(rsp)
}

// AssociateOptimizationRulesWithAdGroupWithBodyWithResponse request with arbitrary body returning *AssociateOptimizationRulesWithAdGroupResp
func (c *ClientWithResponses) AssociateOptimizationRulesWithAdGroupWithBodyWithResponse(ctx context.Context, adGroupId int64, params *AssociateOptimizationRulesWithAdGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssociateOptimizationRulesWithAdGroupResp, error) {
	rsp, err := c.AssociateOptimizationRulesWithAdGroupWithBody(ctx, adGroupId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssociateOptimizationRulesWithAdGroupResp(rsp)
}

func (c *ClientWithResponses) AssociateOptimizationRulesWithAdGroupWithResponse(ctx context.Context, adGroupId int64, params *AssociateOptimizationRulesWithAdGroupParams, body AssociateOptimizationRulesWithAdGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AssociateOptimizationRulesWithAdGroupResp, error) {
	rsp, err := c.AssociateOptimizationRulesWithAdGroup(ctx, adGroupId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssociateOptimizationRulesWithAdGroupResp(rsp)
}

// DeleteBrandSafetyDenyListWithResponse request returning *DeleteBrandSafetyDenyListResp
func (c *ClientWithResponses) DeleteBrandSafetyDenyListWithResponse(ctx context.Context, params *DeleteBrandSafetyDenyListParams, reqEditors ...RequestEditorFn) (*DeleteBrandSafetyDenyListResp, error) {
	rsp, err := c.DeleteBrandSafetyDenyList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBrandSafetyDenyListResp(rsp)
}

// ListDomainsWithResponse request returning *ListDomainsResp
func (c *ClientWithResponses) ListDomainsWithResponse(ctx context.Context, params *ListDomainsParams, reqEditors ...RequestEditorFn) (*ListDomainsResp, error) {
	rsp, err := c.ListDomains(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDomainsResp(rsp)
}

// CreateBrandSafetyDenyListDomainsWithBodyWithResponse request with arbitrary body returning *CreateBrandSafetyDenyListDomainsResp
func (c *ClientWithResponses) CreateBrandSafetyDenyListDomainsWithBodyWithResponse(ctx context.Context, params *CreateBrandSafetyDenyListDomainsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBrandSafetyDenyListDomainsResp, error) {
	rsp, err := c.CreateBrandSafetyDenyListDomainsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBrandSafetyDenyListDomainsResp(rsp)
}

func (c *ClientWithResponses) CreateBrandSafetyDenyListDomainsWithResponse(ctx context.Context, params *CreateBrandSafetyDenyListDomainsParams, body CreateBrandSafetyDenyListDomainsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBrandSafetyDenyListDomainsResp, error) {
	rsp, err := c.CreateBrandSafetyDenyListDomains(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBrandSafetyDenyListDomainsResp(rsp)
}

// ListRequestStatusWithResponse request returning *ListRequestStatusResp
func (c *ClientWithResponses) ListRequestStatusWithResponse(ctx context.Context, params *ListRequestStatusParams, reqEditors ...RequestEditorFn) (*ListRequestStatusResp, error) {
	rsp, err := c.ListRequestStatus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRequestStatusResp(rsp)
}

// GetRequestResultsWithResponse request returning *GetRequestResultsResp
func (c *ClientWithResponses) GetRequestResultsWithResponse(ctx context.Context, requestId string, params *GetRequestResultsParams, reqEditors ...RequestEditorFn) (*GetRequestResultsResp, error) {
	rsp, err := c.GetRequestResults(ctx, requestId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRequestResultsResp(rsp)
}

// GetRequestStatusWithResponse request returning *GetRequestStatusResp
func (c *ClientWithResponses) GetRequestStatusWithResponse(ctx context.Context, requestId string, params *GetRequestStatusParams, reqEditors ...RequestEditorFn) (*GetRequestStatusResp, error) {
	rsp, err := c.GetRequestStatus(ctx, requestId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRequestStatusResp(rsp)
}

// GetSDBudgetRulesForAdvertiserWithResponse request returning *GetSDBudgetRulesForAdvertiserResp
func (c *ClientWithResponses) GetSDBudgetRulesForAdvertiserWithResponse(ctx context.Context, params *GetSDBudgetRulesForAdvertiserParams, reqEditors ...RequestEditorFn) (*GetSDBudgetRulesForAdvertiserResp, error) {
	rsp, err := c.GetSDBudgetRulesForAdvertiser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSDBudgetRulesForAdvertiserResp(rsp)
}

// CreateBudgetRulesForSDCampaignsWithBodyWithResponse request with arbitrary body returning *CreateBudgetRulesForSDCampaignsResp
func (c *ClientWithResponses) CreateBudgetRulesForSDCampaignsWithBodyWithResponse(ctx context.Context, params *CreateBudgetRulesForSDCampaignsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBudgetRulesForSDCampaignsResp, error) {
	rsp, err := c.CreateBudgetRulesForSDCampaignsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBudgetRulesForSDCampaignsResp(rsp)
}

func (c *ClientWithResponses) CreateBudgetRulesForSDCampaignsWithResponse(ctx context.Context, params *CreateBudgetRulesForSDCampaignsParams, body CreateBudgetRulesForSDCampaignsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBudgetRulesForSDCampaignsResp, error) {
	rsp, err := c.CreateBudgetRulesForSDCampaigns(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBudgetRulesForSDCampaignsResp(rsp)
}

// UpdateBudgetRulesForSDCampaignsWithBodyWithResponse request with arbitrary body returning *UpdateBudgetRulesForSDCampaignsResp
func (c *ClientWithResponses) UpdateBudgetRulesForSDCampaignsWithBodyWithResponse(ctx context.Context, params *UpdateBudgetRulesForSDCampaignsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBudgetRulesForSDCampaignsResp, error) {
	rsp, err := c.UpdateBudgetRulesForSDCampaignsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBudgetRulesForSDCampaignsResp(rsp)
}

func (c *ClientWithResponses) UpdateBudgetRulesForSDCampaignsWithResponse(ctx context.Context, params *UpdateBudgetRulesForSDCampaignsParams, body UpdateBudgetRulesForSDCampaignsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBudgetRulesForSDCampaignsResp, error) {
	rsp, err := c.UpdateBudgetRulesForSDCampaigns(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBudgetRulesForSDCampaignsResp(rsp)
}

// GetBudgetRuleByRuleIdForSDCampaignsWithResponse request returning *GetBudgetRuleByRuleIdForSDCampaignsResp
func (c *ClientWithResponses) GetBudgetRuleByRuleIdForSDCampaignsWithResponse(ctx context.Context, budgetRuleId string, params *GetBudgetRuleByRuleIdForSDCampaignsParams, reqEditors ...RequestEditorFn) (*GetBudgetRuleByRuleIdForSDCampaignsResp, error) {
	rsp, err := c.GetBudgetRuleByRuleIdForSDCampaigns(ctx, budgetRuleId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBudgetRuleByRuleIdForSDCampaignsResp(rsp)
}

// ListCampaignsWithResponse request returning *ListCampaignsResp
func (c *ClientWithResponses) ListCampaignsWithResponse(ctx context.Context, params *ListCampaignsParams, reqEditors ...RequestEditorFn) (*ListCampaignsResp, error) {
	rsp, err := c.ListCampaigns(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCampaignsResp(rsp)
}

// CreateCampaignsWithBodyWithResponse request with arbitrary body returning *CreateCampaignsResp
func (c *ClientWithResponses) CreateCampaignsWithBodyWithResponse(ctx context.Context, params *CreateCampaignsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCampaignsResp, error) {
	rsp, err := c.CreateCampaignsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCampaignsResp(rsp)
}

func (c *ClientWithResponses) CreateCampaignsWithResponse(ctx context.Context, params *CreateCampaignsParams, body CreateCampaignsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCampaignsResp, error) {
	rsp, err := c.CreateCampaigns(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCampaignsResp(rsp)
}

// UpdateCampaignsWithBodyWithResponse request with arbitrary body returning *UpdateCampaignsResp
func (c *ClientWithResponses) UpdateCampaignsWithBodyWithResponse(ctx context.Context, params *UpdateCampaignsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCampaignsResp, error) {
	rsp, err := c.UpdateCampaignsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCampaignsResp(rsp)
}

func (c *ClientWithResponses) UpdateCampaignsWithResponse(ctx context.Context, params *UpdateCampaignsParams, body UpdateCampaignsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCampaignsResp, error) {
	rsp, err := c.UpdateCampaigns(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCampaignsResp(rsp)
}

// SdCampaignsBudgetUsageWithBodyWithResponse request with arbitrary body returning *SdCampaignsBudgetUsageResp
func (c *ClientWithResponses) SdCampaignsBudgetUsageWithBodyWithResponse(ctx context.Context, params *SdCampaignsBudgetUsageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SdCampaignsBudgetUsageResp, error) {
	rsp, err := c.SdCampaignsBudgetUsageWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSdCampaignsBudgetUsageResp(rsp)
}

func (c *ClientWithResponses) SdCampaignsBudgetUsageWithApplicationVndSdcampaignbudgetusageV1PlusJSONBodyWithResponse(ctx context.Context, params *SdCampaignsBudgetUsageParams, body SdCampaignsBudgetUsageApplicationVndSdcampaignbudgetusageV1PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*SdCampaignsBudgetUsageResp, error) {
	rsp, err := c.SdCampaignsBudgetUsageWithApplicationVndSdcampaignbudgetusageV1PlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSdCampaignsBudgetUsageResp(rsp)
}

// ListCampaignsExWithResponse request returning *ListCampaignsExResp
func (c *ClientWithResponses) ListCampaignsExWithResponse(ctx context.Context, params *ListCampaignsExParams, reqEditors ...RequestEditorFn) (*ListCampaignsExResp, error) {
	rsp, err := c.ListCampaignsEx(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCampaignsExResp(rsp)
}

// GetCampaignResponseExWithResponse request returning *GetCampaignResponseExResp
func (c *ClientWithResponses) GetCampaignResponseExWithResponse(ctx context.Context, campaignId int64, params *GetCampaignResponseExParams, reqEditors ...RequestEditorFn) (*GetCampaignResponseExResp, error) {
	rsp, err := c.GetCampaignResponseEx(ctx, campaignId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCampaignResponseExResp(rsp)
}

// ArchiveCampaignWithResponse request returning *ArchiveCampaignResp
func (c *ClientWithResponses) ArchiveCampaignWithResponse(ctx context.Context, campaignId int64, params *ArchiveCampaignParams, reqEditors ...RequestEditorFn) (*ArchiveCampaignResp, error) {
	rsp, err := c.ArchiveCampaign(ctx, campaignId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveCampaignResp(rsp)
}

// GetCampaignWithResponse request returning *GetCampaignResp
func (c *ClientWithResponses) GetCampaignWithResponse(ctx context.Context, campaignId int64, params *GetCampaignParams, reqEditors ...RequestEditorFn) (*GetCampaignResp, error) {
	rsp, err := c.GetCampaign(ctx, campaignId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCampaignResp(rsp)
}

// GetRuleBasedBudgetHistoryForSDCampaignsWithResponse request returning *GetRuleBasedBudgetHistoryForSDCampaignsResp
func (c *ClientWithResponses) GetRuleBasedBudgetHistoryForSDCampaignsWithResponse(ctx context.Context, campaignId int64, params *GetRuleBasedBudgetHistoryForSDCampaignsParams, reqEditors ...RequestEditorFn) (*GetRuleBasedBudgetHistoryForSDCampaignsResp, error) {
	rsp, err := c.GetRuleBasedBudgetHistoryForSDCampaigns(ctx, campaignId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleBasedBudgetHistoryForSDCampaignsResp(rsp)
}

// ListCreativesWithResponse request returning *ListCreativesResp
func (c *ClientWithResponses) ListCreativesWithResponse(ctx context.Context, params *ListCreativesParams, reqEditors ...RequestEditorFn) (*ListCreativesResp, error) {
	rsp, err := c.ListCreatives(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCreativesResp(rsp)
}

// CreateCreativesWithBodyWithResponse request with arbitrary body returning *CreateCreativesResp
func (c *ClientWithResponses) CreateCreativesWithBodyWithResponse(ctx context.Context, params *CreateCreativesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCreativesResp, error) {
	rsp, err := c.CreateCreativesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCreativesResp(rsp)
}

func (c *ClientWithResponses) CreateCreativesWithResponse(ctx context.Context, params *CreateCreativesParams, body CreateCreativesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCreativesResp, error) {
	rsp, err := c.CreateCreatives(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCreativesResp(rsp)
}

// UpdateCreativesWithBodyWithResponse request with arbitrary body returning *UpdateCreativesResp
func (c *ClientWithResponses) UpdateCreativesWithBodyWithResponse(ctx context.Context, params *UpdateCreativesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCreativesResp, error) {
	rsp, err := c.UpdateCreativesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCreativesResp(rsp)
}

func (c *ClientWithResponses) UpdateCreativesWithResponse(ctx context.Context, params *UpdateCreativesParams, body UpdateCreativesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCreativesResp, error) {
	rsp, err := c.UpdateCreatives(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCreativesResp(rsp)
}

// PostCreativePreviewWithBodyWithResponse request with arbitrary body returning *PostCreativePreviewResp
func (c *ClientWithResponses) PostCreativePreviewWithBodyWithResponse(ctx context.Context, params *PostCreativePreviewParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCreativePreviewResp, error) {
	rsp, err := c.PostCreativePreviewWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCreativePreviewResp(rsp)
}

func (c *ClientWithResponses) PostCreativePreviewWithResponse(ctx context.Context, params *PostCreativePreviewParams, body PostCreativePreviewJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCreativePreviewResp, error) {
	rsp, err := c.PostCreativePreview(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCreativePreviewResp(rsp)
}

// CreateSDForecastWithBodyWithResponse request with arbitrary body returning *CreateSDForecastResp
func (c *ClientWithResponses) CreateSDForecastWithBodyWithResponse(ctx context.Context, params *CreateSDForecastParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSDForecastResp, error) {
	rsp, err := c.CreateSDForecastWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSDForecastResp(rsp)
}

func (c *ClientWithResponses) CreateSDForecastWithApplicationVndSdforecastsV30PlusJSONBodyWithResponse(ctx context.Context, params *CreateSDForecastParams, body CreateSDForecastApplicationVndSdforecastsV30PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSDForecastResp, error) {
	rsp, err := c.CreateSDForecastWithApplicationVndSdforecastsV30PlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSDForecastResp(rsp)
}

// ListLocationsWithResponse request returning *ListLocationsResp
func (c *ClientWithResponses) ListLocationsWithResponse(ctx context.Context, params *ListLocationsParams, reqEditors ...RequestEditorFn) (*ListLocationsResp, error) {
	rsp, err := c.ListLocations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLocationsResp(rsp)
}

// CreateLocationsWithBodyWithResponse request with arbitrary body returning *CreateLocationsResp
func (c *ClientWithResponses) CreateLocationsWithBodyWithResponse(ctx context.Context, params *CreateLocationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLocationsResp, error) {
	rsp, err := c.CreateLocationsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLocationsResp(rsp)
}

func (c *ClientWithResponses) CreateLocationsWithResponse(ctx context.Context, params *CreateLocationsParams, body CreateLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLocationsResp, error) {
	rsp, err := c.CreateLocations(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLocationsResp(rsp)
}

// ListCreativeModerationsWithResponse request returning *ListCreativeModerationsResp
func (c *ClientWithResponses) ListCreativeModerationsWithResponse(ctx context.Context, params *ListCreativeModerationsParams, reqEditors ...RequestEditorFn) (*ListCreativeModerationsResp, error) {
	rsp, err := c.ListCreativeModerations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCreativeModerationsResp(rsp)
}

// ListNegativeTargetingClausesWithResponse request returning *ListNegativeTargetingClausesResp
func (c *ClientWithResponses) ListNegativeTargetingClausesWithResponse(ctx context.Context, params *ListNegativeTargetingClausesParams, reqEditors ...RequestEditorFn) (*ListNegativeTargetingClausesResp, error) {
	rsp, err := c.ListNegativeTargetingClauses(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNegativeTargetingClausesResp(rsp)
}

// CreateNegativeTargetingClausesWithBodyWithResponse request with arbitrary body returning *CreateNegativeTargetingClausesResp
func (c *ClientWithResponses) CreateNegativeTargetingClausesWithBodyWithResponse(ctx context.Context, params *CreateNegativeTargetingClausesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNegativeTargetingClausesResp, error) {
	rsp, err := c.CreateNegativeTargetingClausesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNegativeTargetingClausesResp(rsp)
}

func (c *ClientWithResponses) CreateNegativeTargetingClausesWithResponse(ctx context.Context, params *CreateNegativeTargetingClausesParams, body CreateNegativeTargetingClausesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNegativeTargetingClausesResp, error) {
	rsp, err := c.CreateNegativeTargetingClauses(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNegativeTargetingClausesResp(rsp)
}

// UpdateNegativeTargetingClausesWithBodyWithResponse request with arbitrary body returning *UpdateNegativeTargetingClausesResp
func (c *ClientWithResponses) UpdateNegativeTargetingClausesWithBodyWithResponse(ctx context.Context, params *UpdateNegativeTargetingClausesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNegativeTargetingClausesResp, error) {
	rsp, err := c.UpdateNegativeTargetingClausesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNegativeTargetingClausesResp(rsp)
}

func (c *ClientWithResponses) UpdateNegativeTargetingClausesWithResponse(ctx context.Context, params *UpdateNegativeTargetingClausesParams, body UpdateNegativeTargetingClausesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNegativeTargetingClausesResp, error) {
	rsp, err := c.UpdateNegativeTargetingClauses(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNegativeTargetingClausesResp(rsp)
}

// ListNegativeTargetingClausesExWithResponse request returning *ListNegativeTargetingClausesExResp
func (c *ClientWithResponses) ListNegativeTargetingClausesExWithResponse(ctx context.Context, params *ListNegativeTargetingClausesExParams, reqEditors ...RequestEditorFn) (*ListNegativeTargetingClausesExResp, error) {
	rsp, err := c.ListNegativeTargetingClausesEx(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNegativeTargetingClausesExResp(rsp)
}

// GetNegativeTargetsExWithResponse request returning *GetNegativeTargetsExResp
func (c *ClientWithResponses) GetNegativeTargetsExWithResponse(ctx context.Context, negativeTargetId int64, params *GetNegativeTargetsExParams, reqEditors ...RequestEditorFn) (*GetNegativeTargetsExResp, error) {
	rsp, err := c.GetNegativeTargetsEx(ctx, negativeTargetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNegativeTargetsExResp(rsp)
}

// ArchiveNegativeTargetingClauseWithResponse request returning *ArchiveNegativeTargetingClauseResp
func (c *ClientWithResponses) ArchiveNegativeTargetingClauseWithResponse(ctx context.Context, negativeTargetId int64, params *ArchiveNegativeTargetingClauseParams, reqEditors ...RequestEditorFn) (*ArchiveNegativeTargetingClauseResp, error) {
	rsp, err := c.ArchiveNegativeTargetingClause(ctx, negativeTargetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveNegativeTargetingClauseResp(rsp)
}

// GetNegativeTargetsWithResponse request returning *GetNegativeTargetsResp
func (c *ClientWithResponses) GetNegativeTargetsWithResponse(ctx context.Context, negativeTargetId int64, params *GetNegativeTargetsParams, reqEditors ...RequestEditorFn) (*GetNegativeTargetsResp, error) {
	rsp, err := c.GetNegativeTargets(ctx, negativeTargetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNegativeTargetsResp(rsp)
}

// ListOptimizationRulesWithResponse request returning *ListOptimizationRulesResp
func (c *ClientWithResponses) ListOptimizationRulesWithResponse(ctx context.Context, params *ListOptimizationRulesParams, reqEditors ...RequestEditorFn) (*ListOptimizationRulesResp, error) {
	rsp, err := c.ListOptimizationRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOptimizationRulesResp(rsp)
}

// CreateOptimizationRulesWithBodyWithResponse request with arbitrary body returning *CreateOptimizationRulesResp
func (c *ClientWithResponses) CreateOptimizationRulesWithBodyWithResponse(ctx context.Context, params *CreateOptimizationRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOptimizationRulesResp, error) {
	rsp, err := c.CreateOptimizationRulesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOptimizationRulesResp(rsp)
}

func (c *ClientWithResponses) CreateOptimizationRulesWithResponse(ctx context.Context, params *CreateOptimizationRulesParams, body CreateOptimizationRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOptimizationRulesResp, error) {
	rsp, err := c.CreateOptimizationRules(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOptimizationRulesResp(rsp)
}

// UpdateOptimizationRulesWithBodyWithResponse request with arbitrary body returning *UpdateOptimizationRulesResp
func (c *ClientWithResponses) UpdateOptimizationRulesWithBodyWithResponse(ctx context.Context, params *UpdateOptimizationRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOptimizationRulesResp, error) {
	rsp, err := c.UpdateOptimizationRulesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOptimizationRulesResp(rsp)
}

func (c *ClientWithResponses) UpdateOptimizationRulesWithResponse(ctx context.Context, params *UpdateOptimizationRulesParams, body UpdateOptimizationRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOptimizationRulesResp, error) {
	rsp, err := c.UpdateOptimizationRules(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOptimizationRulesResp(rsp)
}

// GetSdOptimizationRulesOptimizationRuleIdWithResponse request returning *GetSdOptimizationRulesOptimizationRuleIdResp
func (c *ClientWithResponses) GetSdOptimizationRulesOptimizationRuleIdWithResponse(ctx context.Context, optimizationRuleId string, params *GetSdOptimizationRulesOptimizationRuleIdParams, reqEditors ...RequestEditorFn) (*GetSdOptimizationRulesOptimizationRuleIdResp, error) {
	rsp, err := c.GetSdOptimizationRulesOptimizationRuleId(ctx, optimizationRuleId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSdOptimizationRulesOptimizationRuleIdResp(rsp)
}

// ListProductAdsWithResponse request returning *ListProductAdsResp
func (c *ClientWithResponses) ListProductAdsWithResponse(ctx context.Context, params *ListProductAdsParams, reqEditors ...RequestEditorFn) (*ListProductAdsResp, error) {
	rsp, err := c.ListProductAds(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProductAdsResp(rsp)
}

// CreateProductAdsWithBodyWithResponse request with arbitrary body returning *CreateProductAdsResp
func (c *ClientWithResponses) CreateProductAdsWithBodyWithResponse(ctx context.Context, params *CreateProductAdsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProductAdsResp, error) {
	rsp, err := c.CreateProductAdsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProductAdsResp(rsp)
}

func (c *ClientWithResponses) CreateProductAdsWithResponse(ctx context.Context, params *CreateProductAdsParams, body CreateProductAdsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProductAdsResp, error) {
	rsp, err := c.CreateProductAds(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProductAdsResp(rsp)
}

// UpdateProductAdsWithBodyWithResponse request with arbitrary body returning *UpdateProductAdsResp
func (c *ClientWithResponses) UpdateProductAdsWithBodyWithResponse(ctx context.Context, params *UpdateProductAdsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProductAdsResp, error) {
	rsp, err := c.UpdateProductAdsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProductAdsResp(rsp)
}

func (c *ClientWithResponses) UpdateProductAdsWithResponse(ctx context.Context, params *UpdateProductAdsParams, body UpdateProductAdsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProductAdsResp, error) {
	rsp, err := c.UpdateProductAds(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProductAdsResp(rsp)
}

// ListProductAdsExWithResponse request returning *ListProductAdsExResp
func (c *ClientWithResponses) ListProductAdsExWithResponse(ctx context.Context, params *ListProductAdsExParams, reqEditors ...RequestEditorFn) (*ListProductAdsExResp, error) {
	rsp, err := c.ListProductAdsEx(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProductAdsExResp(rsp)
}

// GetProductAdResponseExWithResponse request returning *GetProductAdResponseExResp
func (c *ClientWithResponses) GetProductAdResponseExWithResponse(ctx context.Context, adId int64, params *GetProductAdResponseExParams, reqEditors ...RequestEditorFn) (*GetProductAdResponseExResp, error) {
	rsp, err := c.GetProductAdResponseEx(ctx, adId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductAdResponseExResp(rsp)
}

// ArchiveProductAdWithResponse request returning *ArchiveProductAdResp
func (c *ClientWithResponses) ArchiveProductAdWithResponse(ctx context.Context, adId int64, params *ArchiveProductAdParams, reqEditors ...RequestEditorFn) (*ArchiveProductAdResp, error) {
	rsp, err := c.ArchiveProductAd(ctx, adId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveProductAdResp(rsp)
}

// GetProductAdWithResponse request returning *GetProductAdResp
func (c *ClientWithResponses) GetProductAdWithResponse(ctx context.Context, adId int64, params *GetProductAdParams, reqEditors ...RequestEditorFn) (*GetProductAdResp, error) {
	rsp, err := c.GetProductAd(ctx, adId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductAdResp(rsp)
}

// GetSnapshotWithResponse request returning *GetSnapshotResp
func (c *ClientWithResponses) GetSnapshotWithResponse(ctx context.Context, snapshotId string, params *GetSnapshotParams, reqEditors ...RequestEditorFn) (*GetSnapshotResp, error) {
	rsp, err := c.GetSnapshot(ctx, snapshotId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSnapshotResp(rsp)
}

// DownloadSnapshotWithResponse request returning *DownloadSnapshotResp
func (c *ClientWithResponses) DownloadSnapshotWithResponse(ctx context.Context, snapshotId string, params *DownloadSnapshotParams, reqEditors ...RequestEditorFn) (*DownloadSnapshotResp, error) {
	rsp, err := c.DownloadSnapshot(ctx, snapshotId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadSnapshotResp(rsp)
}

// ListTargetingClausesWithResponse request returning *ListTargetingClausesResp
func (c *ClientWithResponses) ListTargetingClausesWithResponse(ctx context.Context, params *ListTargetingClausesParams, reqEditors ...RequestEditorFn) (*ListTargetingClausesResp, error) {
	rsp, err := c.ListTargetingClauses(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTargetingClausesResp(rsp)
}

// CreateTargetingClausesWithBodyWithResponse request with arbitrary body returning *CreateTargetingClausesResp
func (c *ClientWithResponses) CreateTargetingClausesWithBodyWithResponse(ctx context.Context, params *CreateTargetingClausesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTargetingClausesResp, error) {
	rsp, err := c.CreateTargetingClausesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTargetingClausesResp(rsp)
}

func (c *ClientWithResponses) CreateTargetingClausesWithResponse(ctx context.Context, params *CreateTargetingClausesParams, body CreateTargetingClausesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTargetingClausesResp, error) {
	rsp, err := c.CreateTargetingClauses(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTargetingClausesResp(rsp)
}

// UpdateTargetingClausesWithBodyWithResponse request with arbitrary body returning *UpdateTargetingClausesResp
func (c *ClientWithResponses) UpdateTargetingClausesWithBodyWithResponse(ctx context.Context, params *UpdateTargetingClausesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTargetingClausesResp, error) {
	rsp, err := c.UpdateTargetingClausesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTargetingClausesResp(rsp)
}

func (c *ClientWithResponses) UpdateTargetingClausesWithResponse(ctx context.Context, params *UpdateTargetingClausesParams, body UpdateTargetingClausesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTargetingClausesResp, error) {
	rsp, err := c.UpdateTargetingClauses(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTargetingClausesResp(rsp)
}

// GetTargetBidRecommendationsWithBodyWithResponse request with arbitrary body returning *GetTargetBidRecommendationsResp
func (c *ClientWithResponses) GetTargetBidRecommendationsWithBodyWithResponse(ctx context.Context, params *GetTargetBidRecommendationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetTargetBidRecommendationsResp, error) {
	rsp, err := c.GetTargetBidRecommendationsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTargetBidRecommendationsResp(rsp)
}

func (c *ClientWithResponses) GetTargetBidRecommendationsWithApplicationVndSdtargetingrecommendationsV31PlusJSONBodyWithResponse(ctx context.Context, params *GetTargetBidRecommendationsParams, body GetTargetBidRecommendationsApplicationVndSdtargetingrecommendationsV31PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetTargetBidRecommendationsResp, error) {
	rsp, err := c.GetTargetBidRecommendationsWithApplicationVndSdtargetingrecommendationsV31PlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTargetBidRecommendationsResp(rsp)
}

func (c *ClientWithResponses) GetTargetBidRecommendationsWithApplicationVndSdtargetingrecommendationsV32PlusJSONBodyWithResponse(ctx context.Context, params *GetTargetBidRecommendationsParams, body GetTargetBidRecommendationsApplicationVndSdtargetingrecommendationsV32PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetTargetBidRecommendationsResp, error) {
	rsp, err := c.GetTargetBidRecommendationsWithApplicationVndSdtargetingrecommendationsV32PlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTargetBidRecommendationsResp(rsp)
}

// ListTargetingClausesExWithResponse request returning *ListTargetingClausesExResp
func (c *ClientWithResponses) ListTargetingClausesExWithResponse(ctx context.Context, params *ListTargetingClausesExParams, reqEditors ...RequestEditorFn) (*ListTargetingClausesExResp, error) {
	rsp, err := c.ListTargetingClausesEx(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTargetingClausesExResp(rsp)
}

// GetTargetsExWithResponse request returning *GetTargetsExResp
func (c *ClientWithResponses) GetTargetsExWithResponse(ctx context.Context, targetId int64, params *GetTargetsExParams, reqEditors ...RequestEditorFn) (*GetTargetsExResp, error) {
	rsp, err := c.GetTargetsEx(ctx, targetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTargetsExResp(rsp)
}

// GetTargetRecommendationsWithBodyWithResponse request with arbitrary body returning *GetTargetRecommendationsResp
func (c *ClientWithResponses) GetTargetRecommendationsWithBodyWithResponse(ctx context.Context, params *GetTargetRecommendationsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetTargetRecommendationsResp, error) {
	rsp, err := c.GetTargetRecommendationsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTargetRecommendationsResp(rsp)
}

func (c *ClientWithResponses) GetTargetRecommendationsWithApplicationVndSdtargetingrecommendationsV30PlusJSONBodyWithResponse(ctx context.Context, params *GetTargetRecommendationsParams, body GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV30PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetTargetRecommendationsResp, error) {
	rsp, err := c.GetTargetRecommendationsWithApplicationVndSdtargetingrecommendationsV30PlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTargetRecommendationsResp(rsp)
}

func (c *ClientWithResponses) GetTargetRecommendationsWithApplicationVndSdtargetingrecommendationsV31PlusJSONBodyWithResponse(ctx context.Context, params *GetTargetRecommendationsParams, body GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV31PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetTargetRecommendationsResp, error) {
	rsp, err := c.GetTargetRecommendationsWithApplicationVndSdtargetingrecommendationsV31PlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTargetRecommendationsResp(rsp)
}

func (c *ClientWithResponses) GetTargetRecommendationsWithApplicationVndSdtargetingrecommendationsV32PlusJSONBodyWithResponse(ctx context.Context, params *GetTargetRecommendationsParams, body GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV32PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetTargetRecommendationsResp, error) {
	rsp, err := c.GetTargetRecommendationsWithApplicationVndSdtargetingrecommendationsV32PlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTargetRecommendationsResp(rsp)
}

func (c *ClientWithResponses) GetTargetRecommendationsWithApplicationVndSdtargetingrecommendationsV33PlusJSONBodyWithResponse(ctx context.Context, params *GetTargetRecommendationsParams, body GetTargetRecommendationsApplicationVndSdtargetingrecommendationsV33PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*GetTargetRecommendationsResp, error) {
	rsp, err := c.GetTargetRecommendationsWithApplicationVndSdtargetingrecommendationsV33PlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTargetRecommendationsResp(rsp)
}

// ArchiveTargetingClauseWithResponse request returning *ArchiveTargetingClauseResp
func (c *ClientWithResponses) ArchiveTargetingClauseWithResponse(ctx context.Context, targetId int64, params *ArchiveTargetingClauseParams, reqEditors ...RequestEditorFn) (*ArchiveTargetingClauseResp, error) {
	rsp, err := c.ArchiveTargetingClause(ctx, targetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveTargetingClauseResp(rsp)
}

// GetTargetsWithResponse request returning *GetTargetsResp
func (c *ClientWithResponses) GetTargetsWithResponse(ctx context.Context, targetId int64, params *GetTargetsParams, reqEditors ...RequestEditorFn) (*GetTargetsResp, error) {
	rsp, err := c.GetTargets(ctx, targetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTargetsResp(rsp)
}

// RequestReportWithBodyWithResponse request with arbitrary body returning *RequestReportResp
func (c *ClientWithResponses) RequestReportWithBodyWithResponse(ctx context.Context, recordType RequestReportParamsRecordType, params *RequestReportParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RequestReportResp, error) {
	rsp, err := c.RequestReportWithBody(ctx, recordType, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestReportResp(rsp)
}

func (c *ClientWithResponses) RequestReportWithResponse(ctx context.Context, recordType RequestReportParamsRecordType, params *RequestReportParams, body RequestReportJSONRequestBody, reqEditors ...RequestEditorFn) (*RequestReportResp, error) {
	rsp, err := c.RequestReport(ctx, recordType, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestReportResp(rsp)
}

// CreateSnapshotWithBodyWithResponse request with arbitrary body returning *CreateSnapshotResp
func (c *ClientWithResponses) CreateSnapshotWithBodyWithResponse(ctx context.Context, recordType string, params *CreateSnapshotParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSnapshotResp, error) {
	rsp, err := c.CreateSnapshotWithBody(ctx, recordType, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSnapshotResp(rsp)
}

func (c *ClientWithResponses) CreateSnapshotWithResponse(ctx context.Context, recordType string, params *CreateSnapshotParams, body CreateSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSnapshotResp, error) {
	rsp, err := c.CreateSnapshot(ctx, recordType, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSnapshotResp(rsp)
}

// GetReportStatusWithResponse request returning *GetReportStatusResp
func (c *ClientWithResponses) GetReportStatusWithResponse(ctx context.Context, reportId string, params *GetReportStatusParams, reqEditors ...RequestEditorFn) (*GetReportStatusResp, error) {
	rsp, err := c.GetReportStatus(ctx, reportId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReportStatusResp(rsp)
}

// DownloadReportWithResponse request returning *DownloadReportResp
func (c *ClientWithResponses) DownloadReportWithResponse(ctx context.Context, reportId string, params *DownloadReportParams, reqEditors ...RequestEditorFn) (*DownloadReportResp, error) {
	rsp, err := c.DownloadReport(ctx, reportId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadReportResp(rsp)
}

// ParseListAdGroupsResp parses an HTTP response from a ListAdGroupsWithResponse call
func ParseListAdGroupsResp(rsp *http.Response) (*ListAdGroupsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAdGroupsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AdGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateAdGroupsResp parses an HTTP response from a CreateAdGroupsWithResponse call
func ParseCreateAdGroupsResp(rsp *http.Response) (*CreateAdGroupsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAdGroupsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest []AdGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAdGroupsResp parses an HTTP response from a UpdateAdGroupsWithResponse call
func ParseUpdateAdGroupsResp(rsp *http.Response) (*UpdateAdGroupsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAdGroupsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest []AdGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListAdGroupsExResp parses an HTTP response from a ListAdGroupsExWithResponse call
func ParseListAdGroupsExResp(rsp *http.Response) (*ListAdGroupsExResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAdGroupsExResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AdGroupResponseEx
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAdGroupResponseExResp parses an HTTP response from a GetAdGroupResponseExWithResponse call
func ParseGetAdGroupResponseExResp(rsp *http.Response) (*GetAdGroupResponseExResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAdGroupResponseExResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdGroupResponseEx
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseArchiveAdGroupResp parses an HTTP response from a ArchiveAdGroupWithResponse call
func ParseArchiveAdGroupResp(rsp *http.Response) (*ArchiveAdGroupResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveAdGroupResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAdGroupResp parses an HTTP response from a GetAdGroupWithResponse call
func ParseGetAdGroupResp(rsp *http.Response) (*GetAdGroupResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAdGroupResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSdAdGroupsAdGroupIdOptimizationRulesResp parses an HTTP response from a GetSdAdGroupsAdGroupIdOptimizationRulesWithResponse call
func ParseGetSdAdGroupsAdGroupIdOptimizationRulesResp(rsp *http.Response) (*GetSdAdGroupsAdGroupIdOptimizationRulesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSdAdGroupsAdGroupIdOptimizationRulesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OptimizationRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAssociateOptimizationRulesWithAdGroupResp parses an HTTP response from a AssociateOptimizationRulesWithAdGroupWithResponse call
func ParseAssociateOptimizationRulesWithAdGroupResp(rsp *http.Response) (*AssociateOptimizationRulesWithAdGroupResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssociateOptimizationRulesWithAdGroupResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest []OptimizationRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteBrandSafetyDenyListResp parses an HTTP response from a DeleteBrandSafetyDenyListWithResponse call
func ParseDeleteBrandSafetyDenyListResp(rsp *http.Response) (*DeleteBrandSafetyDenyListResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBrandSafetyDenyListResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest BrandSafetyUpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListDomainsResp parses an HTTP response from a ListDomainsWithResponse call
func ParseListDomainsResp(rsp *http.Response) (*ListDomainsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDomainsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BrandSafetyGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateBrandSafetyDenyListDomainsResp parses an HTTP response from a CreateBrandSafetyDenyListDomainsWithResponse call
func ParseCreateBrandSafetyDenyListDomainsResp(rsp *http.Response) (*CreateBrandSafetyDenyListDomainsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBrandSafetyDenyListDomainsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest BrandSafetyUpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListRequestStatusResp parses an HTTP response from a ListRequestStatusWithResponse call
func ParseListRequestStatusResp(rsp *http.Response) (*ListRequestStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRequestStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BrandSafetyListRequestStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRequestResultsResp parses an HTTP response from a GetRequestResultsWithResponse call
func ParseGetRequestResultsResp(rsp *http.Response) (*GetRequestResultsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRequestResultsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BrandSafetyRequestResultsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRequestStatusResp parses an HTTP response from a GetRequestStatusWithResponse call
func ParseGetRequestStatusResp(rsp *http.Response) (*GetRequestStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRequestStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BrandSafetyRequestStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSDBudgetRulesForAdvertiserResp parses an HTTP response from a GetSDBudgetRulesForAdvertiserWithResponse call
func ParseGetSDBudgetRulesForAdvertiserResp(rsp *http.Response) (*GetSDBudgetRulesForAdvertiserResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSDBudgetRulesForAdvertiserResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSDBudgetRulesForAdvertiserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateBudgetRulesForSDCampaignsResp parses an HTTP response from a CreateBudgetRulesForSDCampaignsWithResponse call
func ParseCreateBudgetRulesForSDCampaignsResp(rsp *http.Response) (*CreateBudgetRulesForSDCampaignsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBudgetRulesForSDCampaignsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest CreateBudgetRulesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateBudgetRulesForSDCampaignsResp parses an HTTP response from a UpdateBudgetRulesForSDCampaignsWithResponse call
func ParseUpdateBudgetRulesForSDCampaignsResp(rsp *http.Response) (*UpdateBudgetRulesForSDCampaignsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBudgetRulesForSDCampaignsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest UpdateBudgetRulesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBudgetRuleByRuleIdForSDCampaignsResp parses an HTTP response from a GetBudgetRuleByRuleIdForSDCampaignsWithResponse call
func ParseGetBudgetRuleByRuleIdForSDCampaignsResp(rsp *http.Response) (*GetBudgetRuleByRuleIdForSDCampaignsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBudgetRuleByRuleIdForSDCampaignsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSDBudgetRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListCampaignsResp parses an HTTP response from a ListCampaignsWithResponse call
func ParseListCampaignsResp(rsp *http.Response) (*ListCampaignsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCampaignsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Campaign
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateCampaignsResp parses an HTTP response from a CreateCampaignsWithResponse call
func ParseCreateCampaignsResp(rsp *http.Response) (*CreateCampaignsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCampaignsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest []CampaignResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateCampaignsResp parses an HTTP response from a UpdateCampaignsWithResponse call
func ParseUpdateCampaignsResp(rsp *http.Response) (*UpdateCampaignsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCampaignsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest []CampaignResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSdCampaignsBudgetUsageResp parses an HTTP response from a SdCampaignsBudgetUsageWithResponse call
func ParseSdCampaignsBudgetUsageResp(rsp *http.Response) (*SdCampaignsBudgetUsageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SdCampaignsBudgetUsageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest BudgetUsageCampaignResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndSdcampaignbudgetusageV1JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BudgetUsageError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BudgetUsageError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BudgetUsageError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest BudgetUsageError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest BudgetUsageError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BudgetUsageError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListCampaignsExResp parses an HTTP response from a ListCampaignsExWithResponse call
func ParseListCampaignsExResp(rsp *http.Response) (*ListCampaignsExResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCampaignsExResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CampaignResponseEx
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCampaignResponseExResp parses an HTTP response from a GetCampaignResponseExWithResponse call
func ParseGetCampaignResponseExResp(rsp *http.Response) (*GetCampaignResponseExResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCampaignResponseExResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CampaignResponseEx
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseArchiveCampaignResp parses an HTTP response from a ArchiveCampaignWithResponse call
func ParseArchiveCampaignResp(rsp *http.Response) (*ArchiveCampaignResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveCampaignResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CampaignResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCampaignResp parses an HTTP response from a GetCampaignWithResponse call
func ParseGetCampaignResp(rsp *http.Response) (*GetCampaignResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCampaignResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Campaign
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRuleBasedBudgetHistoryForSDCampaignsResp parses an HTTP response from a GetRuleBasedBudgetHistoryForSDCampaignsWithResponse call
func ParseGetRuleBasedBudgetHistoryForSDCampaignsResp(rsp *http.Response) (*GetRuleBasedBudgetHistoryForSDCampaignsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleBasedBudgetHistoryForSDCampaignsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SDBudgetHistory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BudgetRuleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListCreativesResp parses an HTTP response from a ListCreativesWithResponse call
func ParseListCreativesResp(rsp *http.Response) (*ListCreativesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCreativesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Creative
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateCreativesResp parses an HTTP response from a CreateCreativesWithResponse call
func ParseCreateCreativesResp(rsp *http.Response) (*CreateCreativesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCreativesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest []CreativeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateCreativesResp parses an HTTP response from a UpdateCreativesWithResponse call
func ParseUpdateCreativesResp(rsp *http.Response) (*UpdateCreativesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCreativesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest []CreativeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostCreativePreviewResp parses an HTTP response from a PostCreativePreviewWithResponse call
func ParsePostCreativePreviewResp(rsp *http.Response) (*PostCreativePreviewResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCreativePreviewResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreativePreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSDForecastResp parses an HTTP response from a CreateSDForecastWithResponse call
func ParseCreateSDForecastResp(rsp *http.Response) (*CreateSDForecastResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSDForecastResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SDForecastResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndSdforecastsV30JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest SDForecastErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndSdforecastsV30JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest SDForecastErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndSdforecastsV30JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest SDForecastErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndSdforecastsV30JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest SDForecastErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndSdforecastsV30JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest SDForecastErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndSdforecastsV30JSON500 = &dest

	}

	return response, nil
}

// ParseListLocationsResp parses an HTTP response from a ListLocationsWithResponse call
func ParseListLocationsResp(rsp *http.Response) (*ListLocationsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLocationsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Location
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateLocationsResp parses an HTTP response from a CreateLocationsWithResponse call
func ParseCreateLocationsResp(rsp *http.Response) (*CreateLocationsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLocationsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Location
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListCreativeModerationsResp parses an HTTP response from a ListCreativeModerationsWithResponse call
func ParseListCreativeModerationsResp(rsp *http.Response) (*ListCreativeModerationsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCreativeModerationsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CreativeModeration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListNegativeTargetingClausesResp parses an HTTP response from a ListNegativeTargetingClausesWithResponse call
func ParseListNegativeTargetingClausesResp(rsp *http.Response) (*ListNegativeTargetingClausesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNegativeTargetingClausesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []NegativeTargetingClause
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateNegativeTargetingClausesResp parses an HTTP response from a CreateNegativeTargetingClausesWithResponse call
func ParseCreateNegativeTargetingClausesResp(rsp *http.Response) (*CreateNegativeTargetingClausesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNegativeTargetingClausesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest []TargetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateNegativeTargetingClausesResp parses an HTTP response from a UpdateNegativeTargetingClausesWithResponse call
func ParseUpdateNegativeTargetingClausesResp(rsp *http.Response) (*UpdateNegativeTargetingClausesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNegativeTargetingClausesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest []TargetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListNegativeTargetingClausesExResp parses an HTTP response from a ListNegativeTargetingClausesExWithResponse call
func ParseListNegativeTargetingClausesExResp(rsp *http.Response) (*ListNegativeTargetingClausesExResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNegativeTargetingClausesExResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []NegativeTargetingClauseEx
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNegativeTargetsExResp parses an HTTP response from a GetNegativeTargetsExWithResponse call
func ParseGetNegativeTargetsExResp(rsp *http.Response) (*GetNegativeTargetsExResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNegativeTargetsExResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NegativeTargetingClauseEx
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseArchiveNegativeTargetingClauseResp parses an HTTP response from a ArchiveNegativeTargetingClauseWithResponse call
func ParseArchiveNegativeTargetingClauseResp(rsp *http.Response) (*ArchiveNegativeTargetingClauseResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveNegativeTargetingClauseResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TargetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNegativeTargetsResp parses an HTTP response from a GetNegativeTargetsWithResponse call
func ParseGetNegativeTargetsResp(rsp *http.Response) (*GetNegativeTargetsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNegativeTargetsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NegativeTargetingClause
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListOptimizationRulesResp parses an HTTP response from a ListOptimizationRulesWithResponse call
func ParseListOptimizationRulesResp(rsp *http.Response) (*ListOptimizationRulesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOptimizationRulesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OptimizationRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateOptimizationRulesResp parses an HTTP response from a CreateOptimizationRulesWithResponse call
func ParseCreateOptimizationRulesResp(rsp *http.Response) (*CreateOptimizationRulesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOptimizationRulesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest []OptimizationRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateOptimizationRulesResp parses an HTTP response from a UpdateOptimizationRulesWithResponse call
func ParseUpdateOptimizationRulesResp(rsp *http.Response) (*UpdateOptimizationRulesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOptimizationRulesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest []OptimizationRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSdOptimizationRulesOptimizationRuleIdResp parses an HTTP response from a GetSdOptimizationRulesOptimizationRuleIdWithResponse call
func ParseGetSdOptimizationRulesOptimizationRuleIdResp(rsp *http.Response) (*GetSdOptimizationRulesOptimizationRuleIdResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSdOptimizationRulesOptimizationRuleIdResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OptimizationRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListProductAdsResp parses an HTTP response from a ListProductAdsWithResponse call
func ParseListProductAdsResp(rsp *http.Response) (*ListProductAdsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProductAdsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ProductAd
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateProductAdsResp parses an HTTP response from a CreateProductAdsWithResponse call
func ParseCreateProductAdsResp(rsp *http.Response) (*CreateProductAdsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProductAdsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest []ProductAdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateProductAdsResp parses an HTTP response from a UpdateProductAdsWithResponse call
func ParseUpdateProductAdsResp(rsp *http.Response) (*UpdateProductAdsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProductAdsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest []ProductAdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListProductAdsExResp parses an HTTP response from a ListProductAdsExWithResponse call
func ParseListProductAdsExResp(rsp *http.Response) (*ListProductAdsExResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProductAdsExResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ProductAdResponseEx
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductAdResponseExResp parses an HTTP response from a GetProductAdResponseExWithResponse call
func ParseGetProductAdResponseExResp(rsp *http.Response) (*GetProductAdResponseExResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductAdResponseExResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductAdResponseEx
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseArchiveProductAdResp parses an HTTP response from a ArchiveProductAdWithResponse call
func ParseArchiveProductAdResp(rsp *http.Response) (*ArchiveProductAdResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveProductAdResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductAdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductAdResp parses an HTTP response from a GetProductAdWithResponse call
func ParseGetProductAdResp(rsp *http.Response) (*GetProductAdResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductAdResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductAd
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSnapshotResp parses an HTTP response from a GetSnapshotWithResponse call
func ParseGetSnapshotResp(rsp *http.Response) (*GetSnapshotResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSnapshotResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SnapshotResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDownloadSnapshotResp parses an HTTP response from a DownloadSnapshotWithResponse call
func ParseDownloadSnapshotResp(rsp *http.Response) (*DownloadSnapshotResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadSnapshotResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTargetingClausesResp parses an HTTP response from a ListTargetingClausesWithResponse call
func ParseListTargetingClausesResp(rsp *http.Response) (*ListTargetingClausesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTargetingClausesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TargetingClause
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateTargetingClausesResp parses an HTTP response from a CreateTargetingClausesWithResponse call
func ParseCreateTargetingClausesResp(rsp *http.Response) (*CreateTargetingClausesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTargetingClausesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest []TargetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateTargetingClausesResp parses an HTTP response from a UpdateTargetingClausesWithResponse call
func ParseUpdateTargetingClausesResp(rsp *http.Response) (*UpdateTargetingClausesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTargetingClausesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest []TargetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTargetBidRecommendationsResp parses an HTTP response from a GetTargetBidRecommendationsWithResponse call
func ParseGetTargetBidRecommendationsResp(rsp *http.Response) (*GetTargetBidRecommendationsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTargetBidRecommendationsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/vnd.sdtargetingrecommendations.v3.1+json" && rsp.StatusCode == 207:
		var dest SDTargetingBidRecommendationsResponseV31
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndSdtargetingrecommendationsV31JSON207 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.sdtargetingrecommendations.v3.2+json" && rsp.StatusCode == 207:
		var dest SDTargetingBidRecommendationsResponseV32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndSdtargetingrecommendationsV32JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest SDErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest SDErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest SDErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest SDErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest SDErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest SDErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListTargetingClausesExResp parses an HTTP response from a ListTargetingClausesExWithResponse call
func ParseListTargetingClausesExResp(rsp *http.Response) (*ListTargetingClausesExResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTargetingClausesExResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TargetingClauseEx
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTargetsExResp parses an HTTP response from a GetTargetsExWithResponse call
func ParseGetTargetsExResp(rsp *http.Response) (*GetTargetsExResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTargetsExResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TargetingClauseEx
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTargetRecommendationsResp parses an HTTP response from a GetTargetRecommendationsWithResponse call
func ParseGetTargetRecommendationsResp(rsp *http.Response) (*GetTargetRecommendationsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTargetRecommendationsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/vnd.sdtargetingrecommendations.v3.0+json" && rsp.StatusCode == 200:
		var dest SDTargetingRecommendationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndSdtargetingrecommendationsV30JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.sdtargetingrecommendations.v3.1+json" && rsp.StatusCode == 200:
		var dest SDTargetingRecommendationsResponseV31
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndSdtargetingrecommendationsV31JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.sdtargetingrecommendations.v3.2+json" && rsp.StatusCode == 200:
		var dest SDTargetingRecommendationsResponseV32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndSdtargetingrecommendationsV32JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.sdtargetingrecommendations.v3.3+json" && rsp.StatusCode == 200:
		var dest SDTargetingRecommendationsResponseV33
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndSdtargetingrecommendationsV33JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest SDErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest SDErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest SDErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest SDErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest SDErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest SDErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseArchiveTargetingClauseResp parses an HTTP response from a ArchiveTargetingClauseWithResponse call
func ParseArchiveTargetingClauseResp(rsp *http.Response) (*ArchiveTargetingClauseResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveTargetingClauseResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TargetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTargetsResp parses an HTTP response from a GetTargetsWithResponse call
func ParseGetTargetsResp(rsp *http.Response) (*GetTargetsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTargetsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TargetingClause
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRequestReportResp parses an HTTP response from a RequestReportWithResponse call
func ParseRequestReportResp(rsp *http.Response) (*RequestReportResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestReportResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ReportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSnapshotResp parses an HTTP response from a CreateSnapshotWithResponse call
func ParseCreateSnapshotResp(rsp *http.Response) (*CreateSnapshotResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSnapshotResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SnapshotResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetReportStatusResp parses an HTTP response from a GetReportStatusWithResponse call
func ParseGetReportStatusResp(rsp *http.Response) (*GetReportStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReportStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDownloadReportResp parses an HTTP response from a DownloadReportWithResponse call
func ParseDownloadReportResp(rsp *http.Response) (*DownloadReportResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadReportResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
