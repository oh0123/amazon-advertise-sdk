// Package eligibility provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.15.0 DO NOT EDIT.
package eligibility

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

// Defines values for AcceptLanguage.
const (
	ArAE AcceptLanguage = "ar-AE"
	DeDE AcceptLanguage = "de-DE"
	EnAU AcceptLanguage = "en-AU"
	EnCA AcceptLanguage = "en-CA"
	EnGB AcceptLanguage = "en-GB"
	EnIN AcceptLanguage = "en-IN"
	EnUS AcceptLanguage = "en-US"
	EsES AcceptLanguage = "es-ES"
	EsMX AcceptLanguage = "es-MX"
	EsUS AcceptLanguage = "es-US"
	FrCA AcceptLanguage = "fr-CA"
	FrFR AcceptLanguage = "fr-FR"
	ItIT AcceptLanguage = "it-IT"
	JaJP AcceptLanguage = "ja-JP"
	KoKR AcceptLanguage = "ko-KR"
	NlNL AcceptLanguage = "nl-NL"
	PlPL AcceptLanguage = "pl-PL"
	PtBR AcceptLanguage = "pt-BR"
	TrTR AcceptLanguage = "tr-TR"
	ZhCN AcceptLanguage = "zh-CN"
)

// Defines values for AdProgram.
const (
	DTC  AdProgram = "DTC"
	MAAS AdProgram = "MAAS"
	SB   AdProgram = "SB"
	SD   AdProgram = "SD"
	SPOT AdProgram = "SPOT"
)

// Defines values for EligibilityStatusName.
const (
	ADULTPRODUCT          EligibilityStatusName = "ADULT_PRODUCT"
	CLOSEDCATEGORY        EligibilityStatusName = "CLOSED_CATEGORY"
	INELIGIBLECONDITION   EligibilityStatusName = "INELIGIBLE_CONDITION"
	INELIGIBLEOFFER       EligibilityStatusName = "INELIGIBLE_OFFER"
	INELIGIBLEPRODUCTCOST EligibilityStatusName = "INELIGIBLE_PRODUCT_COST"
	LISTINGSUPRESSED      EligibilityStatusName = "LISTING_SUPRESSED"
	MISSINGIMAGE          EligibilityStatusName = "MISSING_IMAGE"
	MISSINGTITLE          EligibilityStatusName = "MISSING_TITLE"
	NOTINBUYBOX           EligibilityStatusName = "NOT_IN_BUYBOX"
	OUTOFSTOCK            EligibilityStatusName = "OUT_OF_STOCK"
	RESTRICTEDCATEGORY    EligibilityStatusName = "RESTRICTED_CATEGORY"
	VARIATIONPARENT       EligibilityStatusName = "VARIATION_PARENT"
)

// Defines values for EligibilityStatusSeverity.
const (
	EligibilityStatusSeverityELIGIBLEWITHWARNING EligibilityStatusSeverity = "ELIGIBLE_WITH_WARNING"
	EligibilityStatusSeverityINELIGIBLE          EligibilityStatusSeverity = "INELIGIBLE"
)

// Defines values for IneligibleLevel.
const (
	IneligibleLevelINELIGIBLE               IneligibleLevel = "INELIGIBLE"
	IneligibleLevelINELIGIBLEWITHRESOLUTION IneligibleLevel = "INELIGIBLE_WITH_RESOLUTION"
)

// Defines values for ProductEligibilityRequestAdType.
const (
	Sb ProductEligibilityRequestAdType = "sb"
	Sd ProductEligibilityRequestAdType = "sd"
	Sp ProductEligibilityRequestAdType = "sp"
)

// Defines values for ProductResponseOverallStatus.
const (
	ELIGIBLE            ProductResponseOverallStatus = "ELIGIBLE"
	ELIGIBLEWITHWARNING ProductResponseOverallStatus = "ELIGIBLE_WITH_WARNING"
	INELIGIBLE          ProductResponseOverallStatus = "INELIGIBLE"
)

// Defines values for ReasonCode.
const (
	ACCOUNTSUSPENDED                     ReasonCode = "ACCOUNT_SUSPENDED"
	ADVERTISINGACCOUNTNOTFOUND           ReasonCode = "ADVERTISING_ACCOUNT_NOT_FOUND"
	BILLINGACCOUNTNOTFOUND               ReasonCode = "BILLING_ACCOUNT_NOT_FOUND"
	BLOCKED                              ReasonCode = "BLOCKED"
	DIRECTTOCONSUMEROWNERTAGIDNOTFOUND   ReasonCode = "DIRECT_TO_CONSUMER_OWNER_TAG_ID_NOT_FOUND"
	DIRECTTOCONSUMERSUBSCRIPTIONNOTFOUND ReasonCode = "DIRECT_TO_CONSUMER_SUBSCRIPTION_NOT_FOUND"
	EXPIREDPAYMENTMETHOD                 ReasonCode = "EXPIRED_PAYMENT_METHOD"
	NOBRANDRELATIONS                     ReasonCode = "NO_BRAND_RELATIONS"
	NOTACTICENABLED                      ReasonCode = "NO_TACTIC_ENABLED"
	NOTBRANDREPRESENTATIVE               ReasonCode = "NOT_BRAND_REPRESENTATIVE"
	NOTLAUNCHEDINMARKETPLACE             ReasonCode = "NOT_LAUNCHED_IN_MARKETPLACE"
	PAYMENTMETHODNOTFOUND                ReasonCode = "PAYMENT_METHOD_NOT_FOUND"
	PAYMENTMETHODNOTVALID                ReasonCode = "PAYMENT_METHOD_NOT_VALID"
	PAYMENTPROFILENOTFOUND               ReasonCode = "PAYMENT_PROFILE_NOT_FOUND"
	PREPAYBALANCETOOLOW                  ReasonCode = "PREPAY_BALANCE_TOO_LOW"
	ROBALANCETOOLOW                      ReasonCode = "RO_BALANCE_TOO_LOW"
	SUBSCRIPTIONNOTFOUND                 ReasonCode = "SUBSCRIPTION_NOT_FOUND"
	TAXINFONOTCOMPLETE                   ReasonCode = "TAX_INFO_NOT_COMPLETE"
	UNKNOWN                              ReasonCode = "UNKNOWN"
	VETTINGFAILURE                       ReasonCode = "VETTING_FAILURE"
)

// AcceptLanguage defines model for AcceptLanguage.
type AcceptLanguage string

// AdProgram This defines the AdPrograms supported
type AdProgram string

// BadRequestExceptionResponseContent defines model for BadRequestExceptionResponseContent.
type BadRequestExceptionResponseContent struct {
	// Code Programmatic status code.
	Code *float32 `json:"code,omitempty"`

	// Details A human-readable description of the response.
	Details *string `json:"details,omitempty"`
}

// Check A union of all the checks that we would want to skip
type Check struct {
	union json.RawMessage
}

// Check0 defines model for .
type Check0 struct {
	// SkipAllBillingChecks Skip all billing/payments/suspension related checks
	SkipAllBillingChecks bool `json:"skipAllBillingChecks"`
}

// EligibilityStatus The advertising eligibility status of a product.
type EligibilityStatus struct {
	// HelpUrl A URL with additional information about the status identifier. May not be present for all status identifiers.
	HelpUrl *string `json:"helpUrl,omitempty"`

	// Message A human-readable description of the status identifier specified in the `name` field.
	Message *string `json:"message,omitempty"`

	// Name The status identifier.
	Name *EligibilityStatusName `json:"name,omitempty"`

	// Severity An enumerated advertising eligibility severity status. If set to `INELIGIBLE`, the product cannot be included in an advertisement. If set to `ELIGIBLE_WITH_WARNING`, the product may not receive impressions when included in an advertisement.
	Severity *EligibilityStatusSeverity `json:"severity,omitempty"`
}

// EligibilityStatusName The status identifier.
type EligibilityStatusName string

// EligibilityStatusSeverity An enumerated advertising eligibility severity status. If set to `INELIGIBLE`, the product cannot be included in an advertisement. If set to `ELIGIBLE_WITH_WARNING`, the product may not receive impressions when included in an advertisement.
type EligibilityStatusSeverity string

// EligibilityStatusDetail Describes a single program's eligibility status
type EligibilityStatusDetail struct {
	// Eligible Boolean value where if true, advertiser is eligible to access the given program.
	Eligible *bool `json:"eligible,omitempty"`

	// Reasons String identifier for the status.
	Reasons *[]ReasonItem `json:"reasons,omitempty"`
}

// EligibilityStatusDetailV2 Describes a single program's eligibility status
type EligibilityStatusDetailV2 struct {
	// AdProgram This defines the AdPrograms supported
	AdProgram *AdProgram `json:"adProgram,omitempty"`

	// Eligible Boolean value where if true, advertiser is eligible to access the given program.
	Eligible *bool `json:"eligible,omitempty"`

	// Reasons String identifier for the status.
	Reasons *[]ReasonItem `json:"reasons,omitempty"`
}

// EligibilityStatusMap This is a map that will be key'd on the ad program (SB/SD/DTC/MAAS/SPOT); the value will be an eligibility object.
type EligibilityStatusMap map[string]EligibilityStatusDetail

// IneligibleLevel defines model for IneligibleLevel.
type IneligibleLevel string

// InternalServerErrorExceptionResponseContent defines model for InternalServerErrorExceptionResponseContent.
type InternalServerErrorExceptionResponseContent struct {
	// Code Programmatic status code.
	Code *float32 `json:"code,omitempty"`

	// Details A human-readable description of the response.
	Details *string `json:"details,omitempty"`
}

// MarketplaceEntitiesEligibilityStatusList defines model for MarketplaceEntitiesEligibilityStatusList.
type MarketplaceEntitiesEligibilityStatusList struct {
	// EligibilityStatusList This is a map that will be key'd on the ad program (SB/SD/DTC/MAAS/SPOT); the value will be an eligibility object.
	EligibilityStatusList *[]EligibilityStatusDetailV2 `json:"eligibilityStatusList,omitempty"`
	EntityId              *string                      `json:"entityId,omitempty"`
	MarketplaceId         *string                      `json:"marketplaceId,omitempty"`
}

// NotFoundExceptionResponseContent defines model for NotFoundExceptionResponseContent.
type NotFoundExceptionResponseContent struct {
	// Code Programmatic status code.
	Code *float32 `json:"code,omitempty"`

	// Details A human-readable description of the response.
	Details *string `json:"details,omitempty"`
}

// ProductDetails An Amazon product identifier, seller product identifer, or both.
type ProductDetails struct {
	// Asin An Amazon product identifier.
	Asin string `json:"asin"`

	// Sku A seller product identifier.
	Sku *string `json:"sku,omitempty"`
}

// ProductEligibilityError The error response object.
type ProductEligibilityError struct {
	// Code The HTTP status code of the response.
	Code *string `json:"code,omitempty"`

	// Details A human-readable description of the response.
	Details *string `json:"details,omitempty"`
}

// ProductEligibilityRequest A product advertising eligibility request object.
type ProductEligibilityRequest struct {
	// AdType Set to 'sp' to check product eligibility for Sponsored Products advertisements. Set to 'sb' to check product eligibility for Sponsored Brands advertisements. Set to 'sd' to check product eligibility for Sponsored Display advertisements.
	AdType *ProductEligibilityRequestAdType `json:"adType,omitempty"`

	// Locale Set to the locale string in the table below to specify the language in which the response is returned.
	// |Locale|Language (ISO 639)|Country (ISO 3166)|
	// |------|------------------|------------------|
	// |ar-AE|Arabic (ar)|United Arab Emirates (AE)|
	// |zh-CN|Chinese (zh)|China (CN)|
	// |nl-NL|Dutch (nl)|Netherlands (NL)|
	// |en-AU|English (en)|Australia (AU)|
	// |en-CA|English (en)|Canada (CA)|
	// |en-IN|English (en)|India (IN)|
	// |en-GB|English (en)|United Kingdom (GB)|
	// |en-US|English (en)|United States (US)|
	// |fr-CA|French (fr)|Canada (CA)|
	// |fr-FR|French (fr)|France (FR)|
	// |de-DE|German (de)|Germany (DE)|
	// |it-IT|Italian (it)|Italy (IT)|
	// |ja-JP|Japanese (ja)|Japan (JP)|
	// |ko-KR|Korean (ko)|South Korea (KR)|
	// |pt-BR|Portuguese (pt)|Brazil (BR)|
	// |es-ES|Spanish (es)|Spain (ES)|
	// |es-US|Spanish (es)|United States (US)|
	// |es-MX|Spanish (es)|Mexico (MX)|
	// |tr-TR|Turkish (tr)|Turkey (TR)|
	Locale *string `json:"locale,omitempty"`

	// ProductDetailsList A list of product identifier objects.
	ProductDetailsList []ProductDetails `json:"productDetailsList"`
}

// ProductEligibilityRequestAdType Set to 'sp' to check product eligibility for Sponsored Products advertisements. Set to 'sb' to check product eligibility for Sponsored Brands advertisements. Set to 'sd' to check product eligibility for Sponsored Display advertisements.
type ProductEligibilityRequestAdType string

// ProductEligibilityResponse A product advertising eligibility response object.
type ProductEligibilityResponse struct {
	// ProductResponseList A list of product advertising eligibility responses.
	ProductResponseList *[]ProductResponse `json:"productResponseList,omitempty"`
}

// ProductResponse An product advertising eligibility response.
type ProductResponse struct {
	EligibilityStatusList []EligibilityStatus `json:"eligibilityStatusList"`

	// OverallStatus A human-readable description of the product's advertising eligibility status. Inherits highest severity from eligibilityStatusList.
	OverallStatus ProductResponseOverallStatus `json:"overallStatus"`

	// ProductDetails An Amazon product identifier, seller product identifer, or both.
	ProductDetails ProductDetails `json:"productDetails"`
}

// ProductResponseOverallStatus A human-readable description of the product's advertising eligibility status. Inherits highest severity from eligibilityStatusList.
type ProductResponseOverallStatus string

// ProgramEligibilityRequestContent A request to evaluate account level eligibility for Amazon ad programs (Sponsored Products, Sponsored Brands, Sponsored Display, Stores, DirectToConsumer, Amazon Attribution, etc).
type ProgramEligibilityRequestContent struct {
	// SkipChecks A union of all the checks that we would want to skip
	SkipChecks *Check `json:"skipChecks,omitempty"`
}

// ProgramEligibilityResponseContent An object of program eligibility responses for an advertiser.
type ProgramEligibilityResponseContent struct {
	// EligibilityStatusMap This is a map that will be key'd on the ad program (SB/SD/DTC/MAAS/SPOT); the value will be an eligibility object.
	EligibilityStatusMap *EligibilityStatusMap `json:"eligibilityStatusMap,omitempty"`
}

// ProgramEligibilityV2RequestContent A request to evaluate account level eligibility for Amazon ad programs (Sponsored Products, Sponsored Brands, Sponsored Display, Stores, DirectToConsumer, Amazon Attribution, etc).
type ProgramEligibilityV2RequestContent struct {
	// MaxResults Max results for pagination
	MaxResults *float32 `json:"maxResults,omitempty"`

	// NextToken The pagination token that is required to go to the next page
	NextToken *string `json:"nextToken,omitempty"`
}

// ProgramEligibilityV2ResponseContent An object of program eligibility responses for an advertiser.
type ProgramEligibilityV2ResponseContent struct {
	EligibilityStatusLists *[]MarketplaceEntitiesEligibilityStatusList `json:"eligibilityStatusLists,omitempty"`

	// NextToken token value allowing to navigate to the next response page
	NextToken *string `json:"nextToken,omitempty"`
}

// RateExceededExceptionResponseContent defines model for RateExceededExceptionResponseContent.
type RateExceededExceptionResponseContent struct {
	// Code Programmatic status code.
	Code *float32 `json:"code,omitempty"`

	// Details A human-readable description of the response.
	Details *string `json:"details,omitempty"`
}

// ReasonCode defines model for ReasonCode.
type ReasonCode string

// ReasonItem defines model for ReasonItem.
type ReasonItem struct {
	Code *ReasonCode `json:"code,omitempty"`

	// Description Message explaining what the status means. Example: Payment preference not found for associated billing account. Please add a new payment method
	Description *string          `json:"description,omitempty"`
	Level       *IneligibleLevel `json:"level,omitempty"`
}

// UnauthorizedExceptionResponseContent defines model for UnauthorizedExceptionResponseContent.
type UnauthorizedExceptionResponseContent struct {
	// Code Programmatic status code.
	Code *float32 `json:"code,omitempty"`

	// Details A human-readable description of the response.
	Details *string `json:"details,omitempty"`
}

// ProductEligibilityParams defines parameters for ProductEligibility.
type ProductEligibilityParams struct {
	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId string `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
	AmazonAdvertisingAPIScope string `json:"Amazon-Advertising-API-Scope"`
}

// ProgramEligibilityParams defines parameters for ProgramEligibility.
type ProgramEligibilityParams struct {
	// AcceptLanguage Specify the language in which the response is returned.
	AcceptLanguage *AcceptLanguage `json:"Accept-Language,omitempty"`

	// AmazonAdsAccountId The header used to pass global account associated with the advertiser account
	// Use `GET` method on the Global Ads Account resource to list the global ads account associated with the access token passed in the HTTP Authorization header and choose AdvertisingAccountIdentifier id from the response to pass it as input.
	// Use for v2 global calls
	AmazonAdsAccountId *string `json:"Amazon-Ads-AccountId,omitempty"`

	// AmazonAdvertisingAPIClientId The identifier of a client associated with a "Login with Amazon" account.
	AmazonAdvertisingAPIClientId string `json:"Amazon-Advertising-API-ClientId"`

	// AmazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use `GET` method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header and choose profile id `profileId` from the response to pass it as input.
	AmazonAdvertisingAPIScope *string `json:"Amazon-Advertising-API-Scope,omitempty"`

	// ContentType The content type of the request.
	ContentType *string `json:"Content-Type,omitempty"`
}

// ProductEligibilityJSONRequestBody defines body for ProductEligibility for application/json ContentType.
type ProductEligibilityJSONRequestBody = ProductEligibilityRequest

// ProgramEligibilityJSONRequestBody defines body for ProgramEligibility for application/json ContentType.
type ProgramEligibilityJSONRequestBody = ProgramEligibilityRequestContent

// ProgramEligibilityApplicationVndProgrameligibilityV2PlusJSONRequestBody defines body for ProgramEligibility for application/vnd.programeligibility.v2+json ContentType.
type ProgramEligibilityApplicationVndProgrameligibilityV2PlusJSONRequestBody = ProgramEligibilityV2RequestContent

// AsCheck0 returns the union data inside the Check as a Check0
func (t Check) AsCheck0() (Check0, error) {
	var body Check0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCheck0 overwrites any union data inside the Check as the provided Check0
func (t *Check) FromCheck0(v Check0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCheck0 performs a merge with any union data inside the Check, using the provided Check0
func (t *Check) MergeCheck0(v Check0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Check) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Check) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ProductEligibilityWithBody request with any body
	ProductEligibilityWithBody(ctx context.Context, params *ProductEligibilityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProductEligibility(ctx context.Context, params *ProductEligibilityParams, body ProductEligibilityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProgramEligibilityWithBody request with any body
	ProgramEligibilityWithBody(ctx context.Context, params *ProgramEligibilityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProgramEligibility(ctx context.Context, params *ProgramEligibilityParams, body ProgramEligibilityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProgramEligibilityWithApplicationVndProgrameligibilityV2PlusJSONBody(ctx context.Context, params *ProgramEligibilityParams, body ProgramEligibilityApplicationVndProgrameligibilityV2PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ProductEligibilityWithBody(ctx context.Context, params *ProductEligibilityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductEligibilityRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductEligibility(ctx context.Context, params *ProductEligibilityParams, body ProductEligibilityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductEligibilityRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProgramEligibilityWithBody(ctx context.Context, params *ProgramEligibilityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProgramEligibilityRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProgramEligibility(ctx context.Context, params *ProgramEligibilityParams, body ProgramEligibilityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProgramEligibilityRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProgramEligibilityWithApplicationVndProgrameligibilityV2PlusJSONBody(ctx context.Context, params *ProgramEligibilityParams, body ProgramEligibilityApplicationVndProgrameligibilityV2PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProgramEligibilityRequestWithApplicationVndProgrameligibilityV2PlusJSONBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewProductEligibilityRequest calls the generic ProductEligibility builder with application/json body
func NewProductEligibilityRequest(server string, params *ProductEligibilityParams, body ProductEligibilityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProductEligibilityRequestWithBody(server, params, "application/json", bodyReader)
}

// NewProductEligibilityRequestWithBody generates requests for ProductEligibility with any type of body
func NewProductEligibilityRequestWithBody(server string, params *ProductEligibilityParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/eligibility/product/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIScope)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-Scope", headerParam1)

	}

	return req, nil
}

// NewProgramEligibilityRequest calls the generic ProgramEligibility builder with application/json body
func NewProgramEligibilityRequest(server string, params *ProgramEligibilityParams, body ProgramEligibilityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProgramEligibilityRequestWithBody(server, params, "application/json", bodyReader)
}

// NewProgramEligibilityRequestWithApplicationVndProgrameligibilityV2PlusJSONBody calls the generic ProgramEligibility builder with application/vnd.programeligibility.v2+json body
func NewProgramEligibilityRequestWithApplicationVndProgrameligibilityV2PlusJSONBody(server string, params *ProgramEligibilityParams, body ProgramEligibilityApplicationVndProgrameligibilityV2PlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProgramEligibilityRequestWithBody(server, params, "application/vnd.programeligibility.v2+json", bodyReader)
}

// NewProgramEligibilityRequestWithBody generates requests for ProgramEligibility with any type of body
func NewProgramEligibilityRequestWithBody(server string, params *ProgramEligibilityParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/eligibility/programs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

		if params.AmazonAdsAccountId != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Ads-AccountId", runtime.ParamLocationHeader, *params.AmazonAdsAccountId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Amazon-Ads-AccountId", headerParam1)
		}

		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-ClientId", runtime.ParamLocationHeader, params.AmazonAdvertisingAPIClientId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Amazon-Advertising-API-ClientId", headerParam2)

		if params.AmazonAdvertisingAPIScope != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "Amazon-Advertising-API-Scope", runtime.ParamLocationHeader, *params.AmazonAdvertisingAPIScope)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Amazon-Advertising-API-Scope", headerParam3)
		}

		if params.ContentType != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, *params.ContentType)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Type", headerParam4)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ProductEligibilityWithBodyWithResponse request with any body
	ProductEligibilityWithBodyWithResponse(ctx context.Context, params *ProductEligibilityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductEligibilityResp, error)

	ProductEligibilityWithResponse(ctx context.Context, params *ProductEligibilityParams, body ProductEligibilityJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductEligibilityResp, error)

	// ProgramEligibilityWithBodyWithResponse request with any body
	ProgramEligibilityWithBodyWithResponse(ctx context.Context, params *ProgramEligibilityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProgramEligibilityResp, error)

	ProgramEligibilityWithResponse(ctx context.Context, params *ProgramEligibilityParams, body ProgramEligibilityJSONRequestBody, reqEditors ...RequestEditorFn) (*ProgramEligibilityResp, error)

	ProgramEligibilityWithApplicationVndProgrameligibilityV2PlusJSONBodyWithResponse(ctx context.Context, params *ProgramEligibilityParams, body ProgramEligibilityApplicationVndProgrameligibilityV2PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ProgramEligibilityResp, error)
}

type ProductEligibilityResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProductEligibilityResponse
	JSON400      *ProductEligibilityError
	JSON401      *ProductEligibilityError
	JSON403      *ProductEligibilityError
	JSON404      *ProductEligibilityError
	JSON422      *ProductEligibilityError
	JSON429      *ProductEligibilityError
	JSON500      *ProductEligibilityError
}

// Status returns HTTPResponse.Status
func (r ProductEligibilityResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductEligibilityResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProgramEligibilityResp struct {
	Body                                      []byte
	HTTPResponse                              *http.Response
	JSON200                                   *ProgramEligibilityResponseContent
	ApplicationvndProgrameligibilityV2JSON200 *ProgramEligibilityV2ResponseContent
	JSON400                                   *BadRequestExceptionResponseContent
	JSON401                                   *UnauthorizedExceptionResponseContent
	JSON404                                   *NotFoundExceptionResponseContent
	JSON429                                   *RateExceededExceptionResponseContent
	JSON500                                   *InternalServerErrorExceptionResponseContent
}

// Status returns HTTPResponse.Status
func (r ProgramEligibilityResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProgramEligibilityResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ProductEligibilityWithBodyWithResponse request with arbitrary body returning *ProductEligibilityResp
func (c *ClientWithResponses) ProductEligibilityWithBodyWithResponse(ctx context.Context, params *ProductEligibilityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProductEligibilityResp, error) {
	rsp, err := c.ProductEligibilityWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductEligibilityResp(rsp)
}

func (c *ClientWithResponses) ProductEligibilityWithResponse(ctx context.Context, params *ProductEligibilityParams, body ProductEligibilityJSONRequestBody, reqEditors ...RequestEditorFn) (*ProductEligibilityResp, error) {
	rsp, err := c.ProductEligibility(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductEligibilityResp(rsp)
}

// ProgramEligibilityWithBodyWithResponse request with arbitrary body returning *ProgramEligibilityResp
func (c *ClientWithResponses) ProgramEligibilityWithBodyWithResponse(ctx context.Context, params *ProgramEligibilityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProgramEligibilityResp, error) {
	rsp, err := c.ProgramEligibilityWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProgramEligibilityResp(rsp)
}

func (c *ClientWithResponses) ProgramEligibilityWithResponse(ctx context.Context, params *ProgramEligibilityParams, body ProgramEligibilityJSONRequestBody, reqEditors ...RequestEditorFn) (*ProgramEligibilityResp, error) {
	rsp, err := c.ProgramEligibility(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProgramEligibilityResp(rsp)
}

func (c *ClientWithResponses) ProgramEligibilityWithApplicationVndProgrameligibilityV2PlusJSONBodyWithResponse(ctx context.Context, params *ProgramEligibilityParams, body ProgramEligibilityApplicationVndProgrameligibilityV2PlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ProgramEligibilityResp, error) {
	rsp, err := c.ProgramEligibilityWithApplicationVndProgrameligibilityV2PlusJSONBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProgramEligibilityResp(rsp)
}

// ParseProductEligibilityResp parses an HTTP response from a ProductEligibilityWithResponse call
func ParseProductEligibilityResp(rsp *http.Response) (*ProductEligibilityResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductEligibilityResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProductEligibilityResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ProductEligibilityError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ProductEligibilityError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ProductEligibilityError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ProductEligibilityError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ProductEligibilityError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ProductEligibilityError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ProductEligibilityError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseProgramEligibilityResp parses an HTTP response from a ProgramEligibilityWithResponse call
func ParseProgramEligibilityResp(rsp *http.Response) (*ProgramEligibilityResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProgramEligibilityResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/json" && rsp.StatusCode == 200:
		var dest ProgramEligibilityResponseContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/vnd.programeligibility.v2+json" && rsp.StatusCode == 200:
		var dest ProgramEligibilityV2ResponseContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndProgrameligibilityV2JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestExceptionResponseContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedExceptionResponseContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundExceptionResponseContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateExceededExceptionResponseContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorExceptionResponseContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
